# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sim2d', [dirname(__file__)])
        except ImportError:
            import _sim2d
            return _sim2d
        if fp is not None:
            try:
                _mod = imp.load_module('_sim2d', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _sim2d = swig_import_helper()
    del swig_import_helper
else:
    import _sim2d
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


import collections
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sim2d.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        """value(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_value(self)


    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2d.SwigPyIterator_incr(self, n)


    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2d.SwigPyIterator_decr(self, n)


    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _sim2d.SwigPyIterator_distance(self, x)


    def equal(self, x: 'SwigPyIterator') -> "bool":
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator_equal(self, x)


    def copy(self) -> "swig::SwigPyIterator *":
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator_copy(self)


    def next(self) -> "PyObject *":
        """next(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_next(self)


    def __next__(self) -> "PyObject *":
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator___next__(self)


    def previous(self) -> "PyObject *":
        """previous(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_previous(self)


    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator_advance(self, n)


    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator___eq__(self, x)


    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___isub__(self, n)


    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___add__(self, n)


    def __sub__(self, *args) -> "ptrdiff_t":
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _sim2d.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _sim2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_sim2d.SHARED_PTR_DISOWN_swigconstant(_sim2d)
SHARED_PTR_DISOWN = _sim2d.SHARED_PTR_DISOWN
class _JammingList(collections.MutableSequence):
    """Proxy of C++ std::list<(JammingList)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _JammingList, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _JammingList, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_JammingList self) -> SwigPyIterator"""
        return _sim2d._JammingList_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_JammingList self) -> bool"""
        return _sim2d._JammingList___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_JammingList self) -> bool"""
        return _sim2d._JammingList___bool__(self)


    def __len__(self) -> "std::list< JammingList >::size_type":
        """__len__(_JammingList self) -> std::list< JammingList >::size_type"""
        return _sim2d._JammingList___len__(self)


    def __getslice__(self, i: 'std::list< JammingList >::difference_type', j: 'std::list< JammingList >::difference_type') -> "std::list< JammingList,std::allocator< JammingList > > *":
        """__getslice__(_JammingList self, std::list< JammingList >::difference_type i, std::list< JammingList >::difference_type j) -> _JammingList"""
        return _sim2d._JammingList___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_JammingList self, std::list< JammingList >::difference_type i, std::list< JammingList >::difference_type j)
        __setslice__(_JammingList self, std::list< JammingList >::difference_type i, std::list< JammingList >::difference_type j, _JammingList v)
        """
        return _sim2d._JammingList___setslice__(self, *args)


    def __delslice__(self, i: 'std::list< JammingList >::difference_type', j: 'std::list< JammingList >::difference_type') -> "void":
        """__delslice__(_JammingList self, std::list< JammingList >::difference_type i, std::list< JammingList >::difference_type j)"""
        return _sim2d._JammingList___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_JammingList self, std::list< JammingList >::difference_type i)
        __delitem__(_JammingList self, PySliceObject * slice)
        """
        return _sim2d._JammingList___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::list< JammingList >::value_type const &":
        """
        __getitem__(_JammingList self, PySliceObject * slice) -> _JammingList
        __getitem__(_JammingList self, std::list< JammingList >::difference_type i) -> JammingList
        """
        return _sim2d._JammingList___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_JammingList self, PySliceObject * slice, _JammingList v)
        __setitem__(_JammingList self, PySliceObject * slice)
        __setitem__(_JammingList self, std::list< JammingList >::difference_type i, JammingList x)
        """
        return _sim2d._JammingList___setitem__(self, *args)


    def pop(self) -> "std::list< JammingList >::value_type":
        """pop(_JammingList self) -> JammingList"""
        return _sim2d._JammingList_pop(self)


    def append(self, x: 'JammingList') -> "void":
        """append(_JammingList self, JammingList x)"""
        return _sim2d._JammingList_append(self, x)


    def empty(self) -> "bool":
        """empty(_JammingList self) -> bool"""
        return _sim2d._JammingList_empty(self)


    def size(self) -> "std::list< JammingList >::size_type":
        """size(_JammingList self) -> std::list< JammingList >::size_type"""
        return _sim2d._JammingList_size(self)


    def swap(self, v: '_JammingList') -> "void":
        """swap(_JammingList self, _JammingList v)"""
        return _sim2d._JammingList_swap(self, v)


    def begin(self) -> "std::list< JammingList >::iterator":
        """begin(_JammingList self) -> std::list< JammingList >::iterator"""
        return _sim2d._JammingList_begin(self)


    def end(self) -> "std::list< JammingList >::iterator":
        """end(_JammingList self) -> std::list< JammingList >::iterator"""
        return _sim2d._JammingList_end(self)


    def rbegin(self) -> "std::list< JammingList >::reverse_iterator":
        """rbegin(_JammingList self) -> std::list< JammingList >::reverse_iterator"""
        return _sim2d._JammingList_rbegin(self)


    def rend(self) -> "std::list< JammingList >::reverse_iterator":
        """rend(_JammingList self) -> std::list< JammingList >::reverse_iterator"""
        return _sim2d._JammingList_rend(self)


    def clear(self) -> "void":
        """clear(_JammingList self)"""
        return _sim2d._JammingList_clear(self)


    def get_allocator(self) -> "std::list< JammingList >::allocator_type":
        """get_allocator(_JammingList self) -> std::list< JammingList >::allocator_type"""
        return _sim2d._JammingList_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_JammingList self)"""
        return _sim2d._JammingList_pop_back(self)


    def erase(self, *args) -> "std::list< JammingList >::iterator":
        """
        erase(_JammingList self, std::list< JammingList >::iterator pos) -> std::list< JammingList >::iterator
        erase(_JammingList self, std::list< JammingList >::iterator first, std::list< JammingList >::iterator last) -> std::list< JammingList >::iterator
        """
        return _sim2d._JammingList_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::list<(JammingList)> self) -> _JammingList
        __init__(std::list<(JammingList)> self, _JammingList arg2) -> _JammingList
        __init__(std::list<(JammingList)> self, std::list< JammingList >::size_type size) -> _JammingList
        __init__(std::list<(JammingList)> self, std::list< JammingList >::size_type size, JammingList value) -> _JammingList
        """
        this = _sim2d.new__JammingList(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'JammingList') -> "void":
        """push_back(_JammingList self, JammingList x)"""
        return _sim2d._JammingList_push_back(self, x)


    def front(self) -> "std::list< JammingList >::value_type const &":
        """front(_JammingList self) -> JammingList"""
        return _sim2d._JammingList_front(self)


    def back(self) -> "std::list< JammingList >::value_type const &":
        """back(_JammingList self) -> JammingList"""
        return _sim2d._JammingList_back(self)


    def assign(self, n: 'std::list< JammingList >::size_type', x: 'JammingList') -> "void":
        """assign(_JammingList self, std::list< JammingList >::size_type n, JammingList x)"""
        return _sim2d._JammingList_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_JammingList self, std::list< JammingList >::size_type new_size)
        resize(_JammingList self, std::list< JammingList >::size_type new_size, JammingList x)
        """
        return _sim2d._JammingList_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_JammingList self, std::list< JammingList >::iterator pos, JammingList x) -> std::list< JammingList >::iterator
        insert(_JammingList self, std::list< JammingList >::iterator pos, std::list< JammingList >::size_type n, JammingList x)
        """
        return _sim2d._JammingList_insert(self, *args)


    def pop_front(self) -> "void":
        """pop_front(_JammingList self)"""
        return _sim2d._JammingList_pop_front(self)


    def push_front(self, x: 'JammingList') -> "void":
        """push_front(_JammingList self, JammingList x)"""
        return _sim2d._JammingList_push_front(self, x)


    def reverse(self) -> "void":
        """reverse(_JammingList self)"""
        return _sim2d._JammingList_reverse(self)

    __swig_destroy__ = _sim2d.delete__JammingList
    __del__ = lambda self: None
_JammingList_swigregister = _sim2d._JammingList_swigregister
_JammingList_swigregister(_JammingList)

class _JammingListRot(collections.MutableSequence):
    """Proxy of C++ std::list<(JammingListRot)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _JammingListRot, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _JammingListRot, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_JammingListRot self) -> SwigPyIterator"""
        return _sim2d._JammingListRot_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_JammingListRot self) -> bool"""
        return _sim2d._JammingListRot___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_JammingListRot self) -> bool"""
        return _sim2d._JammingListRot___bool__(self)


    def __len__(self) -> "std::list< JammingListRot >::size_type":
        """__len__(_JammingListRot self) -> std::list< JammingListRot >::size_type"""
        return _sim2d._JammingListRot___len__(self)


    def __getslice__(self, i: 'std::list< JammingListRot >::difference_type', j: 'std::list< JammingListRot >::difference_type') -> "std::list< JammingListRot,std::allocator< JammingListRot > > *":
        """__getslice__(_JammingListRot self, std::list< JammingListRot >::difference_type i, std::list< JammingListRot >::difference_type j) -> _JammingListRot"""
        return _sim2d._JammingListRot___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_JammingListRot self, std::list< JammingListRot >::difference_type i, std::list< JammingListRot >::difference_type j)
        __setslice__(_JammingListRot self, std::list< JammingListRot >::difference_type i, std::list< JammingListRot >::difference_type j, _JammingListRot v)
        """
        return _sim2d._JammingListRot___setslice__(self, *args)


    def __delslice__(self, i: 'std::list< JammingListRot >::difference_type', j: 'std::list< JammingListRot >::difference_type') -> "void":
        """__delslice__(_JammingListRot self, std::list< JammingListRot >::difference_type i, std::list< JammingListRot >::difference_type j)"""
        return _sim2d._JammingListRot___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_JammingListRot self, std::list< JammingListRot >::difference_type i)
        __delitem__(_JammingListRot self, PySliceObject * slice)
        """
        return _sim2d._JammingListRot___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::list< JammingListRot >::value_type const &":
        """
        __getitem__(_JammingListRot self, PySliceObject * slice) -> _JammingListRot
        __getitem__(_JammingListRot self, std::list< JammingListRot >::difference_type i) -> JammingListRot
        """
        return _sim2d._JammingListRot___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_JammingListRot self, PySliceObject * slice, _JammingListRot v)
        __setitem__(_JammingListRot self, PySliceObject * slice)
        __setitem__(_JammingListRot self, std::list< JammingListRot >::difference_type i, JammingListRot x)
        """
        return _sim2d._JammingListRot___setitem__(self, *args)


    def pop(self) -> "std::list< JammingListRot >::value_type":
        """pop(_JammingListRot self) -> JammingListRot"""
        return _sim2d._JammingListRot_pop(self)


    def append(self, x: 'JammingListRot') -> "void":
        """append(_JammingListRot self, JammingListRot x)"""
        return _sim2d._JammingListRot_append(self, x)


    def empty(self) -> "bool":
        """empty(_JammingListRot self) -> bool"""
        return _sim2d._JammingListRot_empty(self)


    def size(self) -> "std::list< JammingListRot >::size_type":
        """size(_JammingListRot self) -> std::list< JammingListRot >::size_type"""
        return _sim2d._JammingListRot_size(self)


    def swap(self, v: '_JammingListRot') -> "void":
        """swap(_JammingListRot self, _JammingListRot v)"""
        return _sim2d._JammingListRot_swap(self, v)


    def begin(self) -> "std::list< JammingListRot >::iterator":
        """begin(_JammingListRot self) -> std::list< JammingListRot >::iterator"""
        return _sim2d._JammingListRot_begin(self)


    def end(self) -> "std::list< JammingListRot >::iterator":
        """end(_JammingListRot self) -> std::list< JammingListRot >::iterator"""
        return _sim2d._JammingListRot_end(self)


    def rbegin(self) -> "std::list< JammingListRot >::reverse_iterator":
        """rbegin(_JammingListRot self) -> std::list< JammingListRot >::reverse_iterator"""
        return _sim2d._JammingListRot_rbegin(self)


    def rend(self) -> "std::list< JammingListRot >::reverse_iterator":
        """rend(_JammingListRot self) -> std::list< JammingListRot >::reverse_iterator"""
        return _sim2d._JammingListRot_rend(self)


    def clear(self) -> "void":
        """clear(_JammingListRot self)"""
        return _sim2d._JammingListRot_clear(self)


    def get_allocator(self) -> "std::list< JammingListRot >::allocator_type":
        """get_allocator(_JammingListRot self) -> std::list< JammingListRot >::allocator_type"""
        return _sim2d._JammingListRot_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_JammingListRot self)"""
        return _sim2d._JammingListRot_pop_back(self)


    def erase(self, *args) -> "std::list< JammingListRot >::iterator":
        """
        erase(_JammingListRot self, std::list< JammingListRot >::iterator pos) -> std::list< JammingListRot >::iterator
        erase(_JammingListRot self, std::list< JammingListRot >::iterator first, std::list< JammingListRot >::iterator last) -> std::list< JammingListRot >::iterator
        """
        return _sim2d._JammingListRot_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::list<(JammingListRot)> self) -> _JammingListRot
        __init__(std::list<(JammingListRot)> self, _JammingListRot arg2) -> _JammingListRot
        __init__(std::list<(JammingListRot)> self, std::list< JammingListRot >::size_type size) -> _JammingListRot
        __init__(std::list<(JammingListRot)> self, std::list< JammingListRot >::size_type size, JammingListRot value) -> _JammingListRot
        """
        this = _sim2d.new__JammingListRot(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'JammingListRot') -> "void":
        """push_back(_JammingListRot self, JammingListRot x)"""
        return _sim2d._JammingListRot_push_back(self, x)


    def front(self) -> "std::list< JammingListRot >::value_type const &":
        """front(_JammingListRot self) -> JammingListRot"""
        return _sim2d._JammingListRot_front(self)


    def back(self) -> "std::list< JammingListRot >::value_type const &":
        """back(_JammingListRot self) -> JammingListRot"""
        return _sim2d._JammingListRot_back(self)


    def assign(self, n: 'std::list< JammingListRot >::size_type', x: 'JammingListRot') -> "void":
        """assign(_JammingListRot self, std::list< JammingListRot >::size_type n, JammingListRot x)"""
        return _sim2d._JammingListRot_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_JammingListRot self, std::list< JammingListRot >::size_type new_size)
        resize(_JammingListRot self, std::list< JammingListRot >::size_type new_size, JammingListRot x)
        """
        return _sim2d._JammingListRot_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_JammingListRot self, std::list< JammingListRot >::iterator pos, JammingListRot x) -> std::list< JammingListRot >::iterator
        insert(_JammingListRot self, std::list< JammingListRot >::iterator pos, std::list< JammingListRot >::size_type n, JammingListRot x)
        """
        return _sim2d._JammingListRot_insert(self, *args)


    def pop_front(self) -> "void":
        """pop_front(_JammingListRot self)"""
        return _sim2d._JammingListRot_pop_front(self)


    def push_front(self, x: 'JammingListRot') -> "void":
        """push_front(_JammingListRot self, JammingListRot x)"""
        return _sim2d._JammingListRot_push_front(self, x)


    def reverse(self) -> "void":
        """reverse(_JammingListRot self)"""
        return _sim2d._JammingListRot_reverse(self)

    __swig_destroy__ = _sim2d.delete__JammingListRot
    __del__ = lambda self: None
_JammingListRot_swigregister = _sim2d._JammingListRot_swigregister
_JammingListRot_swigregister(_JammingListRot)

class fvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(fvector self) -> SwigPyIterator"""
        return _sim2d.fvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(fvector self) -> bool"""
        return _sim2d.fvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(fvector self) -> bool"""
        return _sim2d.fvector___bool__(self)


    def __len__(self) -> "std::vector< float >::size_type":
        """__len__(fvector self) -> std::vector< float >::size_type"""
        return _sim2d.fvector___len__(self)


    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        """__getslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> fvector"""
        return _sim2d.fvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, fvector v)
        """
        return _sim2d.fvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        """__delslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _sim2d.fvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(fvector self, std::vector< float >::difference_type i)
        __delitem__(fvector self, PySliceObject * slice)
        """
        return _sim2d.fvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        """
        __getitem__(fvector self, PySliceObject * slice) -> fvector
        __getitem__(fvector self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _sim2d.fvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(fvector self, PySliceObject * slice, fvector v)
        __setitem__(fvector self, PySliceObject * slice)
        __setitem__(fvector self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _sim2d.fvector___setitem__(self, *args)


    def pop(self) -> "std::vector< float >::value_type":
        """pop(fvector self) -> std::vector< float >::value_type"""
        return _sim2d.fvector_pop(self)


    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        """append(fvector self, std::vector< float >::value_type const & x)"""
        return _sim2d.fvector_append(self, x)


    def empty(self) -> "bool":
        """empty(fvector self) -> bool"""
        return _sim2d.fvector_empty(self)


    def size(self) -> "std::vector< float >::size_type":
        """size(fvector self) -> std::vector< float >::size_type"""
        return _sim2d.fvector_size(self)


    def swap(self, v: 'fvector') -> "void":
        """swap(fvector self, fvector v)"""
        return _sim2d.fvector_swap(self, v)


    def begin(self) -> "std::vector< float >::iterator":
        """begin(fvector self) -> std::vector< float >::iterator"""
        return _sim2d.fvector_begin(self)


    def end(self) -> "std::vector< float >::iterator":
        """end(fvector self) -> std::vector< float >::iterator"""
        return _sim2d.fvector_end(self)


    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        """rbegin(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim2d.fvector_rbegin(self)


    def rend(self) -> "std::vector< float >::reverse_iterator":
        """rend(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim2d.fvector_rend(self)


    def clear(self) -> "void":
        """clear(fvector self)"""
        return _sim2d.fvector_clear(self)


    def get_allocator(self) -> "std::vector< float >::allocator_type":
        """get_allocator(fvector self) -> std::vector< float >::allocator_type"""
        return _sim2d.fvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(fvector self)"""
        return _sim2d.fvector_pop_back(self)


    def erase(self, *args) -> "std::vector< float >::iterator":
        """
        erase(fvector self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(fvector self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _sim2d.fvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(float)> self) -> fvector
        __init__(std::vector<(float)> self, fvector arg2) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> fvector
        """
        this = _sim2d.new_fvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        """push_back(fvector self, std::vector< float >::value_type const & x)"""
        return _sim2d.fvector_push_back(self, x)


    def front(self) -> "std::vector< float >::value_type const &":
        """front(fvector self) -> std::vector< float >::value_type const &"""
        return _sim2d.fvector_front(self)


    def back(self) -> "std::vector< float >::value_type const &":
        """back(fvector self) -> std::vector< float >::value_type const &"""
        return _sim2d.fvector_back(self)


    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        """assign(fvector self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _sim2d.fvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(fvector self, std::vector< float >::size_type new_size)
        resize(fvector self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _sim2d.fvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _sim2d.fvector_insert(self, *args)


    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        """reserve(fvector self, std::vector< float >::size_type n)"""
        return _sim2d.fvector_reserve(self, n)


    def capacity(self) -> "std::vector< float >::size_type":
        """capacity(fvector self) -> std::vector< float >::size_type"""
        return _sim2d.fvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_fvector
    __del__ = lambda self: None
fvector_swigregister = _sim2d.fvector_swigregister
fvector_swigregister(fvector)

class _ffvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(float)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ffvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ffvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ffvector self) -> SwigPyIterator"""
        return _sim2d._ffvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ffvector self) -> bool"""
        return _sim2d._ffvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ffvector self) -> bool"""
        return _sim2d._ffvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< float > >::size_type":
        """__len__(_ffvector self) -> std::vector< std::vector< float > >::size_type"""
        return _sim2d._ffvector___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > *":
        """__getslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j) -> _ffvector"""
        return _sim2d._ffvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)
        __setslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j, _ffvector v)
        """
        return _sim2d._ffvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "void":
        """__delslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)"""
        return _sim2d._ffvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ffvector self, std::vector< std::vector< float > >::difference_type i)
        __delitem__(_ffvector self, PySliceObject * slice)
        """
        return _sim2d._ffvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< float > >::value_type const &":
        """
        __getitem__(_ffvector self, PySliceObject * slice) -> _ffvector
        __getitem__(_ffvector self, std::vector< std::vector< float > >::difference_type i) -> fvector
        """
        return _sim2d._ffvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ffvector self, PySliceObject * slice, _ffvector v)
        __setitem__(_ffvector self, PySliceObject * slice)
        __setitem__(_ffvector self, std::vector< std::vector< float > >::difference_type i, fvector x)
        """
        return _sim2d._ffvector___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< float > >::value_type":
        """pop(_ffvector self) -> fvector"""
        return _sim2d._ffvector_pop(self)


    def append(self, x: 'fvector') -> "void":
        """append(_ffvector self, fvector x)"""
        return _sim2d._ffvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_ffvector self) -> bool"""
        return _sim2d._ffvector_empty(self)


    def size(self) -> "std::vector< std::vector< float > >::size_type":
        """size(_ffvector self) -> std::vector< std::vector< float > >::size_type"""
        return _sim2d._ffvector_size(self)


    def swap(self, v: '_ffvector') -> "void":
        """swap(_ffvector self, _ffvector v)"""
        return _sim2d._ffvector_swap(self, v)


    def begin(self) -> "std::vector< std::vector< float > >::iterator":
        """begin(_ffvector self) -> std::vector< std::vector< float > >::iterator"""
        return _sim2d._ffvector_begin(self)


    def end(self) -> "std::vector< std::vector< float > >::iterator":
        """end(_ffvector self) -> std::vector< std::vector< float > >::iterator"""
        return _sim2d._ffvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        """rbegin(_ffvector self) -> std::vector< std::vector< float > >::reverse_iterator"""
        return _sim2d._ffvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        """rend(_ffvector self) -> std::vector< std::vector< float > >::reverse_iterator"""
        return _sim2d._ffvector_rend(self)


    def clear(self) -> "void":
        """clear(_ffvector self)"""
        return _sim2d._ffvector_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< float > >::allocator_type":
        """get_allocator(_ffvector self) -> std::vector< std::vector< float > >::allocator_type"""
        return _sim2d._ffvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_ffvector self)"""
        return _sim2d._ffvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< float > >::iterator":
        """
        erase(_ffvector self, std::vector< std::vector< float > >::iterator pos) -> std::vector< std::vector< float > >::iterator
        erase(_ffvector self, std::vector< std::vector< float > >::iterator first, std::vector< std::vector< float > >::iterator last) -> std::vector< std::vector< float > >::iterator
        """
        return _sim2d._ffvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(float)>)> self) -> _ffvector
        __init__(std::vector<(std::vector<(float)>)> self, _ffvector arg2) -> _ffvector
        __init__(std::vector<(std::vector<(float)>)> self, std::vector< std::vector< float > >::size_type size) -> _ffvector
        __init__(std::vector<(std::vector<(float)>)> self, std::vector< std::vector< float > >::size_type size, fvector value) -> _ffvector
        """
        this = _sim2d.new__ffvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'fvector') -> "void":
        """push_back(_ffvector self, fvector x)"""
        return _sim2d._ffvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< float > >::value_type const &":
        """front(_ffvector self) -> fvector"""
        return _sim2d._ffvector_front(self)


    def back(self) -> "std::vector< std::vector< float > >::value_type const &":
        """back(_ffvector self) -> fvector"""
        return _sim2d._ffvector_back(self)


    def assign(self, n: 'std::vector< std::vector< float > >::size_type', x: 'fvector') -> "void":
        """assign(_ffvector self, std::vector< std::vector< float > >::size_type n, fvector x)"""
        return _sim2d._ffvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ffvector self, std::vector< std::vector< float > >::size_type new_size)
        resize(_ffvector self, std::vector< std::vector< float > >::size_type new_size, fvector x)
        """
        return _sim2d._ffvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ffvector self, std::vector< std::vector< float > >::iterator pos, fvector x) -> std::vector< std::vector< float > >::iterator
        insert(_ffvector self, std::vector< std::vector< float > >::iterator pos, std::vector< std::vector< float > >::size_type n, fvector x)
        """
        return _sim2d._ffvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< float > >::size_type') -> "void":
        """reserve(_ffvector self, std::vector< std::vector< float > >::size_type n)"""
        return _sim2d._ffvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< float > >::size_type":
        """capacity(_ffvector self) -> std::vector< std::vector< float > >::size_type"""
        return _sim2d._ffvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__ffvector
    __del__ = lambda self: None
_ffvector_swigregister = _sim2d._ffvector_swigregister
_ffvector_swigregister(_ffvector)

class dvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, dvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(dvector self) -> SwigPyIterator"""
        return _sim2d.dvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(dvector self) -> bool"""
        return _sim2d.dvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(dvector self) -> bool"""
        return _sim2d.dvector___bool__(self)


    def __len__(self) -> "std::vector< double >::size_type":
        """__len__(dvector self) -> std::vector< double >::size_type"""
        return _sim2d.dvector___len__(self)


    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        """__getslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> dvector"""
        return _sim2d.dvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, dvector v)
        """
        return _sim2d.dvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        """__delslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _sim2d.dvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(dvector self, std::vector< double >::difference_type i)
        __delitem__(dvector self, PySliceObject * slice)
        """
        return _sim2d.dvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        """
        __getitem__(dvector self, PySliceObject * slice) -> dvector
        __getitem__(dvector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _sim2d.dvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(dvector self, PySliceObject * slice, dvector v)
        __setitem__(dvector self, PySliceObject * slice)
        __setitem__(dvector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _sim2d.dvector___setitem__(self, *args)


    def pop(self) -> "std::vector< double >::value_type":
        """pop(dvector self) -> std::vector< double >::value_type"""
        return _sim2d.dvector_pop(self)


    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        """append(dvector self, std::vector< double >::value_type const & x)"""
        return _sim2d.dvector_append(self, x)


    def empty(self) -> "bool":
        """empty(dvector self) -> bool"""
        return _sim2d.dvector_empty(self)


    def size(self) -> "std::vector< double >::size_type":
        """size(dvector self) -> std::vector< double >::size_type"""
        return _sim2d.dvector_size(self)


    def swap(self, v: 'dvector') -> "void":
        """swap(dvector self, dvector v)"""
        return _sim2d.dvector_swap(self, v)


    def begin(self) -> "std::vector< double >::iterator":
        """begin(dvector self) -> std::vector< double >::iterator"""
        return _sim2d.dvector_begin(self)


    def end(self) -> "std::vector< double >::iterator":
        """end(dvector self) -> std::vector< double >::iterator"""
        return _sim2d.dvector_end(self)


    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        """rbegin(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim2d.dvector_rbegin(self)


    def rend(self) -> "std::vector< double >::reverse_iterator":
        """rend(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim2d.dvector_rend(self)


    def clear(self) -> "void":
        """clear(dvector self)"""
        return _sim2d.dvector_clear(self)


    def get_allocator(self) -> "std::vector< double >::allocator_type":
        """get_allocator(dvector self) -> std::vector< double >::allocator_type"""
        return _sim2d.dvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(dvector self)"""
        return _sim2d.dvector_pop_back(self)


    def erase(self, *args) -> "std::vector< double >::iterator":
        """
        erase(dvector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(dvector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _sim2d.dvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> dvector
        __init__(std::vector<(double)> self, dvector arg2) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> dvector
        """
        this = _sim2d.new_dvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        """push_back(dvector self, std::vector< double >::value_type const & x)"""
        return _sim2d.dvector_push_back(self, x)


    def front(self) -> "std::vector< double >::value_type const &":
        """front(dvector self) -> std::vector< double >::value_type const &"""
        return _sim2d.dvector_front(self)


    def back(self) -> "std::vector< double >::value_type const &":
        """back(dvector self) -> std::vector< double >::value_type const &"""
        return _sim2d.dvector_back(self)


    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        """assign(dvector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _sim2d.dvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(dvector self, std::vector< double >::size_type new_size)
        resize(dvector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _sim2d.dvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _sim2d.dvector_insert(self, *args)


    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        """reserve(dvector self, std::vector< double >::size_type n)"""
        return _sim2d.dvector_reserve(self, n)


    def capacity(self) -> "std::vector< double >::size_type":
        """capacity(dvector self) -> std::vector< double >::size_type"""
        return _sim2d.dvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_dvector
    __del__ = lambda self: None
dvector_swigregister = _sim2d.dvector_swigregister
dvector_swigregister(dvector)

class _ddvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ddvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ddvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ddvector self) -> SwigPyIterator"""
        return _sim2d._ddvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ddvector self) -> bool"""
        return _sim2d._ddvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ddvector self) -> bool"""
        return _sim2d._ddvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< double > >::size_type":
        """__len__(_ddvector self) -> std::vector< std::vector< double > >::size_type"""
        return _sim2d._ddvector___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< double > >::difference_type', j: 'std::vector< std::vector< double > >::difference_type') -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *":
        """__getslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> _ddvector"""
        return _sim2d._ddvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, _ddvector v)
        """
        return _sim2d._ddvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< double > >::difference_type', j: 'std::vector< std::vector< double > >::difference_type') -> "void":
        """__delslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _sim2d._ddvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ddvector self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(_ddvector self, PySliceObject * slice)
        """
        return _sim2d._ddvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< double > >::value_type const &":
        """
        __getitem__(_ddvector self, PySliceObject * slice) -> _ddvector
        __getitem__(_ddvector self, std::vector< std::vector< double > >::difference_type i) -> dvector
        """
        return _sim2d._ddvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ddvector self, PySliceObject * slice, _ddvector v)
        __setitem__(_ddvector self, PySliceObject * slice)
        __setitem__(_ddvector self, std::vector< std::vector< double > >::difference_type i, dvector x)
        """
        return _sim2d._ddvector___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< double > >::value_type":
        """pop(_ddvector self) -> dvector"""
        return _sim2d._ddvector_pop(self)


    def append(self, x: 'dvector') -> "void":
        """append(_ddvector self, dvector x)"""
        return _sim2d._ddvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_ddvector self) -> bool"""
        return _sim2d._ddvector_empty(self)


    def size(self) -> "std::vector< std::vector< double > >::size_type":
        """size(_ddvector self) -> std::vector< std::vector< double > >::size_type"""
        return _sim2d._ddvector_size(self)


    def swap(self, v: '_ddvector') -> "void":
        """swap(_ddvector self, _ddvector v)"""
        return _sim2d._ddvector_swap(self, v)


    def begin(self) -> "std::vector< std::vector< double > >::iterator":
        """begin(_ddvector self) -> std::vector< std::vector< double > >::iterator"""
        return _sim2d._ddvector_begin(self)


    def end(self) -> "std::vector< std::vector< double > >::iterator":
        """end(_ddvector self) -> std::vector< std::vector< double > >::iterator"""
        return _sim2d._ddvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        """rbegin(_ddvector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _sim2d._ddvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        """rend(_ddvector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _sim2d._ddvector_rend(self)


    def clear(self) -> "void":
        """clear(_ddvector self)"""
        return _sim2d._ddvector_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< double > >::allocator_type":
        """get_allocator(_ddvector self) -> std::vector< std::vector< double > >::allocator_type"""
        return _sim2d._ddvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_ddvector self)"""
        return _sim2d._ddvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< double > >::iterator":
        """
        erase(_ddvector self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(_ddvector self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _sim2d._ddvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> _ddvector
        __init__(std::vector<(std::vector<(double)>)> self, _ddvector arg2) -> _ddvector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> _ddvector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, dvector value) -> _ddvector
        """
        this = _sim2d.new__ddvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'dvector') -> "void":
        """push_back(_ddvector self, dvector x)"""
        return _sim2d._ddvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< double > >::value_type const &":
        """front(_ddvector self) -> dvector"""
        return _sim2d._ddvector_front(self)


    def back(self) -> "std::vector< std::vector< double > >::value_type const &":
        """back(_ddvector self) -> dvector"""
        return _sim2d._ddvector_back(self)


    def assign(self, n: 'std::vector< std::vector< double > >::size_type', x: 'dvector') -> "void":
        """assign(_ddvector self, std::vector< std::vector< double > >::size_type n, dvector x)"""
        return _sim2d._ddvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ddvector self, std::vector< std::vector< double > >::size_type new_size)
        resize(_ddvector self, std::vector< std::vector< double > >::size_type new_size, dvector x)
        """
        return _sim2d._ddvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ddvector self, std::vector< std::vector< double > >::iterator pos, dvector x) -> std::vector< std::vector< double > >::iterator
        insert(_ddvector self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, dvector x)
        """
        return _sim2d._ddvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< double > >::size_type') -> "void":
        """reserve(_ddvector self, std::vector< std::vector< double > >::size_type n)"""
        return _sim2d._ddvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< double > >::size_type":
        """capacity(_ddvector self) -> std::vector< std::vector< double > >::size_type"""
        return _sim2d._ddvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__ddvector
    __del__ = lambda self: None
_ddvector_swigregister = _sim2d._ddvector_swigregister
_ddvector_swigregister(_ddvector)

class _dddvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(double)>)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _dddvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _dddvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_dddvector self) -> SwigPyIterator"""
        return _sim2d._dddvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_dddvector self) -> bool"""
        return _sim2d._dddvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_dddvector self) -> bool"""
        return _sim2d._dddvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::vector< double > > >::size_type":
        """__len__(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _sim2d._dddvector___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::vector< double > > >::difference_type', j: 'std::vector< std::vector< std::vector< double > > >::difference_type') -> "std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > *":
        """__getslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j) -> _dddvector"""
        return _sim2d._dddvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j)
        __setslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j, _dddvector v)
        """
        return _sim2d._dddvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::vector< double > > >::difference_type', j: 'std::vector< std::vector< std::vector< double > > >::difference_type') -> "void":
        """__delslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j)"""
        return _sim2d._dddvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i)
        __delitem__(_dddvector self, PySliceObject * slice)
        """
        return _sim2d._dddvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::vector< double > > >::value_type const &":
        """
        __getitem__(_dddvector self, PySliceObject * slice) -> _dddvector
        __getitem__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i) -> _ddvector
        """
        return _sim2d._dddvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_dddvector self, PySliceObject * slice, _dddvector v)
        __setitem__(_dddvector self, PySliceObject * slice)
        __setitem__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, _ddvector x)
        """
        return _sim2d._dddvector___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< std::vector< double > > >::value_type":
        """pop(_dddvector self) -> _ddvector"""
        return _sim2d._dddvector_pop(self)


    def append(self, x: '_ddvector') -> "void":
        """append(_dddvector self, _ddvector x)"""
        return _sim2d._dddvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_dddvector self) -> bool"""
        return _sim2d._dddvector_empty(self)


    def size(self) -> "std::vector< std::vector< std::vector< double > > >::size_type":
        """size(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _sim2d._dddvector_size(self)


    def swap(self, v: '_dddvector') -> "void":
        """swap(_dddvector self, _dddvector v)"""
        return _sim2d._dddvector_swap(self, v)


    def begin(self) -> "std::vector< std::vector< std::vector< double > > >::iterator":
        """begin(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::iterator"""
        return _sim2d._dddvector_begin(self)


    def end(self) -> "std::vector< std::vector< std::vector< double > > >::iterator":
        """end(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::iterator"""
        return _sim2d._dddvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::vector< double > > >::reverse_iterator":
        """rbegin(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::reverse_iterator"""
        return _sim2d._dddvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::vector< double > > >::reverse_iterator":
        """rend(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::reverse_iterator"""
        return _sim2d._dddvector_rend(self)


    def clear(self) -> "void":
        """clear(_dddvector self)"""
        return _sim2d._dddvector_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< std::vector< double > > >::allocator_type":
        """get_allocator(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::allocator_type"""
        return _sim2d._dddvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_dddvector self)"""
        return _sim2d._dddvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::vector< double > > >::iterator":
        """
        erase(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator pos) -> std::vector< std::vector< std::vector< double > > >::iterator
        erase(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator first, std::vector< std::vector< std::vector< double > > >::iterator last) -> std::vector< std::vector< std::vector< double > > >::iterator
        """
        return _sim2d._dddvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self) -> _dddvector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, _dddvector arg2) -> _dddvector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, std::vector< std::vector< std::vector< double > > >::size_type size) -> _dddvector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, std::vector< std::vector< std::vector< double > > >::size_type size, _ddvector value) -> _dddvector
        """
        this = _sim2d.new__dddvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_ddvector') -> "void":
        """push_back(_dddvector self, _ddvector x)"""
        return _sim2d._dddvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::vector< double > > >::value_type const &":
        """front(_dddvector self) -> _ddvector"""
        return _sim2d._dddvector_front(self)


    def back(self) -> "std::vector< std::vector< std::vector< double > > >::value_type const &":
        """back(_dddvector self) -> _ddvector"""
        return _sim2d._dddvector_back(self)


    def assign(self, n: 'std::vector< std::vector< std::vector< double > > >::size_type', x: '_ddvector') -> "void":
        """assign(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type n, _ddvector x)"""
        return _sim2d._dddvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type new_size)
        resize(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type new_size, _ddvector x)
        """
        return _sim2d._dddvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator pos, _ddvector x) -> std::vector< std::vector< std::vector< double > > >::iterator
        insert(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator pos, std::vector< std::vector< std::vector< double > > >::size_type n, _ddvector x)
        """
        return _sim2d._dddvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::vector< double > > >::size_type') -> "void":
        """reserve(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type n)"""
        return _sim2d._dddvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::vector< double > > >::size_type":
        """capacity(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _sim2d._dddvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__dddvector
    __del__ = lambda self: None
_dddvector_swigregister = _sim2d._dddvector_swigregister
_dddvector_swigregister(_dddvector)

class cvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::complex<(double)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(cvector self) -> SwigPyIterator"""
        return _sim2d.cvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(cvector self) -> bool"""
        return _sim2d.cvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(cvector self) -> bool"""
        return _sim2d.cvector___bool__(self)


    def __len__(self) -> "std::vector< std::complex< double > >::size_type":
        """__len__(cvector self) -> std::vector< std::complex< double > >::size_type"""
        return _sim2d.cvector___len__(self)


    def __getslice__(self, i: 'std::vector< std::complex< double > >::difference_type', j: 'std::vector< std::complex< double > >::difference_type') -> "std::vector< std::complex< double >,std::allocator< std::complex< double > > > *":
        """__getslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> cvector"""
        return _sim2d.cvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, cvector v)
        """
        return _sim2d.cvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::complex< double > >::difference_type', j: 'std::vector< std::complex< double > >::difference_type') -> "void":
        """__delslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _sim2d.cvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(cvector self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(cvector self, PySliceObject * slice)
        """
        return _sim2d.cvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::complex< double > >::value_type const &":
        """
        __getitem__(cvector self, PySliceObject * slice) -> cvector
        __getitem__(cvector self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _sim2d.cvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(cvector self, PySliceObject * slice, cvector v)
        __setitem__(cvector self, PySliceObject * slice)
        __setitem__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _sim2d.cvector___setitem__(self, *args)


    def pop(self) -> "std::vector< std::complex< double > >::value_type":
        """pop(cvector self) -> std::vector< std::complex< double > >::value_type"""
        return _sim2d.cvector_pop(self)


    def append(self, x: 'std::vector< std::complex< double > >::value_type const &') -> "void":
        """append(cvector self, std::vector< std::complex< double > >::value_type const & x)"""
        return _sim2d.cvector_append(self, x)


    def empty(self) -> "bool":
        """empty(cvector self) -> bool"""
        return _sim2d.cvector_empty(self)


    def size(self) -> "std::vector< std::complex< double > >::size_type":
        """size(cvector self) -> std::vector< std::complex< double > >::size_type"""
        return _sim2d.cvector_size(self)


    def swap(self, v: 'cvector') -> "void":
        """swap(cvector self, cvector v)"""
        return _sim2d.cvector_swap(self, v)


    def begin(self) -> "std::vector< std::complex< double > >::iterator":
        """begin(cvector self) -> std::vector< std::complex< double > >::iterator"""
        return _sim2d.cvector_begin(self)


    def end(self) -> "std::vector< std::complex< double > >::iterator":
        """end(cvector self) -> std::vector< std::complex< double > >::iterator"""
        return _sim2d.cvector_end(self)


    def rbegin(self) -> "std::vector< std::complex< double > >::reverse_iterator":
        """rbegin(cvector self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _sim2d.cvector_rbegin(self)


    def rend(self) -> "std::vector< std::complex< double > >::reverse_iterator":
        """rend(cvector self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _sim2d.cvector_rend(self)


    def clear(self) -> "void":
        """clear(cvector self)"""
        return _sim2d.cvector_clear(self)


    def get_allocator(self) -> "std::vector< std::complex< double > >::allocator_type":
        """get_allocator(cvector self) -> std::vector< std::complex< double > >::allocator_type"""
        return _sim2d.cvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(cvector self)"""
        return _sim2d.cvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::complex< double > >::iterator":
        """
        erase(cvector self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(cvector self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _sim2d.cvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::complex<(double)>)> self) -> cvector
        __init__(std::vector<(std::complex<(double)>)> self, cvector arg2) -> cvector
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size) -> cvector
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> cvector
        """
        this = _sim2d.new_cvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::complex< double > >::value_type const &') -> "void":
        """push_back(cvector self, std::vector< std::complex< double > >::value_type const & x)"""
        return _sim2d.cvector_push_back(self, x)


    def front(self) -> "std::vector< std::complex< double > >::value_type const &":
        """front(cvector self) -> std::vector< std::complex< double > >::value_type const &"""
        return _sim2d.cvector_front(self)


    def back(self) -> "std::vector< std::complex< double > >::value_type const &":
        """back(cvector self) -> std::vector< std::complex< double > >::value_type const &"""
        return _sim2d.cvector_back(self)


    def assign(self, n: 'std::vector< std::complex< double > >::size_type', x: 'std::vector< std::complex< double > >::value_type const &') -> "void":
        """assign(cvector self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _sim2d.cvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(cvector self, std::vector< std::complex< double > >::size_type new_size)
        resize(cvector self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _sim2d.cvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(cvector self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(cvector self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _sim2d.cvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::complex< double > >::size_type') -> "void":
        """reserve(cvector self, std::vector< std::complex< double > >::size_type n)"""
        return _sim2d.cvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::complex< double > >::size_type":
        """capacity(cvector self) -> std::vector< std::complex< double > >::size_type"""
        return _sim2d.cvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_cvector
    __del__ = lambda self: None
cvector_swigregister = _sim2d.cvector_swigregister
cvector_swigregister(cvector)

class _ccvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::complex<(double)>)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ccvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ccvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ccvector self) -> SwigPyIterator"""
        return _sim2d._ccvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ccvector self) -> bool"""
        return _sim2d._ccvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ccvector self) -> bool"""
        return _sim2d._ccvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        """__len__(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _sim2d._ccvector___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::complex< double > > >::difference_type', j: 'std::vector< std::vector< std::complex< double > > >::difference_type') -> "std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > > *":
        """__getslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j) -> _ccvector"""
        return _sim2d._ccvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j)
        __setslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j, _ccvector v)
        """
        return _sim2d._ccvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::complex< double > > >::difference_type', j: 'std::vector< std::vector< std::complex< double > > >::difference_type') -> "void":
        """__delslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j)"""
        return _sim2d._ccvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i)
        __delitem__(_ccvector self, PySliceObject * slice)
        """
        return _sim2d._ccvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        """
        __getitem__(_ccvector self, PySliceObject * slice) -> _ccvector
        __getitem__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i) -> cvector
        """
        return _sim2d._ccvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ccvector self, PySliceObject * slice, _ccvector v)
        __setitem__(_ccvector self, PySliceObject * slice)
        __setitem__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, cvector x)
        """
        return _sim2d._ccvector___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< std::complex< double > > >::value_type":
        """pop(_ccvector self) -> cvector"""
        return _sim2d._ccvector_pop(self)


    def append(self, x: 'cvector') -> "void":
        """append(_ccvector self, cvector x)"""
        return _sim2d._ccvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_ccvector self) -> bool"""
        return _sim2d._ccvector_empty(self)


    def size(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        """size(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _sim2d._ccvector_size(self)


    def swap(self, v: '_ccvector') -> "void":
        """swap(_ccvector self, _ccvector v)"""
        return _sim2d._ccvector_swap(self, v)


    def begin(self) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        """begin(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _sim2d._ccvector_begin(self)


    def end(self) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        """end(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _sim2d._ccvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::complex< double > > >::reverse_iterator":
        """rbegin(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _sim2d._ccvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::complex< double > > >::reverse_iterator":
        """rend(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _sim2d._ccvector_rend(self)


    def clear(self) -> "void":
        """clear(_ccvector self)"""
        return _sim2d._ccvector_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< std::complex< double > > >::allocator_type":
        """get_allocator(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::allocator_type"""
        return _sim2d._ccvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_ccvector self)"""
        return _sim2d._ccvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        """
        erase(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator pos) -> std::vector< std::vector< std::complex< double > > >::iterator
        erase(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator first, std::vector< std::vector< std::complex< double > > >::iterator last) -> std::vector< std::vector< std::complex< double > > >::iterator
        """
        return _sim2d._ccvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self) -> _ccvector
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, _ccvector arg2) -> _ccvector
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, std::vector< std::vector< std::complex< double > > >::size_type size) -> _ccvector
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, std::vector< std::vector< std::complex< double > > >::size_type size, cvector value) -> _ccvector
        """
        this = _sim2d.new__ccvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'cvector') -> "void":
        """push_back(_ccvector self, cvector x)"""
        return _sim2d._ccvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        """front(_ccvector self) -> cvector"""
        return _sim2d._ccvector_front(self)


    def back(self) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        """back(_ccvector self) -> cvector"""
        return _sim2d._ccvector_back(self)


    def assign(self, n: 'std::vector< std::vector< std::complex< double > > >::size_type', x: 'cvector') -> "void":
        """assign(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type n, cvector x)"""
        return _sim2d._ccvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type new_size)
        resize(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type new_size, cvector x)
        """
        return _sim2d._ccvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator pos, cvector x) -> std::vector< std::vector< std::complex< double > > >::iterator
        insert(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator pos, std::vector< std::vector< std::complex< double > > >::size_type n, cvector x)
        """
        return _sim2d._ccvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::complex< double > > >::size_type') -> "void":
        """reserve(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type n)"""
        return _sim2d._ccvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        """capacity(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _sim2d._ccvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__ccvector
    __del__ = lambda self: None
_ccvector_swigregister = _sim2d._ccvector_swigregister
_ccvector_swigregister(_ccvector)

class _cccvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cccvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _cccvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_cccvector self) -> SwigPyIterator"""
        return _sim2d._cccvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_cccvector self) -> bool"""
        return _sim2d._cccvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_cccvector self) -> bool"""
        return _sim2d._cccvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::size_type":
        """__len__(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::size_type"""
        return _sim2d._cccvector___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type', j: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type') -> "std::vector< std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > >,std::allocator< std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > > > > *":
        """__getslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j) -> _cccvector"""
        return _sim2d._cccvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j)
        __setslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j, _cccvector v)
        """
        return _sim2d._cccvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type', j: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type') -> "void":
        """__delslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j)"""
        return _sim2d._cccvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i)
        __delitem__(_cccvector self, PySliceObject * slice)
        """
        return _sim2d._cccvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type const &":
        """
        __getitem__(_cccvector self, PySliceObject * slice) -> _cccvector
        __getitem__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i) -> _ccvector
        """
        return _sim2d._cccvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_cccvector self, PySliceObject * slice, _cccvector v)
        __setitem__(_cccvector self, PySliceObject * slice)
        __setitem__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, _ccvector x)
        """
        return _sim2d._cccvector___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type":
        """pop(_cccvector self) -> _ccvector"""
        return _sim2d._cccvector_pop(self)


    def append(self, x: '_ccvector') -> "void":
        """append(_cccvector self, _ccvector x)"""
        return _sim2d._cccvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_cccvector self) -> bool"""
        return _sim2d._cccvector_empty(self)


    def size(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::size_type":
        """size(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::size_type"""
        return _sim2d._cccvector_size(self)


    def swap(self, v: '_cccvector') -> "void":
        """swap(_cccvector self, _cccvector v)"""
        return _sim2d._cccvector_swap(self, v)


    def begin(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::iterator":
        """begin(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator"""
        return _sim2d._cccvector_begin(self)


    def end(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::iterator":
        """end(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator"""
        return _sim2d._cccvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator":
        """rbegin(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator"""
        return _sim2d._cccvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator":
        """rend(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator"""
        return _sim2d._cccvector_rend(self)


    def clear(self) -> "void":
        """clear(_cccvector self)"""
        return _sim2d._cccvector_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::allocator_type":
        """get_allocator(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::allocator_type"""
        return _sim2d._cccvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_cccvector self)"""
        return _sim2d._cccvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::iterator":
        """
        erase(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator pos) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator
        erase(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator first, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator last) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator
        """
        return _sim2d._cccvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self) -> _cccvector
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self, _cccvector arg2) -> _cccvector
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type size) -> _cccvector
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type size, _ccvector value) -> _cccvector
        """
        this = _sim2d.new__cccvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_ccvector') -> "void":
        """push_back(_cccvector self, _ccvector x)"""
        return _sim2d._cccvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type const &":
        """front(_cccvector self) -> _ccvector"""
        return _sim2d._cccvector_front(self)


    def back(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type const &":
        """back(_cccvector self) -> _ccvector"""
        return _sim2d._cccvector_back(self)


    def assign(self, n: 'std::vector< std::vector< std::vector< std::complex< double > > > >::size_type', x: '_ccvector') -> "void":
        """assign(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type n, _ccvector x)"""
        return _sim2d._cccvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type new_size)
        resize(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type new_size, _ccvector x)
        """
        return _sim2d._cccvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator pos, _ccvector x) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator
        insert(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator pos, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type n, _ccvector x)
        """
        return _sim2d._cccvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::vector< std::complex< double > > > >::size_type') -> "void":
        """reserve(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type n)"""
        return _sim2d._cccvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::size_type":
        """capacity(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::size_type"""
        return _sim2d._cccvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__cccvector
    __del__ = lambda self: None
_cccvector_swigregister = _sim2d._cccvector_swigregister
_cccvector_swigregister(_cccvector)

class ldvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(long double)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ldvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ldvector self) -> SwigPyIterator"""
        return _sim2d.ldvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ldvector self) -> bool"""
        return _sim2d.ldvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ldvector self) -> bool"""
        return _sim2d.ldvector___bool__(self)


    def __len__(self) -> "std::vector< long double >::size_type":
        """__len__(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2d.ldvector___len__(self)


    def __getslice__(self, i: 'std::vector< long double >::difference_type', j: 'std::vector< long double >::difference_type') -> "std::vector< long double,std::allocator< long double > > *":
        """__getslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j) -> ldvector"""
        return _sim2d.ldvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j, ldvector v)
        """
        return _sim2d.ldvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< long double >::difference_type', j: 'std::vector< long double >::difference_type') -> "void":
        """__delslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)"""
        return _sim2d.ldvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ldvector self, std::vector< long double >::difference_type i)
        __delitem__(ldvector self, PySliceObject * slice)
        """
        return _sim2d.ldvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< long double >::value_type const &":
        """
        __getitem__(ldvector self, PySliceObject * slice) -> ldvector
        __getitem__(ldvector self, std::vector< long double >::difference_type i) -> std::vector< long double >::value_type const &
        """
        return _sim2d.ldvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ldvector self, PySliceObject * slice, ldvector v)
        __setitem__(ldvector self, PySliceObject * slice)
        __setitem__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::value_type const & x)
        """
        return _sim2d.ldvector___setitem__(self, *args)


    def pop(self) -> "std::vector< long double >::value_type":
        """pop(ldvector self) -> std::vector< long double >::value_type"""
        return _sim2d.ldvector_pop(self)


    def append(self, x: 'std::vector< long double >::value_type const &') -> "void":
        """append(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim2d.ldvector_append(self, x)


    def empty(self) -> "bool":
        """empty(ldvector self) -> bool"""
        return _sim2d.ldvector_empty(self)


    def size(self) -> "std::vector< long double >::size_type":
        """size(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2d.ldvector_size(self)


    def swap(self, v: 'ldvector') -> "void":
        """swap(ldvector self, ldvector v)"""
        return _sim2d.ldvector_swap(self, v)


    def begin(self) -> "std::vector< long double >::iterator":
        """begin(ldvector self) -> std::vector< long double >::iterator"""
        return _sim2d.ldvector_begin(self)


    def end(self) -> "std::vector< long double >::iterator":
        """end(ldvector self) -> std::vector< long double >::iterator"""
        return _sim2d.ldvector_end(self)


    def rbegin(self) -> "std::vector< long double >::reverse_iterator":
        """rbegin(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim2d.ldvector_rbegin(self)


    def rend(self) -> "std::vector< long double >::reverse_iterator":
        """rend(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim2d.ldvector_rend(self)


    def clear(self) -> "void":
        """clear(ldvector self)"""
        return _sim2d.ldvector_clear(self)


    def get_allocator(self) -> "std::vector< long double >::allocator_type":
        """get_allocator(ldvector self) -> std::vector< long double >::allocator_type"""
        return _sim2d.ldvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(ldvector self)"""
        return _sim2d.ldvector_pop_back(self)


    def erase(self, *args) -> "std::vector< long double >::iterator":
        """
        erase(ldvector self, std::vector< long double >::iterator pos) -> std::vector< long double >::iterator
        erase(ldvector self, std::vector< long double >::iterator first, std::vector< long double >::iterator last) -> std::vector< long double >::iterator
        """
        return _sim2d.ldvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(long double)> self) -> ldvector
        __init__(std::vector<(long double)> self, ldvector arg2) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size, std::vector< long double >::value_type const & value) -> ldvector
        """
        this = _sim2d.new_ldvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< long double >::value_type const &') -> "void":
        """push_back(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim2d.ldvector_push_back(self, x)


    def front(self) -> "std::vector< long double >::value_type const &":
        """front(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim2d.ldvector_front(self)


    def back(self) -> "std::vector< long double >::value_type const &":
        """back(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim2d.ldvector_back(self)


    def assign(self, n: 'std::vector< long double >::size_type', x: 'std::vector< long double >::value_type const &') -> "void":
        """assign(ldvector self, std::vector< long double >::size_type n, std::vector< long double >::value_type const & x)"""
        return _sim2d.ldvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ldvector self, std::vector< long double >::size_type new_size)
        resize(ldvector self, std::vector< long double >::size_type new_size, std::vector< long double >::value_type const & x)
        """
        return _sim2d.ldvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::value_type const & x) -> std::vector< long double >::iterator
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::size_type n, std::vector< long double >::value_type const & x)
        """
        return _sim2d.ldvector_insert(self, *args)


    def reserve(self, n: 'std::vector< long double >::size_type') -> "void":
        """reserve(ldvector self, std::vector< long double >::size_type n)"""
        return _sim2d.ldvector_reserve(self, n)


    def capacity(self) -> "std::vector< long double >::size_type":
        """capacity(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2d.ldvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ldvector
    __del__ = lambda self: None
ldvector_swigregister = _sim2d.ldvector_swigregister
ldvector_swigregister(ldvector)

class ivector(collections.MutableSequence):
    """Proxy of C++ std::vector<(boost::shared_ptr<(Interaction)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ivector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ivector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ivector self) -> SwigPyIterator"""
        return _sim2d.ivector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ivector self) -> bool"""
        return _sim2d.ivector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ivector self) -> bool"""
        return _sim2d.ivector___bool__(self)


    def __len__(self) -> "std::vector< boost::shared_ptr< Interaction > >::size_type":
        """__len__(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::size_type"""
        return _sim2d.ivector___len__(self)


    def __getslice__(self, i: 'std::vector< boost::shared_ptr< Interaction > >::difference_type', j: 'std::vector< boost::shared_ptr< Interaction > >::difference_type') -> "std::vector< boost::shared_ptr< Interaction >,std::allocator< boost::shared_ptr< Interaction > > > *":
        """__getslice__(ivector self, std::vector< boost::shared_ptr< Interaction > >::difference_type i, std::vector< boost::shared_ptr< Interaction > >::difference_type j) -> ivector"""
        return _sim2d.ivector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ivector self, std::vector< boost::shared_ptr< Interaction > >::difference_type i, std::vector< boost::shared_ptr< Interaction > >::difference_type j)
        __setslice__(ivector self, std::vector< boost::shared_ptr< Interaction > >::difference_type i, std::vector< boost::shared_ptr< Interaction > >::difference_type j, ivector v)
        """
        return _sim2d.ivector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< boost::shared_ptr< Interaction > >::difference_type', j: 'std::vector< boost::shared_ptr< Interaction > >::difference_type') -> "void":
        """__delslice__(ivector self, std::vector< boost::shared_ptr< Interaction > >::difference_type i, std::vector< boost::shared_ptr< Interaction > >::difference_type j)"""
        return _sim2d.ivector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ivector self, std::vector< boost::shared_ptr< Interaction > >::difference_type i)
        __delitem__(ivector self, PySliceObject * slice)
        """
        return _sim2d.ivector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< boost::shared_ptr< Interaction > >::value_type const &":
        """
        __getitem__(ivector self, PySliceObject * slice) -> ivector
        __getitem__(ivector self, std::vector< boost::shared_ptr< Interaction > >::difference_type i) -> std::vector< boost::shared_ptr< Interaction > >::value_type const &
        """
        return _sim2d.ivector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ivector self, PySliceObject * slice, ivector v)
        __setitem__(ivector self, PySliceObject * slice)
        __setitem__(ivector self, std::vector< boost::shared_ptr< Interaction > >::difference_type i, std::vector< boost::shared_ptr< Interaction > >::value_type const & x)
        """
        return _sim2d.ivector___setitem__(self, *args)


    def pop(self) -> "std::vector< boost::shared_ptr< Interaction > >::value_type":
        """pop(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::value_type"""
        return _sim2d.ivector_pop(self)


    def append(self, x: 'std::vector< boost::shared_ptr< Interaction > >::value_type const &') -> "void":
        """append(ivector self, std::vector< boost::shared_ptr< Interaction > >::value_type const & x)"""
        return _sim2d.ivector_append(self, x)


    def empty(self) -> "bool":
        """empty(ivector self) -> bool"""
        return _sim2d.ivector_empty(self)


    def size(self) -> "std::vector< boost::shared_ptr< Interaction > >::size_type":
        """size(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::size_type"""
        return _sim2d.ivector_size(self)


    def swap(self, v: 'ivector') -> "void":
        """swap(ivector self, ivector v)"""
        return _sim2d.ivector_swap(self, v)


    def begin(self) -> "std::vector< boost::shared_ptr< Interaction > >::iterator":
        """begin(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::iterator"""
        return _sim2d.ivector_begin(self)


    def end(self) -> "std::vector< boost::shared_ptr< Interaction > >::iterator":
        """end(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::iterator"""
        return _sim2d.ivector_end(self)


    def rbegin(self) -> "std::vector< boost::shared_ptr< Interaction > >::reverse_iterator":
        """rbegin(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::reverse_iterator"""
        return _sim2d.ivector_rbegin(self)


    def rend(self) -> "std::vector< boost::shared_ptr< Interaction > >::reverse_iterator":
        """rend(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::reverse_iterator"""
        return _sim2d.ivector_rend(self)


    def clear(self) -> "void":
        """clear(ivector self)"""
        return _sim2d.ivector_clear(self)


    def get_allocator(self) -> "std::vector< boost::shared_ptr< Interaction > >::allocator_type":
        """get_allocator(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::allocator_type"""
        return _sim2d.ivector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(ivector self)"""
        return _sim2d.ivector_pop_back(self)


    def erase(self, *args) -> "std::vector< boost::shared_ptr< Interaction > >::iterator":
        """
        erase(ivector self, std::vector< boost::shared_ptr< Interaction > >::iterator pos) -> std::vector< boost::shared_ptr< Interaction > >::iterator
        erase(ivector self, std::vector< boost::shared_ptr< Interaction > >::iterator first, std::vector< boost::shared_ptr< Interaction > >::iterator last) -> std::vector< boost::shared_ptr< Interaction > >::iterator
        """
        return _sim2d.ivector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(boost::shared_ptr<(Interaction)>)> self) -> ivector
        __init__(std::vector<(boost::shared_ptr<(Interaction)>)> self, ivector arg2) -> ivector
        __init__(std::vector<(boost::shared_ptr<(Interaction)>)> self, std::vector< boost::shared_ptr< Interaction > >::size_type size) -> ivector
        __init__(std::vector<(boost::shared_ptr<(Interaction)>)> self, std::vector< boost::shared_ptr< Interaction > >::size_type size, std::vector< boost::shared_ptr< Interaction > >::value_type const & value) -> ivector
        """
        this = _sim2d.new_ivector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< boost::shared_ptr< Interaction > >::value_type const &') -> "void":
        """push_back(ivector self, std::vector< boost::shared_ptr< Interaction > >::value_type const & x)"""
        return _sim2d.ivector_push_back(self, x)


    def front(self) -> "std::vector< boost::shared_ptr< Interaction > >::value_type const &":
        """front(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::value_type const &"""
        return _sim2d.ivector_front(self)


    def back(self) -> "std::vector< boost::shared_ptr< Interaction > >::value_type const &":
        """back(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::value_type const &"""
        return _sim2d.ivector_back(self)


    def assign(self, n: 'std::vector< boost::shared_ptr< Interaction > >::size_type', x: 'std::vector< boost::shared_ptr< Interaction > >::value_type const &') -> "void":
        """assign(ivector self, std::vector< boost::shared_ptr< Interaction > >::size_type n, std::vector< boost::shared_ptr< Interaction > >::value_type const & x)"""
        return _sim2d.ivector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ivector self, std::vector< boost::shared_ptr< Interaction > >::size_type new_size)
        resize(ivector self, std::vector< boost::shared_ptr< Interaction > >::size_type new_size, std::vector< boost::shared_ptr< Interaction > >::value_type const & x)
        """
        return _sim2d.ivector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ivector self, std::vector< boost::shared_ptr< Interaction > >::iterator pos, std::vector< boost::shared_ptr< Interaction > >::value_type const & x) -> std::vector< boost::shared_ptr< Interaction > >::iterator
        insert(ivector self, std::vector< boost::shared_ptr< Interaction > >::iterator pos, std::vector< boost::shared_ptr< Interaction > >::size_type n, std::vector< boost::shared_ptr< Interaction > >::value_type const & x)
        """
        return _sim2d.ivector_insert(self, *args)


    def reserve(self, n: 'std::vector< boost::shared_ptr< Interaction > >::size_type') -> "void":
        """reserve(ivector self, std::vector< boost::shared_ptr< Interaction > >::size_type n)"""
        return _sim2d.ivector_reserve(self, n)


    def capacity(self) -> "std::vector< boost::shared_ptr< Interaction > >::size_type":
        """capacity(ivector self) -> std::vector< boost::shared_ptr< Interaction > >::size_type"""
        return _sim2d.ivector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ivector
    __del__ = lambda self: None
ivector_swigregister = _sim2d.ivector_swigregister
ivector_swigregister(ivector)

class ifxvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(boost::shared_ptr<(InteractionPairsX)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ifxvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ifxvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ifxvector self) -> SwigPyIterator"""
        return _sim2d.ifxvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ifxvector self) -> bool"""
        return _sim2d.ifxvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ifxvector self) -> bool"""
        return _sim2d.ifxvector___bool__(self)


    def __len__(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::size_type":
        """__len__(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::size_type"""
        return _sim2d.ifxvector___len__(self)


    def __getslice__(self, i: 'std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type', j: 'std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type') -> "std::vector< boost::shared_ptr< InteractionPairsX >,std::allocator< boost::shared_ptr< InteractionPairsX > > > *":
        """__getslice__(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type i, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type j) -> ifxvector"""
        return _sim2d.ifxvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type i, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type j)
        __setslice__(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type i, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type j, ifxvector v)
        """
        return _sim2d.ifxvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type', j: 'std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type') -> "void":
        """__delslice__(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type i, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type j)"""
        return _sim2d.ifxvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type i)
        __delitem__(ifxvector self, PySliceObject * slice)
        """
        return _sim2d.ifxvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &":
        """
        __getitem__(ifxvector self, PySliceObject * slice) -> ifxvector
        __getitem__(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type i) -> std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &
        """
        return _sim2d.ifxvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ifxvector self, PySliceObject * slice, ifxvector v)
        __setitem__(ifxvector self, PySliceObject * slice)
        __setitem__(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::difference_type i, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & x)
        """
        return _sim2d.ifxvector___setitem__(self, *args)


    def pop(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::value_type":
        """pop(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::value_type"""
        return _sim2d.ifxvector_pop(self)


    def append(self, x: 'std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &') -> "void":
        """append(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & x)"""
        return _sim2d.ifxvector_append(self, x)


    def empty(self) -> "bool":
        """empty(ifxvector self) -> bool"""
        return _sim2d.ifxvector_empty(self)


    def size(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::size_type":
        """size(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::size_type"""
        return _sim2d.ifxvector_size(self)


    def swap(self, v: 'ifxvector') -> "void":
        """swap(ifxvector self, ifxvector v)"""
        return _sim2d.ifxvector_swap(self, v)


    def begin(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::iterator":
        """begin(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::iterator"""
        return _sim2d.ifxvector_begin(self)


    def end(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::iterator":
        """end(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::iterator"""
        return _sim2d.ifxvector_end(self)


    def rbegin(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::reverse_iterator":
        """rbegin(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::reverse_iterator"""
        return _sim2d.ifxvector_rbegin(self)


    def rend(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::reverse_iterator":
        """rend(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::reverse_iterator"""
        return _sim2d.ifxvector_rend(self)


    def clear(self) -> "void":
        """clear(ifxvector self)"""
        return _sim2d.ifxvector_clear(self)


    def get_allocator(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::allocator_type":
        """get_allocator(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::allocator_type"""
        return _sim2d.ifxvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(ifxvector self)"""
        return _sim2d.ifxvector_pop_back(self)


    def erase(self, *args) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::iterator":
        """
        erase(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::iterator pos) -> std::vector< boost::shared_ptr< InteractionPairsX > >::iterator
        erase(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::iterator first, std::vector< boost::shared_ptr< InteractionPairsX > >::iterator last) -> std::vector< boost::shared_ptr< InteractionPairsX > >::iterator
        """
        return _sim2d.ifxvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(boost::shared_ptr<(InteractionPairsX)>)> self) -> ifxvector
        __init__(std::vector<(boost::shared_ptr<(InteractionPairsX)>)> self, ifxvector arg2) -> ifxvector
        __init__(std::vector<(boost::shared_ptr<(InteractionPairsX)>)> self, std::vector< boost::shared_ptr< InteractionPairsX > >::size_type size) -> ifxvector
        __init__(std::vector<(boost::shared_ptr<(InteractionPairsX)>)> self, std::vector< boost::shared_ptr< InteractionPairsX > >::size_type size, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & value) -> ifxvector
        """
        this = _sim2d.new_ifxvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &') -> "void":
        """push_back(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & x)"""
        return _sim2d.ifxvector_push_back(self, x)


    def front(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &":
        """front(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &"""
        return _sim2d.ifxvector_front(self)


    def back(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &":
        """back(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &"""
        return _sim2d.ifxvector_back(self)


    def assign(self, n: 'std::vector< boost::shared_ptr< InteractionPairsX > >::size_type', x: 'std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const &') -> "void":
        """assign(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::size_type n, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & x)"""
        return _sim2d.ifxvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::size_type new_size)
        resize(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::size_type new_size, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & x)
        """
        return _sim2d.ifxvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::iterator pos, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & x) -> std::vector< boost::shared_ptr< InteractionPairsX > >::iterator
        insert(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::iterator pos, std::vector< boost::shared_ptr< InteractionPairsX > >::size_type n, std::vector< boost::shared_ptr< InteractionPairsX > >::value_type const & x)
        """
        return _sim2d.ifxvector_insert(self, *args)


    def reserve(self, n: 'std::vector< boost::shared_ptr< InteractionPairsX > >::size_type') -> "void":
        """reserve(ifxvector self, std::vector< boost::shared_ptr< InteractionPairsX > >::size_type n)"""
        return _sim2d.ifxvector_reserve(self, n)


    def capacity(self) -> "std::vector< boost::shared_ptr< InteractionPairsX > >::size_type":
        """capacity(ifxvector self) -> std::vector< boost::shared_ptr< InteractionPairsX > >::size_type"""
        return _sim2d.ifxvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ifxvector
    __del__ = lambda self: None
ifxvector_swigregister = _sim2d.ifxvector_swigregister
ifxvector_swigregister(ifxvector)

class tvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(boost::shared_ptr<(StateTracker)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, tvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(tvector self) -> SwigPyIterator"""
        return _sim2d.tvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(tvector self) -> bool"""
        return _sim2d.tvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(tvector self) -> bool"""
        return _sim2d.tvector___bool__(self)


    def __len__(self) -> "std::vector< boost::shared_ptr< StateTracker > >::size_type":
        """__len__(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::size_type"""
        return _sim2d.tvector___len__(self)


    def __getslice__(self, i: 'std::vector< boost::shared_ptr< StateTracker > >::difference_type', j: 'std::vector< boost::shared_ptr< StateTracker > >::difference_type') -> "std::vector< boost::shared_ptr< StateTracker >,std::allocator< boost::shared_ptr< StateTracker > > > *":
        """__getslice__(tvector self, std::vector< boost::shared_ptr< StateTracker > >::difference_type i, std::vector< boost::shared_ptr< StateTracker > >::difference_type j) -> tvector"""
        return _sim2d.tvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(tvector self, std::vector< boost::shared_ptr< StateTracker > >::difference_type i, std::vector< boost::shared_ptr< StateTracker > >::difference_type j)
        __setslice__(tvector self, std::vector< boost::shared_ptr< StateTracker > >::difference_type i, std::vector< boost::shared_ptr< StateTracker > >::difference_type j, tvector v)
        """
        return _sim2d.tvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< boost::shared_ptr< StateTracker > >::difference_type', j: 'std::vector< boost::shared_ptr< StateTracker > >::difference_type') -> "void":
        """__delslice__(tvector self, std::vector< boost::shared_ptr< StateTracker > >::difference_type i, std::vector< boost::shared_ptr< StateTracker > >::difference_type j)"""
        return _sim2d.tvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(tvector self, std::vector< boost::shared_ptr< StateTracker > >::difference_type i)
        __delitem__(tvector self, PySliceObject * slice)
        """
        return _sim2d.tvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< boost::shared_ptr< StateTracker > >::value_type const &":
        """
        __getitem__(tvector self, PySliceObject * slice) -> tvector
        __getitem__(tvector self, std::vector< boost::shared_ptr< StateTracker > >::difference_type i) -> std::vector< boost::shared_ptr< StateTracker > >::value_type const &
        """
        return _sim2d.tvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(tvector self, PySliceObject * slice, tvector v)
        __setitem__(tvector self, PySliceObject * slice)
        __setitem__(tvector self, std::vector< boost::shared_ptr< StateTracker > >::difference_type i, std::vector< boost::shared_ptr< StateTracker > >::value_type const & x)
        """
        return _sim2d.tvector___setitem__(self, *args)


    def pop(self) -> "std::vector< boost::shared_ptr< StateTracker > >::value_type":
        """pop(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::value_type"""
        return _sim2d.tvector_pop(self)


    def append(self, x: 'std::vector< boost::shared_ptr< StateTracker > >::value_type const &') -> "void":
        """append(tvector self, std::vector< boost::shared_ptr< StateTracker > >::value_type const & x)"""
        return _sim2d.tvector_append(self, x)


    def empty(self) -> "bool":
        """empty(tvector self) -> bool"""
        return _sim2d.tvector_empty(self)


    def size(self) -> "std::vector< boost::shared_ptr< StateTracker > >::size_type":
        """size(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::size_type"""
        return _sim2d.tvector_size(self)


    def swap(self, v: 'tvector') -> "void":
        """swap(tvector self, tvector v)"""
        return _sim2d.tvector_swap(self, v)


    def begin(self) -> "std::vector< boost::shared_ptr< StateTracker > >::iterator":
        """begin(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::iterator"""
        return _sim2d.tvector_begin(self)


    def end(self) -> "std::vector< boost::shared_ptr< StateTracker > >::iterator":
        """end(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::iterator"""
        return _sim2d.tvector_end(self)


    def rbegin(self) -> "std::vector< boost::shared_ptr< StateTracker > >::reverse_iterator":
        """rbegin(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::reverse_iterator"""
        return _sim2d.tvector_rbegin(self)


    def rend(self) -> "std::vector< boost::shared_ptr< StateTracker > >::reverse_iterator":
        """rend(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::reverse_iterator"""
        return _sim2d.tvector_rend(self)


    def clear(self) -> "void":
        """clear(tvector self)"""
        return _sim2d.tvector_clear(self)


    def get_allocator(self) -> "std::vector< boost::shared_ptr< StateTracker > >::allocator_type":
        """get_allocator(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::allocator_type"""
        return _sim2d.tvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(tvector self)"""
        return _sim2d.tvector_pop_back(self)


    def erase(self, *args) -> "std::vector< boost::shared_ptr< StateTracker > >::iterator":
        """
        erase(tvector self, std::vector< boost::shared_ptr< StateTracker > >::iterator pos) -> std::vector< boost::shared_ptr< StateTracker > >::iterator
        erase(tvector self, std::vector< boost::shared_ptr< StateTracker > >::iterator first, std::vector< boost::shared_ptr< StateTracker > >::iterator last) -> std::vector< boost::shared_ptr< StateTracker > >::iterator
        """
        return _sim2d.tvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(boost::shared_ptr<(StateTracker)>)> self) -> tvector
        __init__(std::vector<(boost::shared_ptr<(StateTracker)>)> self, tvector arg2) -> tvector
        __init__(std::vector<(boost::shared_ptr<(StateTracker)>)> self, std::vector< boost::shared_ptr< StateTracker > >::size_type size) -> tvector
        __init__(std::vector<(boost::shared_ptr<(StateTracker)>)> self, std::vector< boost::shared_ptr< StateTracker > >::size_type size, std::vector< boost::shared_ptr< StateTracker > >::value_type const & value) -> tvector
        """
        this = _sim2d.new_tvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< boost::shared_ptr< StateTracker > >::value_type const &') -> "void":
        """push_back(tvector self, std::vector< boost::shared_ptr< StateTracker > >::value_type const & x)"""
        return _sim2d.tvector_push_back(self, x)


    def front(self) -> "std::vector< boost::shared_ptr< StateTracker > >::value_type const &":
        """front(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::value_type const &"""
        return _sim2d.tvector_front(self)


    def back(self) -> "std::vector< boost::shared_ptr< StateTracker > >::value_type const &":
        """back(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::value_type const &"""
        return _sim2d.tvector_back(self)


    def assign(self, n: 'std::vector< boost::shared_ptr< StateTracker > >::size_type', x: 'std::vector< boost::shared_ptr< StateTracker > >::value_type const &') -> "void":
        """assign(tvector self, std::vector< boost::shared_ptr< StateTracker > >::size_type n, std::vector< boost::shared_ptr< StateTracker > >::value_type const & x)"""
        return _sim2d.tvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(tvector self, std::vector< boost::shared_ptr< StateTracker > >::size_type new_size)
        resize(tvector self, std::vector< boost::shared_ptr< StateTracker > >::size_type new_size, std::vector< boost::shared_ptr< StateTracker > >::value_type const & x)
        """
        return _sim2d.tvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(tvector self, std::vector< boost::shared_ptr< StateTracker > >::iterator pos, std::vector< boost::shared_ptr< StateTracker > >::value_type const & x) -> std::vector< boost::shared_ptr< StateTracker > >::iterator
        insert(tvector self, std::vector< boost::shared_ptr< StateTracker > >::iterator pos, std::vector< boost::shared_ptr< StateTracker > >::size_type n, std::vector< boost::shared_ptr< StateTracker > >::value_type const & x)
        """
        return _sim2d.tvector_insert(self, *args)


    def reserve(self, n: 'std::vector< boost::shared_ptr< StateTracker > >::size_type') -> "void":
        """reserve(tvector self, std::vector< boost::shared_ptr< StateTracker > >::size_type n)"""
        return _sim2d.tvector_reserve(self, n)


    def capacity(self) -> "std::vector< boost::shared_ptr< StateTracker > >::size_type":
        """capacity(tvector self) -> std::vector< boost::shared_ptr< StateTracker > >::size_type"""
        return _sim2d.tvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_tvector
    __del__ = lambda self: None
tvector_swigregister = _sim2d.tvector_swigregister
tvector_swigregister(tvector)

class constraintvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(boost::shared_ptr<(Constraint)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraintvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, constraintvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(constraintvector self) -> SwigPyIterator"""
        return _sim2d.constraintvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(constraintvector self) -> bool"""
        return _sim2d.constraintvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(constraintvector self) -> bool"""
        return _sim2d.constraintvector___bool__(self)


    def __len__(self) -> "std::vector< boost::shared_ptr< Constraint > >::size_type":
        """__len__(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::size_type"""
        return _sim2d.constraintvector___len__(self)


    def __getslice__(self, i: 'std::vector< boost::shared_ptr< Constraint > >::difference_type', j: 'std::vector< boost::shared_ptr< Constraint > >::difference_type') -> "std::vector< boost::shared_ptr< Constraint >,std::allocator< boost::shared_ptr< Constraint > > > *":
        """__getslice__(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::difference_type i, std::vector< boost::shared_ptr< Constraint > >::difference_type j) -> constraintvector"""
        return _sim2d.constraintvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::difference_type i, std::vector< boost::shared_ptr< Constraint > >::difference_type j)
        __setslice__(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::difference_type i, std::vector< boost::shared_ptr< Constraint > >::difference_type j, constraintvector v)
        """
        return _sim2d.constraintvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< boost::shared_ptr< Constraint > >::difference_type', j: 'std::vector< boost::shared_ptr< Constraint > >::difference_type') -> "void":
        """__delslice__(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::difference_type i, std::vector< boost::shared_ptr< Constraint > >::difference_type j)"""
        return _sim2d.constraintvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::difference_type i)
        __delitem__(constraintvector self, PySliceObject * slice)
        """
        return _sim2d.constraintvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< boost::shared_ptr< Constraint > >::value_type const &":
        """
        __getitem__(constraintvector self, PySliceObject * slice) -> constraintvector
        __getitem__(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::difference_type i) -> std::vector< boost::shared_ptr< Constraint > >::value_type const &
        """
        return _sim2d.constraintvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(constraintvector self, PySliceObject * slice, constraintvector v)
        __setitem__(constraintvector self, PySliceObject * slice)
        __setitem__(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::difference_type i, std::vector< boost::shared_ptr< Constraint > >::value_type const & x)
        """
        return _sim2d.constraintvector___setitem__(self, *args)


    def pop(self) -> "std::vector< boost::shared_ptr< Constraint > >::value_type":
        """pop(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::value_type"""
        return _sim2d.constraintvector_pop(self)


    def append(self, x: 'std::vector< boost::shared_ptr< Constraint > >::value_type const &') -> "void":
        """append(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::value_type const & x)"""
        return _sim2d.constraintvector_append(self, x)


    def empty(self) -> "bool":
        """empty(constraintvector self) -> bool"""
        return _sim2d.constraintvector_empty(self)


    def size(self) -> "std::vector< boost::shared_ptr< Constraint > >::size_type":
        """size(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::size_type"""
        return _sim2d.constraintvector_size(self)


    def swap(self, v: 'constraintvector') -> "void":
        """swap(constraintvector self, constraintvector v)"""
        return _sim2d.constraintvector_swap(self, v)


    def begin(self) -> "std::vector< boost::shared_ptr< Constraint > >::iterator":
        """begin(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::iterator"""
        return _sim2d.constraintvector_begin(self)


    def end(self) -> "std::vector< boost::shared_ptr< Constraint > >::iterator":
        """end(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::iterator"""
        return _sim2d.constraintvector_end(self)


    def rbegin(self) -> "std::vector< boost::shared_ptr< Constraint > >::reverse_iterator":
        """rbegin(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::reverse_iterator"""
        return _sim2d.constraintvector_rbegin(self)


    def rend(self) -> "std::vector< boost::shared_ptr< Constraint > >::reverse_iterator":
        """rend(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::reverse_iterator"""
        return _sim2d.constraintvector_rend(self)


    def clear(self) -> "void":
        """clear(constraintvector self)"""
        return _sim2d.constraintvector_clear(self)


    def get_allocator(self) -> "std::vector< boost::shared_ptr< Constraint > >::allocator_type":
        """get_allocator(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::allocator_type"""
        return _sim2d.constraintvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(constraintvector self)"""
        return _sim2d.constraintvector_pop_back(self)


    def erase(self, *args) -> "std::vector< boost::shared_ptr< Constraint > >::iterator":
        """
        erase(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::iterator pos) -> std::vector< boost::shared_ptr< Constraint > >::iterator
        erase(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::iterator first, std::vector< boost::shared_ptr< Constraint > >::iterator last) -> std::vector< boost::shared_ptr< Constraint > >::iterator
        """
        return _sim2d.constraintvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(boost::shared_ptr<(Constraint)>)> self) -> constraintvector
        __init__(std::vector<(boost::shared_ptr<(Constraint)>)> self, constraintvector arg2) -> constraintvector
        __init__(std::vector<(boost::shared_ptr<(Constraint)>)> self, std::vector< boost::shared_ptr< Constraint > >::size_type size) -> constraintvector
        __init__(std::vector<(boost::shared_ptr<(Constraint)>)> self, std::vector< boost::shared_ptr< Constraint > >::size_type size, std::vector< boost::shared_ptr< Constraint > >::value_type const & value) -> constraintvector
        """
        this = _sim2d.new_constraintvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< boost::shared_ptr< Constraint > >::value_type const &') -> "void":
        """push_back(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::value_type const & x)"""
        return _sim2d.constraintvector_push_back(self, x)


    def front(self) -> "std::vector< boost::shared_ptr< Constraint > >::value_type const &":
        """front(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::value_type const &"""
        return _sim2d.constraintvector_front(self)


    def back(self) -> "std::vector< boost::shared_ptr< Constraint > >::value_type const &":
        """back(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::value_type const &"""
        return _sim2d.constraintvector_back(self)


    def assign(self, n: 'std::vector< boost::shared_ptr< Constraint > >::size_type', x: 'std::vector< boost::shared_ptr< Constraint > >::value_type const &') -> "void":
        """assign(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::size_type n, std::vector< boost::shared_ptr< Constraint > >::value_type const & x)"""
        return _sim2d.constraintvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::size_type new_size)
        resize(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::size_type new_size, std::vector< boost::shared_ptr< Constraint > >::value_type const & x)
        """
        return _sim2d.constraintvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::iterator pos, std::vector< boost::shared_ptr< Constraint > >::value_type const & x) -> std::vector< boost::shared_ptr< Constraint > >::iterator
        insert(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::iterator pos, std::vector< boost::shared_ptr< Constraint > >::size_type n, std::vector< boost::shared_ptr< Constraint > >::value_type const & x)
        """
        return _sim2d.constraintvector_insert(self, *args)


    def reserve(self, n: 'std::vector< boost::shared_ptr< Constraint > >::size_type') -> "void":
        """reserve(constraintvector self, std::vector< boost::shared_ptr< Constraint > >::size_type n)"""
        return _sim2d.constraintvector_reserve(self, n)


    def capacity(self) -> "std::vector< boost::shared_ptr< Constraint > >::size_type":
        """capacity(constraintvector self) -> std::vector< boost::shared_ptr< Constraint > >::size_type"""
        return _sim2d.constraintvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_constraintvector
    __del__ = lambda self: None
constraintvector_swigregister = _sim2d.constraintvector_swigregister
constraintvector_swigregister(constraintvector)

class wallvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(boost::shared_ptr<(SoftWall)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, wallvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, wallvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(wallvector self) -> SwigPyIterator"""
        return _sim2d.wallvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(wallvector self) -> bool"""
        return _sim2d.wallvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(wallvector self) -> bool"""
        return _sim2d.wallvector___bool__(self)


    def __len__(self) -> "std::vector< boost::shared_ptr< SoftWall > >::size_type":
        """__len__(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::size_type"""
        return _sim2d.wallvector___len__(self)


    def __getslice__(self, i: 'std::vector< boost::shared_ptr< SoftWall > >::difference_type', j: 'std::vector< boost::shared_ptr< SoftWall > >::difference_type') -> "std::vector< boost::shared_ptr< SoftWall >,std::allocator< boost::shared_ptr< SoftWall > > > *":
        """__getslice__(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::difference_type i, std::vector< boost::shared_ptr< SoftWall > >::difference_type j) -> wallvector"""
        return _sim2d.wallvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::difference_type i, std::vector< boost::shared_ptr< SoftWall > >::difference_type j)
        __setslice__(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::difference_type i, std::vector< boost::shared_ptr< SoftWall > >::difference_type j, wallvector v)
        """
        return _sim2d.wallvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< boost::shared_ptr< SoftWall > >::difference_type', j: 'std::vector< boost::shared_ptr< SoftWall > >::difference_type') -> "void":
        """__delslice__(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::difference_type i, std::vector< boost::shared_ptr< SoftWall > >::difference_type j)"""
        return _sim2d.wallvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::difference_type i)
        __delitem__(wallvector self, PySliceObject * slice)
        """
        return _sim2d.wallvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< boost::shared_ptr< SoftWall > >::value_type const &":
        """
        __getitem__(wallvector self, PySliceObject * slice) -> wallvector
        __getitem__(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::difference_type i) -> std::vector< boost::shared_ptr< SoftWall > >::value_type const &
        """
        return _sim2d.wallvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(wallvector self, PySliceObject * slice, wallvector v)
        __setitem__(wallvector self, PySliceObject * slice)
        __setitem__(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::difference_type i, std::vector< boost::shared_ptr< SoftWall > >::value_type const & x)
        """
        return _sim2d.wallvector___setitem__(self, *args)


    def pop(self) -> "std::vector< boost::shared_ptr< SoftWall > >::value_type":
        """pop(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::value_type"""
        return _sim2d.wallvector_pop(self)


    def append(self, x: 'std::vector< boost::shared_ptr< SoftWall > >::value_type const &') -> "void":
        """append(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::value_type const & x)"""
        return _sim2d.wallvector_append(self, x)


    def empty(self) -> "bool":
        """empty(wallvector self) -> bool"""
        return _sim2d.wallvector_empty(self)


    def size(self) -> "std::vector< boost::shared_ptr< SoftWall > >::size_type":
        """size(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::size_type"""
        return _sim2d.wallvector_size(self)


    def swap(self, v: 'wallvector') -> "void":
        """swap(wallvector self, wallvector v)"""
        return _sim2d.wallvector_swap(self, v)


    def begin(self) -> "std::vector< boost::shared_ptr< SoftWall > >::iterator":
        """begin(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::iterator"""
        return _sim2d.wallvector_begin(self)


    def end(self) -> "std::vector< boost::shared_ptr< SoftWall > >::iterator":
        """end(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::iterator"""
        return _sim2d.wallvector_end(self)


    def rbegin(self) -> "std::vector< boost::shared_ptr< SoftWall > >::reverse_iterator":
        """rbegin(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::reverse_iterator"""
        return _sim2d.wallvector_rbegin(self)


    def rend(self) -> "std::vector< boost::shared_ptr< SoftWall > >::reverse_iterator":
        """rend(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::reverse_iterator"""
        return _sim2d.wallvector_rend(self)


    def clear(self) -> "void":
        """clear(wallvector self)"""
        return _sim2d.wallvector_clear(self)


    def get_allocator(self) -> "std::vector< boost::shared_ptr< SoftWall > >::allocator_type":
        """get_allocator(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::allocator_type"""
        return _sim2d.wallvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(wallvector self)"""
        return _sim2d.wallvector_pop_back(self)


    def erase(self, *args) -> "std::vector< boost::shared_ptr< SoftWall > >::iterator":
        """
        erase(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::iterator pos) -> std::vector< boost::shared_ptr< SoftWall > >::iterator
        erase(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::iterator first, std::vector< boost::shared_ptr< SoftWall > >::iterator last) -> std::vector< boost::shared_ptr< SoftWall > >::iterator
        """
        return _sim2d.wallvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(boost::shared_ptr<(SoftWall)>)> self) -> wallvector
        __init__(std::vector<(boost::shared_ptr<(SoftWall)>)> self, wallvector arg2) -> wallvector
        __init__(std::vector<(boost::shared_ptr<(SoftWall)>)> self, std::vector< boost::shared_ptr< SoftWall > >::size_type size) -> wallvector
        __init__(std::vector<(boost::shared_ptr<(SoftWall)>)> self, std::vector< boost::shared_ptr< SoftWall > >::size_type size, std::vector< boost::shared_ptr< SoftWall > >::value_type const & value) -> wallvector
        """
        this = _sim2d.new_wallvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< boost::shared_ptr< SoftWall > >::value_type const &') -> "void":
        """push_back(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::value_type const & x)"""
        return _sim2d.wallvector_push_back(self, x)


    def front(self) -> "std::vector< boost::shared_ptr< SoftWall > >::value_type const &":
        """front(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::value_type const &"""
        return _sim2d.wallvector_front(self)


    def back(self) -> "std::vector< boost::shared_ptr< SoftWall > >::value_type const &":
        """back(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::value_type const &"""
        return _sim2d.wallvector_back(self)


    def assign(self, n: 'std::vector< boost::shared_ptr< SoftWall > >::size_type', x: 'std::vector< boost::shared_ptr< SoftWall > >::value_type const &') -> "void":
        """assign(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::size_type n, std::vector< boost::shared_ptr< SoftWall > >::value_type const & x)"""
        return _sim2d.wallvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::size_type new_size)
        resize(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::size_type new_size, std::vector< boost::shared_ptr< SoftWall > >::value_type const & x)
        """
        return _sim2d.wallvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::iterator pos, std::vector< boost::shared_ptr< SoftWall > >::value_type const & x) -> std::vector< boost::shared_ptr< SoftWall > >::iterator
        insert(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::iterator pos, std::vector< boost::shared_ptr< SoftWall > >::size_type n, std::vector< boost::shared_ptr< SoftWall > >::value_type const & x)
        """
        return _sim2d.wallvector_insert(self, *args)


    def reserve(self, n: 'std::vector< boost::shared_ptr< SoftWall > >::size_type') -> "void":
        """reserve(wallvector self, std::vector< boost::shared_ptr< SoftWall > >::size_type n)"""
        return _sim2d.wallvector_reserve(self, n)


    def capacity(self) -> "std::vector< boost::shared_ptr< SoftWall > >::size_type":
        """capacity(wallvector self) -> std::vector< boost::shared_ptr< SoftWall > >::size_type"""
        return _sim2d.wallvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_wallvector
    __del__ = lambda self: None
wallvector_swigregister = _sim2d.wallvector_swigregister
wallvector_swigregister(wallvector)

class idvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(AtomID)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, idvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, idvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(idvector self) -> SwigPyIterator"""
        return _sim2d.idvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(idvector self) -> bool"""
        return _sim2d.idvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(idvector self) -> bool"""
        return _sim2d.idvector___bool__(self)


    def __len__(self) -> "std::vector< AtomID >::size_type":
        """__len__(idvector self) -> std::vector< AtomID >::size_type"""
        return _sim2d.idvector___len__(self)


    def __getslice__(self, i: 'std::vector< AtomID >::difference_type', j: 'std::vector< AtomID >::difference_type') -> "std::vector< AtomID,std::allocator< AtomID > > *":
        """__getslice__(idvector self, std::vector< AtomID >::difference_type i, std::vector< AtomID >::difference_type j) -> idvector"""
        return _sim2d.idvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(idvector self, std::vector< AtomID >::difference_type i, std::vector< AtomID >::difference_type j)
        __setslice__(idvector self, std::vector< AtomID >::difference_type i, std::vector< AtomID >::difference_type j, idvector v)
        """
        return _sim2d.idvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< AtomID >::difference_type', j: 'std::vector< AtomID >::difference_type') -> "void":
        """__delslice__(idvector self, std::vector< AtomID >::difference_type i, std::vector< AtomID >::difference_type j)"""
        return _sim2d.idvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(idvector self, std::vector< AtomID >::difference_type i)
        __delitem__(idvector self, PySliceObject * slice)
        """
        return _sim2d.idvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< AtomID >::value_type const &":
        """
        __getitem__(idvector self, PySliceObject * slice) -> idvector
        __getitem__(idvector self, std::vector< AtomID >::difference_type i) -> AtomID
        """
        return _sim2d.idvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(idvector self, PySliceObject * slice, idvector v)
        __setitem__(idvector self, PySliceObject * slice)
        __setitem__(idvector self, std::vector< AtomID >::difference_type i, AtomID x)
        """
        return _sim2d.idvector___setitem__(self, *args)


    def pop(self) -> "std::vector< AtomID >::value_type":
        """pop(idvector self) -> AtomID"""
        return _sim2d.idvector_pop(self)


    def append(self, x: 'AtomID') -> "void":
        """append(idvector self, AtomID x)"""
        return _sim2d.idvector_append(self, x)


    def empty(self) -> "bool":
        """empty(idvector self) -> bool"""
        return _sim2d.idvector_empty(self)


    def size(self) -> "std::vector< AtomID >::size_type":
        """size(idvector self) -> std::vector< AtomID >::size_type"""
        return _sim2d.idvector_size(self)


    def swap(self, v: 'idvector') -> "void":
        """swap(idvector self, idvector v)"""
        return _sim2d.idvector_swap(self, v)


    def begin(self) -> "std::vector< AtomID >::iterator":
        """begin(idvector self) -> std::vector< AtomID >::iterator"""
        return _sim2d.idvector_begin(self)


    def end(self) -> "std::vector< AtomID >::iterator":
        """end(idvector self) -> std::vector< AtomID >::iterator"""
        return _sim2d.idvector_end(self)


    def rbegin(self) -> "std::vector< AtomID >::reverse_iterator":
        """rbegin(idvector self) -> std::vector< AtomID >::reverse_iterator"""
        return _sim2d.idvector_rbegin(self)


    def rend(self) -> "std::vector< AtomID >::reverse_iterator":
        """rend(idvector self) -> std::vector< AtomID >::reverse_iterator"""
        return _sim2d.idvector_rend(self)


    def clear(self) -> "void":
        """clear(idvector self)"""
        return _sim2d.idvector_clear(self)


    def get_allocator(self) -> "std::vector< AtomID >::allocator_type":
        """get_allocator(idvector self) -> std::vector< AtomID >::allocator_type"""
        return _sim2d.idvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(idvector self)"""
        return _sim2d.idvector_pop_back(self)


    def erase(self, *args) -> "std::vector< AtomID >::iterator":
        """
        erase(idvector self, std::vector< AtomID >::iterator pos) -> std::vector< AtomID >::iterator
        erase(idvector self, std::vector< AtomID >::iterator first, std::vector< AtomID >::iterator last) -> std::vector< AtomID >::iterator
        """
        return _sim2d.idvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(AtomID)> self) -> idvector
        __init__(std::vector<(AtomID)> self, idvector arg2) -> idvector
        __init__(std::vector<(AtomID)> self, std::vector< AtomID >::size_type size) -> idvector
        __init__(std::vector<(AtomID)> self, std::vector< AtomID >::size_type size, AtomID value) -> idvector
        """
        this = _sim2d.new_idvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'AtomID') -> "void":
        """push_back(idvector self, AtomID x)"""
        return _sim2d.idvector_push_back(self, x)


    def front(self) -> "std::vector< AtomID >::value_type const &":
        """front(idvector self) -> AtomID"""
        return _sim2d.idvector_front(self)


    def back(self) -> "std::vector< AtomID >::value_type const &":
        """back(idvector self) -> AtomID"""
        return _sim2d.idvector_back(self)


    def assign(self, n: 'std::vector< AtomID >::size_type', x: 'AtomID') -> "void":
        """assign(idvector self, std::vector< AtomID >::size_type n, AtomID x)"""
        return _sim2d.idvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(idvector self, std::vector< AtomID >::size_type new_size)
        resize(idvector self, std::vector< AtomID >::size_type new_size, AtomID x)
        """
        return _sim2d.idvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(idvector self, std::vector< AtomID >::iterator pos, AtomID x) -> std::vector< AtomID >::iterator
        insert(idvector self, std::vector< AtomID >::iterator pos, std::vector< AtomID >::size_type n, AtomID x)
        """
        return _sim2d.idvector_insert(self, *args)


    def reserve(self, n: 'std::vector< AtomID >::size_type') -> "void":
        """reserve(idvector self, std::vector< AtomID >::size_type n)"""
        return _sim2d.idvector_reserve(self, n)


    def capacity(self) -> "std::vector< AtomID >::size_type":
        """capacity(idvector self) -> std::vector< AtomID >::size_type"""
        return _sim2d.idvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_idvector
    __del__ = lambda self: None
idvector_swigregister = _sim2d.idvector_swigregister
idvector_swigregister(idvector)

class idpairvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(IDPair)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, idpairvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, idpairvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(idpairvector self) -> SwigPyIterator"""
        return _sim2d.idpairvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(idpairvector self) -> bool"""
        return _sim2d.idpairvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(idpairvector self) -> bool"""
        return _sim2d.idpairvector___bool__(self)


    def __len__(self) -> "std::vector< IDPair >::size_type":
        """__len__(idpairvector self) -> std::vector< IDPair >::size_type"""
        return _sim2d.idpairvector___len__(self)


    def __getslice__(self, i: 'std::vector< IDPair >::difference_type', j: 'std::vector< IDPair >::difference_type') -> "std::vector< IDPair,std::allocator< IDPair > > *":
        """__getslice__(idpairvector self, std::vector< IDPair >::difference_type i, std::vector< IDPair >::difference_type j) -> idpairvector"""
        return _sim2d.idpairvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(idpairvector self, std::vector< IDPair >::difference_type i, std::vector< IDPair >::difference_type j)
        __setslice__(idpairvector self, std::vector< IDPair >::difference_type i, std::vector< IDPair >::difference_type j, idpairvector v)
        """
        return _sim2d.idpairvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< IDPair >::difference_type', j: 'std::vector< IDPair >::difference_type') -> "void":
        """__delslice__(idpairvector self, std::vector< IDPair >::difference_type i, std::vector< IDPair >::difference_type j)"""
        return _sim2d.idpairvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(idpairvector self, std::vector< IDPair >::difference_type i)
        __delitem__(idpairvector self, PySliceObject * slice)
        """
        return _sim2d.idpairvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< IDPair >::value_type const &":
        """
        __getitem__(idpairvector self, PySliceObject * slice) -> idpairvector
        __getitem__(idpairvector self, std::vector< IDPair >::difference_type i) -> IDPair
        """
        return _sim2d.idpairvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(idpairvector self, PySliceObject * slice, idpairvector v)
        __setitem__(idpairvector self, PySliceObject * slice)
        __setitem__(idpairvector self, std::vector< IDPair >::difference_type i, IDPair x)
        """
        return _sim2d.idpairvector___setitem__(self, *args)


    def pop(self) -> "std::vector< IDPair >::value_type":
        """pop(idpairvector self) -> IDPair"""
        return _sim2d.idpairvector_pop(self)


    def append(self, x: 'IDPair') -> "void":
        """append(idpairvector self, IDPair x)"""
        return _sim2d.idpairvector_append(self, x)


    def empty(self) -> "bool":
        """empty(idpairvector self) -> bool"""
        return _sim2d.idpairvector_empty(self)


    def size(self) -> "std::vector< IDPair >::size_type":
        """size(idpairvector self) -> std::vector< IDPair >::size_type"""
        return _sim2d.idpairvector_size(self)


    def swap(self, v: 'idpairvector') -> "void":
        """swap(idpairvector self, idpairvector v)"""
        return _sim2d.idpairvector_swap(self, v)


    def begin(self) -> "std::vector< IDPair >::iterator":
        """begin(idpairvector self) -> std::vector< IDPair >::iterator"""
        return _sim2d.idpairvector_begin(self)


    def end(self) -> "std::vector< IDPair >::iterator":
        """end(idpairvector self) -> std::vector< IDPair >::iterator"""
        return _sim2d.idpairvector_end(self)


    def rbegin(self) -> "std::vector< IDPair >::reverse_iterator":
        """rbegin(idpairvector self) -> std::vector< IDPair >::reverse_iterator"""
        return _sim2d.idpairvector_rbegin(self)


    def rend(self) -> "std::vector< IDPair >::reverse_iterator":
        """rend(idpairvector self) -> std::vector< IDPair >::reverse_iterator"""
        return _sim2d.idpairvector_rend(self)


    def clear(self) -> "void":
        """clear(idpairvector self)"""
        return _sim2d.idpairvector_clear(self)


    def get_allocator(self) -> "std::vector< IDPair >::allocator_type":
        """get_allocator(idpairvector self) -> std::vector< IDPair >::allocator_type"""
        return _sim2d.idpairvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(idpairvector self)"""
        return _sim2d.idpairvector_pop_back(self)


    def erase(self, *args) -> "std::vector< IDPair >::iterator":
        """
        erase(idpairvector self, std::vector< IDPair >::iterator pos) -> std::vector< IDPair >::iterator
        erase(idpairvector self, std::vector< IDPair >::iterator first, std::vector< IDPair >::iterator last) -> std::vector< IDPair >::iterator
        """
        return _sim2d.idpairvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(IDPair)> self) -> idpairvector
        __init__(std::vector<(IDPair)> self, idpairvector arg2) -> idpairvector
        __init__(std::vector<(IDPair)> self, std::vector< IDPair >::size_type size) -> idpairvector
        __init__(std::vector<(IDPair)> self, std::vector< IDPair >::size_type size, IDPair value) -> idpairvector
        """
        this = _sim2d.new_idpairvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'IDPair') -> "void":
        """push_back(idpairvector self, IDPair x)"""
        return _sim2d.idpairvector_push_back(self, x)


    def front(self) -> "std::vector< IDPair >::value_type const &":
        """front(idpairvector self) -> IDPair"""
        return _sim2d.idpairvector_front(self)


    def back(self) -> "std::vector< IDPair >::value_type const &":
        """back(idpairvector self) -> IDPair"""
        return _sim2d.idpairvector_back(self)


    def assign(self, n: 'std::vector< IDPair >::size_type', x: 'IDPair') -> "void":
        """assign(idpairvector self, std::vector< IDPair >::size_type n, IDPair x)"""
        return _sim2d.idpairvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(idpairvector self, std::vector< IDPair >::size_type new_size)
        resize(idpairvector self, std::vector< IDPair >::size_type new_size, IDPair x)
        """
        return _sim2d.idpairvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(idpairvector self, std::vector< IDPair >::iterator pos, IDPair x) -> std::vector< IDPair >::iterator
        insert(idpairvector self, std::vector< IDPair >::iterator pos, std::vector< IDPair >::size_type n, IDPair x)
        """
        return _sim2d.idpairvector_insert(self, *args)


    def reserve(self, n: 'std::vector< IDPair >::size_type') -> "void":
        """reserve(idpairvector self, std::vector< IDPair >::size_type n)"""
        return _sim2d.idpairvector_reserve(self, n)


    def capacity(self) -> "std::vector< IDPair >::size_type":
        """capacity(idpairvector self) -> std::vector< IDPair >::size_type"""
        return _sim2d.idpairvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_idpairvector
    __del__ = lambda self: None
idpairvector_swigregister = _sim2d.idpairvector_swigregister
idpairvector_swigregister(idpairvector)

class intvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, intvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, intvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(intvector self) -> SwigPyIterator"""
        return _sim2d.intvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(intvector self) -> bool"""
        return _sim2d.intvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(intvector self) -> bool"""
        return _sim2d.intvector___bool__(self)


    def __len__(self) -> "std::vector< int >::size_type":
        """__len__(intvector self) -> std::vector< int >::size_type"""
        return _sim2d.intvector___len__(self)


    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        """__getslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> intvector"""
        return _sim2d.intvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, intvector v)
        """
        return _sim2d.intvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        """__delslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _sim2d.intvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(intvector self, std::vector< int >::difference_type i)
        __delitem__(intvector self, PySliceObject * slice)
        """
        return _sim2d.intvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        """
        __getitem__(intvector self, PySliceObject * slice) -> intvector
        __getitem__(intvector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _sim2d.intvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(intvector self, PySliceObject * slice, intvector v)
        __setitem__(intvector self, PySliceObject * slice)
        __setitem__(intvector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _sim2d.intvector___setitem__(self, *args)


    def pop(self) -> "std::vector< int >::value_type":
        """pop(intvector self) -> std::vector< int >::value_type"""
        return _sim2d.intvector_pop(self)


    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        """append(intvector self, std::vector< int >::value_type const & x)"""
        return _sim2d.intvector_append(self, x)


    def empty(self) -> "bool":
        """empty(intvector self) -> bool"""
        return _sim2d.intvector_empty(self)


    def size(self) -> "std::vector< int >::size_type":
        """size(intvector self) -> std::vector< int >::size_type"""
        return _sim2d.intvector_size(self)


    def swap(self, v: 'intvector') -> "void":
        """swap(intvector self, intvector v)"""
        return _sim2d.intvector_swap(self, v)


    def begin(self) -> "std::vector< int >::iterator":
        """begin(intvector self) -> std::vector< int >::iterator"""
        return _sim2d.intvector_begin(self)


    def end(self) -> "std::vector< int >::iterator":
        """end(intvector self) -> std::vector< int >::iterator"""
        return _sim2d.intvector_end(self)


    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        """rbegin(intvector self) -> std::vector< int >::reverse_iterator"""
        return _sim2d.intvector_rbegin(self)


    def rend(self) -> "std::vector< int >::reverse_iterator":
        """rend(intvector self) -> std::vector< int >::reverse_iterator"""
        return _sim2d.intvector_rend(self)


    def clear(self) -> "void":
        """clear(intvector self)"""
        return _sim2d.intvector_clear(self)


    def get_allocator(self) -> "std::vector< int >::allocator_type":
        """get_allocator(intvector self) -> std::vector< int >::allocator_type"""
        return _sim2d.intvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(intvector self)"""
        return _sim2d.intvector_pop_back(self)


    def erase(self, *args) -> "std::vector< int >::iterator":
        """
        erase(intvector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(intvector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _sim2d.intvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> intvector
        __init__(std::vector<(int)> self, intvector arg2) -> intvector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> intvector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> intvector
        """
        this = _sim2d.new_intvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        """push_back(intvector self, std::vector< int >::value_type const & x)"""
        return _sim2d.intvector_push_back(self, x)


    def front(self) -> "std::vector< int >::value_type const &":
        """front(intvector self) -> std::vector< int >::value_type const &"""
        return _sim2d.intvector_front(self)


    def back(self) -> "std::vector< int >::value_type const &":
        """back(intvector self) -> std::vector< int >::value_type const &"""
        return _sim2d.intvector_back(self)


    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        """assign(intvector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _sim2d.intvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(intvector self, std::vector< int >::size_type new_size)
        resize(intvector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _sim2d.intvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(intvector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(intvector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _sim2d.intvector_insert(self, *args)


    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        """reserve(intvector self, std::vector< int >::size_type n)"""
        return _sim2d.intvector_reserve(self, n)


    def capacity(self) -> "std::vector< int >::size_type":
        """capacity(intvector self) -> std::vector< int >::size_type"""
        return _sim2d.intvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_intvector
    __del__ = lambda self: None
intvector_swigregister = _sim2d.intvector_swigregister
intvector_swigregister(intvector)

class uintvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(unsigned int)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uintvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uintvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(uintvector self) -> SwigPyIterator"""
        return _sim2d.uintvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(uintvector self) -> bool"""
        return _sim2d.uintvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(uintvector self) -> bool"""
        return _sim2d.uintvector___bool__(self)


    def __len__(self) -> "std::vector< unsigned int >::size_type":
        """__len__(uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2d.uintvector___len__(self)


    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        """__getslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> uintvector"""
        return _sim2d.uintvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, uintvector v)
        """
        return _sim2d.uintvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        """__delslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _sim2d.uintvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(uintvector self, std::vector< unsigned int >::difference_type i)
        __delitem__(uintvector self, PySliceObject * slice)
        """
        return _sim2d.uintvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        """
        __getitem__(uintvector self, PySliceObject * slice) -> uintvector
        __getitem__(uintvector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _sim2d.uintvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(uintvector self, PySliceObject * slice, uintvector v)
        __setitem__(uintvector self, PySliceObject * slice)
        __setitem__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2d.uintvector___setitem__(self, *args)


    def pop(self) -> "std::vector< unsigned int >::value_type":
        """pop(uintvector self) -> std::vector< unsigned int >::value_type"""
        return _sim2d.uintvector_pop(self)


    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """append(uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim2d.uintvector_append(self, x)


    def empty(self) -> "bool":
        """empty(uintvector self) -> bool"""
        return _sim2d.uintvector_empty(self)


    def size(self) -> "std::vector< unsigned int >::size_type":
        """size(uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2d.uintvector_size(self)


    def swap(self, v: 'uintvector') -> "void":
        """swap(uintvector self, uintvector v)"""
        return _sim2d.uintvector_swap(self, v)


    def begin(self) -> "std::vector< unsigned int >::iterator":
        """begin(uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim2d.uintvector_begin(self)


    def end(self) -> "std::vector< unsigned int >::iterator":
        """end(uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim2d.uintvector_end(self)


    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rbegin(uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim2d.uintvector_rbegin(self)


    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rend(uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim2d.uintvector_rend(self)


    def clear(self) -> "void":
        """clear(uintvector self)"""
        return _sim2d.uintvector_clear(self)


    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        """get_allocator(uintvector self) -> std::vector< unsigned int >::allocator_type"""
        return _sim2d.uintvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(uintvector self)"""
        return _sim2d.uintvector_pop_back(self)


    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        """
        erase(uintvector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(uintvector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _sim2d.uintvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned int)> self) -> uintvector
        __init__(std::vector<(unsigned int)> self, uintvector arg2) -> uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> uintvector
        """
        this = _sim2d.new_uintvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """push_back(uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim2d.uintvector_push_back(self, x)


    def front(self) -> "std::vector< unsigned int >::value_type const &":
        """front(uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim2d.uintvector_front(self)


    def back(self) -> "std::vector< unsigned int >::value_type const &":
        """back(uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim2d.uintvector_back(self)


    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """assign(uintvector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _sim2d.uintvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(uintvector self, std::vector< unsigned int >::size_type new_size)
        resize(uintvector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2d.uintvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2d.uintvector_insert(self, *args)


    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        """reserve(uintvector self, std::vector< unsigned int >::size_type n)"""
        return _sim2d.uintvector_reserve(self, n)


    def capacity(self) -> "std::vector< unsigned int >::size_type":
        """capacity(uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2d.uintvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_uintvector
    __del__ = lambda self: None
uintvector_swigregister = _sim2d.uintvector_swigregister
uintvector_swigregister(uintvector)

class ulongvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(unsigned long)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ulongvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ulongvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ulongvector self) -> SwigPyIterator"""
        return _sim2d.ulongvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ulongvector self) -> bool"""
        return _sim2d.ulongvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ulongvector self) -> bool"""
        return _sim2d.ulongvector___bool__(self)


    def __len__(self) -> "std::vector< unsigned long >::size_type":
        """__len__(ulongvector self) -> std::vector< unsigned long >::size_type"""
        return _sim2d.ulongvector___len__(self)


    def __getslice__(self, i: 'std::vector< unsigned long >::difference_type', j: 'std::vector< unsigned long >::difference_type') -> "std::vector< unsigned long,std::allocator< unsigned long > > *":
        """__getslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> ulongvector"""
        return _sim2d.ulongvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, ulongvector v)
        """
        return _sim2d.ulongvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< unsigned long >::difference_type', j: 'std::vector< unsigned long >::difference_type') -> "void":
        """__delslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _sim2d.ulongvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ulongvector self, std::vector< unsigned long >::difference_type i)
        __delitem__(ulongvector self, PySliceObject * slice)
        """
        return _sim2d.ulongvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< unsigned long >::value_type const &":
        """
        __getitem__(ulongvector self, PySliceObject * slice) -> ulongvector
        __getitem__(ulongvector self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _sim2d.ulongvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ulongvector self, PySliceObject * slice, ulongvector v)
        __setitem__(ulongvector self, PySliceObject * slice)
        __setitem__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _sim2d.ulongvector___setitem__(self, *args)


    def pop(self) -> "std::vector< unsigned long >::value_type":
        """pop(ulongvector self) -> std::vector< unsigned long >::value_type"""
        return _sim2d.ulongvector_pop(self)


    def append(self, x: 'std::vector< unsigned long >::value_type const &') -> "void":
        """append(ulongvector self, std::vector< unsigned long >::value_type const & x)"""
        return _sim2d.ulongvector_append(self, x)


    def empty(self) -> "bool":
        """empty(ulongvector self) -> bool"""
        return _sim2d.ulongvector_empty(self)


    def size(self) -> "std::vector< unsigned long >::size_type":
        """size(ulongvector self) -> std::vector< unsigned long >::size_type"""
        return _sim2d.ulongvector_size(self)


    def swap(self, v: 'ulongvector') -> "void":
        """swap(ulongvector self, ulongvector v)"""
        return _sim2d.ulongvector_swap(self, v)


    def begin(self) -> "std::vector< unsigned long >::iterator":
        """begin(ulongvector self) -> std::vector< unsigned long >::iterator"""
        return _sim2d.ulongvector_begin(self)


    def end(self) -> "std::vector< unsigned long >::iterator":
        """end(ulongvector self) -> std::vector< unsigned long >::iterator"""
        return _sim2d.ulongvector_end(self)


    def rbegin(self) -> "std::vector< unsigned long >::reverse_iterator":
        """rbegin(ulongvector self) -> std::vector< unsigned long >::reverse_iterator"""
        return _sim2d.ulongvector_rbegin(self)


    def rend(self) -> "std::vector< unsigned long >::reverse_iterator":
        """rend(ulongvector self) -> std::vector< unsigned long >::reverse_iterator"""
        return _sim2d.ulongvector_rend(self)


    def clear(self) -> "void":
        """clear(ulongvector self)"""
        return _sim2d.ulongvector_clear(self)


    def get_allocator(self) -> "std::vector< unsigned long >::allocator_type":
        """get_allocator(ulongvector self) -> std::vector< unsigned long >::allocator_type"""
        return _sim2d.ulongvector_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(ulongvector self)"""
        return _sim2d.ulongvector_pop_back(self)


    def erase(self, *args) -> "std::vector< unsigned long >::iterator":
        """
        erase(ulongvector self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(ulongvector self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _sim2d.ulongvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned long)> self) -> ulongvector
        __init__(std::vector<(unsigned long)> self, ulongvector arg2) -> ulongvector
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size) -> ulongvector
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> ulongvector
        """
        this = _sim2d.new_ulongvector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned long >::value_type const &') -> "void":
        """push_back(ulongvector self, std::vector< unsigned long >::value_type const & x)"""
        return _sim2d.ulongvector_push_back(self, x)


    def front(self) -> "std::vector< unsigned long >::value_type const &":
        """front(ulongvector self) -> std::vector< unsigned long >::value_type const &"""
        return _sim2d.ulongvector_front(self)


    def back(self) -> "std::vector< unsigned long >::value_type const &":
        """back(ulongvector self) -> std::vector< unsigned long >::value_type const &"""
        return _sim2d.ulongvector_back(self)


    def assign(self, n: 'std::vector< unsigned long >::size_type', x: 'std::vector< unsigned long >::value_type const &') -> "void":
        """assign(ulongvector self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _sim2d.ulongvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ulongvector self, std::vector< unsigned long >::size_type new_size)
        resize(ulongvector self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _sim2d.ulongvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ulongvector self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(ulongvector self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _sim2d.ulongvector_insert(self, *args)


    def reserve(self, n: 'std::vector< unsigned long >::size_type') -> "void":
        """reserve(ulongvector self, std::vector< unsigned long >::size_type n)"""
        return _sim2d.ulongvector_reserve(self, n)


    def capacity(self) -> "std::vector< unsigned long >::size_type":
        """capacity(ulongvector self) -> std::vector< unsigned long >::size_type"""
        return _sim2d.ulongvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ulongvector
    __del__ = lambda self: None
ulongvector_swigregister = _sim2d.ulongvector_swigregister
ulongvector_swigregister(ulongvector)

class _eventset(collections.MutableSet):
    """Proxy of C++ std::set<(Event)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _eventset, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _eventset, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_eventset self) -> SwigPyIterator"""
        return _sim2d._eventset_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_eventset self) -> bool"""
        return _sim2d._eventset___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_eventset self) -> bool"""
        return _sim2d._eventset___bool__(self)


    def __len__(self) -> "std::set< Event >::size_type":
        """__len__(_eventset self) -> std::set< Event >::size_type"""
        return _sim2d._eventset___len__(self)


    def append(self, x: 'Event') -> "void":
        """append(_eventset self, Event x)"""
        return _sim2d._eventset_append(self, x)


    def __contains__(self, x: 'Event') -> "bool":
        """__contains__(_eventset self, Event x) -> bool"""
        return _sim2d._eventset___contains__(self, x)


    def __getitem__(self, i: 'std::set< Event >::difference_type') -> "std::set< Event >::value_type":
        """__getitem__(_eventset self, std::set< Event >::difference_type i) -> Event"""
        return _sim2d._eventset___getitem__(self, i)


    def add(self, x: 'Event') -> "void":
        """add(_eventset self, Event x)"""
        return _sim2d._eventset_add(self, x)


    def discard(self, x: 'Event') -> "void":
        """discard(_eventset self, Event x)"""
        return _sim2d._eventset_discard(self, x)


    def __init__(self, *args):
        """
        __init__(std::set<(Event)> self, std::less< Event > const & arg2) -> _eventset
        __init__(std::set<(Event)> self) -> _eventset
        __init__(std::set<(Event)> self, _eventset arg2) -> _eventset
        """
        this = _sim2d.new__eventset(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        """empty(_eventset self) -> bool"""
        return _sim2d._eventset_empty(self)


    def size(self) -> "std::set< Event >::size_type":
        """size(_eventset self) -> std::set< Event >::size_type"""
        return _sim2d._eventset_size(self)


    def clear(self) -> "void":
        """clear(_eventset self)"""
        return _sim2d._eventset_clear(self)


    def swap(self, v: '_eventset') -> "void":
        """swap(_eventset self, _eventset v)"""
        return _sim2d._eventset_swap(self, v)


    def count(self, x: 'Event') -> "std::set< Event >::size_type":
        """count(_eventset self, Event x) -> std::set< Event >::size_type"""
        return _sim2d._eventset_count(self, x)


    def begin(self) -> "std::set< Event >::iterator":
        """begin(_eventset self) -> std::set< Event >::iterator"""
        return _sim2d._eventset_begin(self)


    def end(self) -> "std::set< Event >::iterator":
        """end(_eventset self) -> std::set< Event >::iterator"""
        return _sim2d._eventset_end(self)


    def rbegin(self) -> "std::set< Event >::reverse_iterator":
        """rbegin(_eventset self) -> std::set< Event >::reverse_iterator"""
        return _sim2d._eventset_rbegin(self)


    def rend(self) -> "std::set< Event >::reverse_iterator":
        """rend(_eventset self) -> std::set< Event >::reverse_iterator"""
        return _sim2d._eventset_rend(self)


    def erase(self, *args) -> "void":
        """
        erase(_eventset self, Event x) -> std::set< Event >::size_type
        erase(_eventset self, std::set< Event >::iterator pos)
        erase(_eventset self, std::set< Event >::iterator first, std::set< Event >::iterator last)
        """
        return _sim2d._eventset_erase(self, *args)


    def find(self, x: 'Event') -> "std::set< Event >::iterator":
        """find(_eventset self, Event x) -> std::set< Event >::iterator"""
        return _sim2d._eventset_find(self, x)


    def lower_bound(self, x: 'Event') -> "std::set< Event >::iterator":
        """lower_bound(_eventset self, Event x) -> std::set< Event >::iterator"""
        return _sim2d._eventset_lower_bound(self, x)


    def upper_bound(self, x: 'Event') -> "std::set< Event >::iterator":
        """upper_bound(_eventset self, Event x) -> std::set< Event >::iterator"""
        return _sim2d._eventset_upper_bound(self, x)


    def equal_range(self, x: 'Event') -> "std::pair< std::set< Event >::iterator,std::set< Event >::iterator >":
        """equal_range(_eventset self, Event x) -> std::pair< std::set< Event >::iterator,std::set< Event >::iterator >"""
        return _sim2d._eventset_equal_range(self, x)


    def insert(self, __x: 'Event') -> "std::pair< std::set< Event >::iterator,bool >":
        """insert(_eventset self, Event __x) -> std::pair< std::set< Event >::iterator,bool >"""
        return _sim2d._eventset_insert(self, __x)

    __swig_destroy__ = _sim2d.delete__eventset
    __del__ = lambda self: None
_eventset_swigregister = _sim2d._eventset_swigregister
_eventset_swigregister(_eventset)

class pair_uint_CNodePath(_object):
    """Proxy of C++ std::pair<(unsigned int,CNodePath)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pair_uint_CNodePath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pair_uint_CNodePath, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(unsigned int,CNodePath)> self) -> pair_uint_CNodePath
        __init__(std::pair<(unsigned int,CNodePath)> self, unsigned int first, CNodePath second) -> pair_uint_CNodePath
        __init__(std::pair<(unsigned int,CNodePath)> self, pair_uint_CNodePath p) -> pair_uint_CNodePath
        """
        this = _sim2d.new_pair_uint_CNodePath(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _sim2d.pair_uint_CNodePath_first_set
    __swig_getmethods__["first"] = _sim2d.pair_uint_CNodePath_first_get
    if _newclass:
        first = _swig_property(_sim2d.pair_uint_CNodePath_first_get, _sim2d.pair_uint_CNodePath_first_set)
    __swig_setmethods__["second"] = _sim2d.pair_uint_CNodePath_second_set
    __swig_getmethods__["second"] = _sim2d.pair_uint_CNodePath_second_get
    if _newclass:
        second = _swig_property(_sim2d.pair_uint_CNodePath_second_get, _sim2d.pair_uint_CNodePath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _sim2d.delete_pair_uint_CNodePath
    __del__ = lambda self: None
pair_uint_CNodePath_swigregister = _sim2d.pair_uint_CNodePath_swigregister
pair_uint_CNodePath_swigregister(pair_uint_CNodePath)

class map_uint_CNodePath(collections.MutableMapping):
    """Proxy of C++ std::map<(unsigned int,CNodePath)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, map_uint_CNodePath, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, map_uint_CNodePath, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(map_uint_CNodePath self) -> SwigPyIterator"""
        return _sim2d.map_uint_CNodePath_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(map_uint_CNodePath self) -> bool"""
        return _sim2d.map_uint_CNodePath___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(map_uint_CNodePath self) -> bool"""
        return _sim2d.map_uint_CNodePath___bool__(self)


    def __len__(self) -> "std::map< unsigned int,CNodePath >::size_type":
        """__len__(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::size_type"""
        return _sim2d.map_uint_CNodePath___len__(self)

    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::mapped_type const &":
        """__getitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key) -> CNodePath"""
        return _sim2d.map_uint_CNodePath___getitem__(self, key)


    def __delitem__(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "void":
        """__delitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key)"""
        return _sim2d.map_uint_CNodePath___delitem__(self, key)


    def has_key(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "bool":
        """has_key(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key) -> bool"""
        return _sim2d.map_uint_CNodePath_has_key(self, key)


    def keys(self) -> "PyObject *":
        """keys(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_keys(self)


    def values(self) -> "PyObject *":
        """values(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_values(self)


    def items(self) -> "PyObject *":
        """items(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_items(self)


    def __contains__(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "bool":
        """__contains__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key) -> bool"""
        return _sim2d.map_uint_CNodePath___contains__(self, key)


    def key_iterator(self) -> "swig::SwigPyIterator *":
        """key_iterator(map_uint_CNodePath self) -> SwigPyIterator"""
        return _sim2d.map_uint_CNodePath_key_iterator(self)


    def value_iterator(self) -> "swig::SwigPyIterator *":
        """value_iterator(map_uint_CNodePath self) -> SwigPyIterator"""
        return _sim2d.map_uint_CNodePath_value_iterator(self)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key)
        __setitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key, CNodePath x)
        """
        return _sim2d.map_uint_CNodePath___setitem__(self, *args)


    def asdict(self) -> "PyObject *":
        """asdict(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_asdict(self)


    def __init__(self, *args):
        """
        __init__(std::map<(unsigned int,CNodePath)> self, std::less< unsigned int > const & arg2) -> map_uint_CNodePath
        __init__(std::map<(unsigned int,CNodePath)> self) -> map_uint_CNodePath
        __init__(std::map<(unsigned int,CNodePath)> self, map_uint_CNodePath arg2) -> map_uint_CNodePath
        """
        this = _sim2d.new_map_uint_CNodePath(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        """empty(map_uint_CNodePath self) -> bool"""
        return _sim2d.map_uint_CNodePath_empty(self)


    def size(self) -> "std::map< unsigned int,CNodePath >::size_type":
        """size(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::size_type"""
        return _sim2d.map_uint_CNodePath_size(self)


    def swap(self, v: 'map_uint_CNodePath') -> "void":
        """swap(map_uint_CNodePath self, map_uint_CNodePath v)"""
        return _sim2d.map_uint_CNodePath_swap(self, v)


    def begin(self) -> "std::map< unsigned int,CNodePath >::iterator":
        """begin(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_begin(self)


    def end(self) -> "std::map< unsigned int,CNodePath >::iterator":
        """end(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_end(self)


    def rbegin(self) -> "std::map< unsigned int,CNodePath >::reverse_iterator":
        """rbegin(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::reverse_iterator"""
        return _sim2d.map_uint_CNodePath_rbegin(self)


    def rend(self) -> "std::map< unsigned int,CNodePath >::reverse_iterator":
        """rend(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::reverse_iterator"""
        return _sim2d.map_uint_CNodePath_rend(self)


    def clear(self) -> "void":
        """clear(map_uint_CNodePath self)"""
        return _sim2d.map_uint_CNodePath_clear(self)


    def get_allocator(self) -> "std::map< unsigned int,CNodePath >::allocator_type":
        """get_allocator(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::allocator_type"""
        return _sim2d.map_uint_CNodePath_get_allocator(self)


    def count(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::size_type":
        """count(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::size_type"""
        return _sim2d.map_uint_CNodePath_count(self, x)


    def erase(self, *args) -> "void":
        """
        erase(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::size_type
        erase(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::iterator position)
        erase(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::iterator first, std::map< unsigned int,CNodePath >::iterator last)
        """
        return _sim2d.map_uint_CNodePath_erase(self, *args)


    def find(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::iterator":
        """find(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_find(self, x)


    def lower_bound(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::iterator":
        """lower_bound(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_lower_bound(self, x)


    def upper_bound(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::iterator":
        """upper_bound(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_upper_bound(self, x)

    __swig_destroy__ = _sim2d.delete_map_uint_CNodePath
    __del__ = lambda self: None
map_uint_CNodePath_swigregister = _sim2d.map_uint_CNodePath_swigregister
map_uint_CNodePath_swigregister(map_uint_CNodePath)

class vector_CNode(collections.MutableSequence):
    """Proxy of C++ std::vector<(CNode)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_CNode, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, vector_CNode, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(vector_CNode self) -> SwigPyIterator"""
        return _sim2d.vector_CNode_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(vector_CNode self) -> bool"""
        return _sim2d.vector_CNode___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(vector_CNode self) -> bool"""
        return _sim2d.vector_CNode___bool__(self)


    def __len__(self) -> "std::vector< CNode >::size_type":
        """__len__(vector_CNode self) -> std::vector< CNode >::size_type"""
        return _sim2d.vector_CNode___len__(self)


    def __getslice__(self, i: 'std::vector< CNode >::difference_type', j: 'std::vector< CNode >::difference_type') -> "std::vector< CNode,std::allocator< CNode > > *":
        """__getslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j) -> vector_CNode"""
        return _sim2d.vector_CNode___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j)
        __setslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j, vector_CNode v)
        """
        return _sim2d.vector_CNode___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< CNode >::difference_type', j: 'std::vector< CNode >::difference_type') -> "void":
        """__delslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j)"""
        return _sim2d.vector_CNode___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(vector_CNode self, std::vector< CNode >::difference_type i)
        __delitem__(vector_CNode self, PySliceObject * slice)
        """
        return _sim2d.vector_CNode___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< CNode >::value_type const &":
        """
        __getitem__(vector_CNode self, PySliceObject * slice) -> vector_CNode
        __getitem__(vector_CNode self, std::vector< CNode >::difference_type i) -> CNode
        """
        return _sim2d.vector_CNode___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(vector_CNode self, PySliceObject * slice, vector_CNode v)
        __setitem__(vector_CNode self, PySliceObject * slice)
        __setitem__(vector_CNode self, std::vector< CNode >::difference_type i, CNode x)
        """
        return _sim2d.vector_CNode___setitem__(self, *args)


    def pop(self) -> "std::vector< CNode >::value_type":
        """pop(vector_CNode self) -> CNode"""
        return _sim2d.vector_CNode_pop(self)


    def append(self, x: 'CNode') -> "void":
        """append(vector_CNode self, CNode x)"""
        return _sim2d.vector_CNode_append(self, x)


    def empty(self) -> "bool":
        """empty(vector_CNode self) -> bool"""
        return _sim2d.vector_CNode_empty(self)


    def size(self) -> "std::vector< CNode >::size_type":
        """size(vector_CNode self) -> std::vector< CNode >::size_type"""
        return _sim2d.vector_CNode_size(self)


    def swap(self, v: 'vector_CNode') -> "void":
        """swap(vector_CNode self, vector_CNode v)"""
        return _sim2d.vector_CNode_swap(self, v)


    def begin(self) -> "std::vector< CNode >::iterator":
        """begin(vector_CNode self) -> std::vector< CNode >::iterator"""
        return _sim2d.vector_CNode_begin(self)


    def end(self) -> "std::vector< CNode >::iterator":
        """end(vector_CNode self) -> std::vector< CNode >::iterator"""
        return _sim2d.vector_CNode_end(self)


    def rbegin(self) -> "std::vector< CNode >::reverse_iterator":
        """rbegin(vector_CNode self) -> std::vector< CNode >::reverse_iterator"""
        return _sim2d.vector_CNode_rbegin(self)


    def rend(self) -> "std::vector< CNode >::reverse_iterator":
        """rend(vector_CNode self) -> std::vector< CNode >::reverse_iterator"""
        return _sim2d.vector_CNode_rend(self)


    def clear(self) -> "void":
        """clear(vector_CNode self)"""
        return _sim2d.vector_CNode_clear(self)


    def get_allocator(self) -> "std::vector< CNode >::allocator_type":
        """get_allocator(vector_CNode self) -> std::vector< CNode >::allocator_type"""
        return _sim2d.vector_CNode_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(vector_CNode self)"""
        return _sim2d.vector_CNode_pop_back(self)


    def erase(self, *args) -> "std::vector< CNode >::iterator":
        """
        erase(vector_CNode self, std::vector< CNode >::iterator pos) -> std::vector< CNode >::iterator
        erase(vector_CNode self, std::vector< CNode >::iterator first, std::vector< CNode >::iterator last) -> std::vector< CNode >::iterator
        """
        return _sim2d.vector_CNode_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(CNode)> self) -> vector_CNode
        __init__(std::vector<(CNode)> self, vector_CNode arg2) -> vector_CNode
        __init__(std::vector<(CNode)> self, std::vector< CNode >::size_type size) -> vector_CNode
        __init__(std::vector<(CNode)> self, std::vector< CNode >::size_type size, CNode value) -> vector_CNode
        """
        this = _sim2d.new_vector_CNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'CNode') -> "void":
        """push_back(vector_CNode self, CNode x)"""
        return _sim2d.vector_CNode_push_back(self, x)


    def front(self) -> "std::vector< CNode >::value_type const &":
        """front(vector_CNode self) -> CNode"""
        return _sim2d.vector_CNode_front(self)


    def back(self) -> "std::vector< CNode >::value_type const &":
        """back(vector_CNode self) -> CNode"""
        return _sim2d.vector_CNode_back(self)


    def assign(self, n: 'std::vector< CNode >::size_type', x: 'CNode') -> "void":
        """assign(vector_CNode self, std::vector< CNode >::size_type n, CNode x)"""
        return _sim2d.vector_CNode_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(vector_CNode self, std::vector< CNode >::size_type new_size)
        resize(vector_CNode self, std::vector< CNode >::size_type new_size, CNode x)
        """
        return _sim2d.vector_CNode_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(vector_CNode self, std::vector< CNode >::iterator pos, CNode x) -> std::vector< CNode >::iterator
        insert(vector_CNode self, std::vector< CNode >::iterator pos, std::vector< CNode >::size_type n, CNode x)
        """
        return _sim2d.vector_CNode_insert(self, *args)


    def reserve(self, n: 'std::vector< CNode >::size_type') -> "void":
        """reserve(vector_CNode self, std::vector< CNode >::size_type n)"""
        return _sim2d.vector_CNode_reserve(self, n)


    def capacity(self) -> "std::vector< CNode >::size_type":
        """capacity(vector_CNode self) -> std::vector< CNode >::size_type"""
        return _sim2d.vector_CNode_capacity(self)

    __swig_destroy__ = _sim2d.delete_vector_CNode
    __del__ = lambda self: None
vector_CNode_swigregister = _sim2d.vector_CNode_swigregister
vector_CNode_swigregister(vector_CNode)

class pair_int_CNode(_object):
    """Proxy of C++ std::pair<(int,vector<(CNode)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pair_int_CNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pair_int_CNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(int,vector<(CNode)>)> self) -> pair_int_CNode
        __init__(std::pair<(int,vector<(CNode)>)> self, int first, vector_CNode second) -> pair_int_CNode
        __init__(std::pair<(int,vector<(CNode)>)> self, pair_int_CNode p) -> pair_int_CNode
        """
        this = _sim2d.new_pair_int_CNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _sim2d.pair_int_CNode_first_set
    __swig_getmethods__["first"] = _sim2d.pair_int_CNode_first_get
    if _newclass:
        first = _swig_property(_sim2d.pair_int_CNode_first_get, _sim2d.pair_int_CNode_first_set)
    __swig_setmethods__["second"] = _sim2d.pair_int_CNode_second_set
    __swig_getmethods__["second"] = _sim2d.pair_int_CNode_second_get
    if _newclass:
        second = _swig_property(_sim2d.pair_int_CNode_second_get, _sim2d.pair_int_CNode_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _sim2d.delete_pair_int_CNode
    __del__ = lambda self: None
pair_int_CNode_swigregister = _sim2d.pair_int_CNode_swigregister
pair_int_CNode_swigregister(pair_int_CNode)

class map_int_CNode(collections.MutableMapping):
    """Proxy of C++ std::map<(int,vector<(CNode)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, map_int_CNode, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, map_int_CNode, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(map_int_CNode self) -> SwigPyIterator"""
        return _sim2d.map_int_CNode_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(map_int_CNode self) -> bool"""
        return _sim2d.map_int_CNode___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(map_int_CNode self) -> bool"""
        return _sim2d.map_int_CNode___bool__(self)


    def __len__(self) -> "std::map< int,vector< CNode > >::size_type":
        """__len__(map_int_CNode self) -> std::map< int,vector< CNode > >::size_type"""
        return _sim2d.map_int_CNode___len__(self)

    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< int,vector< CNode > >::key_type const &') -> "std::map< int,vector< CNode > >::mapped_type const &":
        """__getitem__(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & key) -> vector_CNode"""
        return _sim2d.map_int_CNode___getitem__(self, key)


    def __delitem__(self, key: 'std::map< int,vector< CNode > >::key_type const &') -> "void":
        """__delitem__(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & key)"""
        return _sim2d.map_int_CNode___delitem__(self, key)


    def has_key(self, key: 'std::map< int,vector< CNode > >::key_type const &') -> "bool":
        """has_key(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & key) -> bool"""
        return _sim2d.map_int_CNode_has_key(self, key)


    def keys(self) -> "PyObject *":
        """keys(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_keys(self)


    def values(self) -> "PyObject *":
        """values(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_values(self)


    def items(self) -> "PyObject *":
        """items(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_items(self)


    def __contains__(self, key: 'std::map< int,vector< CNode > >::key_type const &') -> "bool":
        """__contains__(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & key) -> bool"""
        return _sim2d.map_int_CNode___contains__(self, key)


    def key_iterator(self) -> "swig::SwigPyIterator *":
        """key_iterator(map_int_CNode self) -> SwigPyIterator"""
        return _sim2d.map_int_CNode_key_iterator(self)


    def value_iterator(self) -> "swig::SwigPyIterator *":
        """value_iterator(map_int_CNode self) -> SwigPyIterator"""
        return _sim2d.map_int_CNode_value_iterator(self)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & key)
        __setitem__(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & key, vector_CNode x)
        """
        return _sim2d.map_int_CNode___setitem__(self, *args)


    def asdict(self) -> "PyObject *":
        """asdict(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_asdict(self)


    def __init__(self, *args):
        """
        __init__(std::map<(int,vector<(CNode)>)> self, std::less< int > const & arg2) -> map_int_CNode
        __init__(std::map<(int,vector<(CNode)>)> self) -> map_int_CNode
        __init__(std::map<(int,vector<(CNode)>)> self, map_int_CNode arg2) -> map_int_CNode
        """
        this = _sim2d.new_map_int_CNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        """empty(map_int_CNode self) -> bool"""
        return _sim2d.map_int_CNode_empty(self)


    def size(self) -> "std::map< int,vector< CNode > >::size_type":
        """size(map_int_CNode self) -> std::map< int,vector< CNode > >::size_type"""
        return _sim2d.map_int_CNode_size(self)


    def swap(self, v: 'map_int_CNode') -> "void":
        """swap(map_int_CNode self, map_int_CNode v)"""
        return _sim2d.map_int_CNode_swap(self, v)


    def begin(self) -> "std::map< int,vector< CNode > >::iterator":
        """begin(map_int_CNode self) -> std::map< int,vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_begin(self)


    def end(self) -> "std::map< int,vector< CNode > >::iterator":
        """end(map_int_CNode self) -> std::map< int,vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_end(self)


    def rbegin(self) -> "std::map< int,vector< CNode > >::reverse_iterator":
        """rbegin(map_int_CNode self) -> std::map< int,vector< CNode > >::reverse_iterator"""
        return _sim2d.map_int_CNode_rbegin(self)


    def rend(self) -> "std::map< int,vector< CNode > >::reverse_iterator":
        """rend(map_int_CNode self) -> std::map< int,vector< CNode > >::reverse_iterator"""
        return _sim2d.map_int_CNode_rend(self)


    def clear(self) -> "void":
        """clear(map_int_CNode self)"""
        return _sim2d.map_int_CNode_clear(self)


    def get_allocator(self) -> "std::map< int,vector< CNode > >::allocator_type":
        """get_allocator(map_int_CNode self) -> std::map< int,vector< CNode > >::allocator_type"""
        return _sim2d.map_int_CNode_get_allocator(self)


    def count(self, x: 'std::map< int,vector< CNode > >::key_type const &') -> "std::map< int,vector< CNode > >::size_type":
        """count(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & x) -> std::map< int,vector< CNode > >::size_type"""
        return _sim2d.map_int_CNode_count(self, x)


    def erase(self, *args) -> "void":
        """
        erase(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & x) -> std::map< int,vector< CNode > >::size_type
        erase(map_int_CNode self, std::map< int,vector< CNode > >::iterator position)
        erase(map_int_CNode self, std::map< int,vector< CNode > >::iterator first, std::map< int,vector< CNode > >::iterator last)
        """
        return _sim2d.map_int_CNode_erase(self, *args)


    def find(self, x: 'std::map< int,vector< CNode > >::key_type const &') -> "std::map< int,vector< CNode > >::iterator":
        """find(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & x) -> std::map< int,vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_find(self, x)


    def lower_bound(self, x: 'std::map< int,vector< CNode > >::key_type const &') -> "std::map< int,vector< CNode > >::iterator":
        """lower_bound(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & x) -> std::map< int,vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_lower_bound(self, x)


    def upper_bound(self, x: 'std::map< int,vector< CNode > >::key_type const &') -> "std::map< int,vector< CNode > >::iterator":
        """upper_bound(map_int_CNode self, std::map< int,vector< CNode > >::key_type const & x) -> std::map< int,vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_upper_bound(self, x)

    __swig_destroy__ = _sim2d.delete_map_int_CNode
    __del__ = lambda self: None
map_int_CNode_swigregister = _sim2d.map_int_CNode_swigregister
map_int_CNode_swigregister(map_int_CNode)

class _carray2(_object):
    """Proxy of C++ boost::array<(std::complex<(double)>,2)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _carray2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _carray2, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(boost::array<(std::complex<(double)>,2)> self) -> _carray2"""
        this = _sim2d.new__carray2()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete__carray2
    __del__ = lambda self: None

    def swap(self, b: '_carray2') -> "void":
        """swap(_carray2 self, _carray2 b)"""
        return _sim2d._carray2_swap(self, b)


    def __getitem__(self, idx: 'unsigned int') -> "std::complex< double >":
        """__getitem__(_carray2 self, unsigned int idx) -> std::complex< double >"""
        return _sim2d._carray2___getitem__(self, idx)


    def __setitem__(self, idx: 'unsigned int', val: 'std::complex< double >') -> "void":
        """__setitem__(_carray2 self, unsigned int idx, std::complex< double > val)"""
        return _sim2d._carray2___setitem__(self, idx, val)


    def __len__(self) -> "unsigned int":
        """__len__(_carray2 self) -> unsigned int"""
        return _sim2d._carray2___len__(self)


    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

    def __str__(self):
        return str(tuple(self))

    def __repr__(self):
        return repr(tuple(self))

_carray2_swigregister = _sim2d._carray2_swigregister
_carray2_swigregister(_carray2)

class _cavector2(collections.MutableSequence):
    """Proxy of C++ std::vector<(boost::array<(std::complex<(double)>,2)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cavector2, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _cavector2, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_cavector2 self) -> SwigPyIterator"""
        return _sim2d._cavector2_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_cavector2 self) -> bool"""
        return _sim2d._cavector2___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_cavector2 self) -> bool"""
        return _sim2d._cavector2___bool__(self)


    def __len__(self) -> "std::vector< boost::array< std::complex< double >,2 > >::size_type":
        """__len__(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::size_type"""
        return _sim2d._cavector2___len__(self)


    def __getslice__(self, i: 'std::vector< boost::array< std::complex< double >,2 > >::difference_type', j: 'std::vector< boost::array< std::complex< double >,2 > >::difference_type') -> "std::vector< boost::array< std::complex< double >,2 >,std::allocator< boost::array< std::complex< double >,2 > > > *":
        """__getslice__(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::difference_type i, std::vector< boost::array< std::complex< double >,2 > >::difference_type j) -> _cavector2"""
        return _sim2d._cavector2___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::difference_type i, std::vector< boost::array< std::complex< double >,2 > >::difference_type j)
        __setslice__(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::difference_type i, std::vector< boost::array< std::complex< double >,2 > >::difference_type j, _cavector2 v)
        """
        return _sim2d._cavector2___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< boost::array< std::complex< double >,2 > >::difference_type', j: 'std::vector< boost::array< std::complex< double >,2 > >::difference_type') -> "void":
        """__delslice__(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::difference_type i, std::vector< boost::array< std::complex< double >,2 > >::difference_type j)"""
        return _sim2d._cavector2___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::difference_type i)
        __delitem__(_cavector2 self, PySliceObject * slice)
        """
        return _sim2d._cavector2___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< boost::array< std::complex< double >,2 > >::value_type const &":
        """
        __getitem__(_cavector2 self, PySliceObject * slice) -> _cavector2
        __getitem__(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::difference_type i) -> _carray2
        """
        return _sim2d._cavector2___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_cavector2 self, PySliceObject * slice, _cavector2 v)
        __setitem__(_cavector2 self, PySliceObject * slice)
        __setitem__(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::difference_type i, _carray2 x)
        """
        return _sim2d._cavector2___setitem__(self, *args)


    def pop(self) -> "std::vector< boost::array< std::complex< double >,2 > >::value_type":
        """pop(_cavector2 self) -> _carray2"""
        return _sim2d._cavector2_pop(self)


    def append(self, x: '_carray2') -> "void":
        """append(_cavector2 self, _carray2 x)"""
        return _sim2d._cavector2_append(self, x)


    def empty(self) -> "bool":
        """empty(_cavector2 self) -> bool"""
        return _sim2d._cavector2_empty(self)


    def size(self) -> "std::vector< boost::array< std::complex< double >,2 > >::size_type":
        """size(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::size_type"""
        return _sim2d._cavector2_size(self)


    def swap(self, v: '_cavector2') -> "void":
        """swap(_cavector2 self, _cavector2 v)"""
        return _sim2d._cavector2_swap(self, v)


    def begin(self) -> "std::vector< boost::array< std::complex< double >,2 > >::iterator":
        """begin(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::iterator"""
        return _sim2d._cavector2_begin(self)


    def end(self) -> "std::vector< boost::array< std::complex< double >,2 > >::iterator":
        """end(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::iterator"""
        return _sim2d._cavector2_end(self)


    def rbegin(self) -> "std::vector< boost::array< std::complex< double >,2 > >::reverse_iterator":
        """rbegin(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::reverse_iterator"""
        return _sim2d._cavector2_rbegin(self)


    def rend(self) -> "std::vector< boost::array< std::complex< double >,2 > >::reverse_iterator":
        """rend(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::reverse_iterator"""
        return _sim2d._cavector2_rend(self)


    def clear(self) -> "void":
        """clear(_cavector2 self)"""
        return _sim2d._cavector2_clear(self)


    def get_allocator(self) -> "std::vector< boost::array< std::complex< double >,2 > >::allocator_type":
        """get_allocator(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::allocator_type"""
        return _sim2d._cavector2_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_cavector2 self)"""
        return _sim2d._cavector2_pop_back(self)


    def erase(self, *args) -> "std::vector< boost::array< std::complex< double >,2 > >::iterator":
        """
        erase(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::iterator pos) -> std::vector< boost::array< std::complex< double >,2 > >::iterator
        erase(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::iterator first, std::vector< boost::array< std::complex< double >,2 > >::iterator last) -> std::vector< boost::array< std::complex< double >,2 > >::iterator
        """
        return _sim2d._cavector2_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(boost::array<(std::complex<(double)>,2)>)> self) -> _cavector2
        __init__(std::vector<(boost::array<(std::complex<(double)>,2)>)> self, _cavector2 arg2) -> _cavector2
        __init__(std::vector<(boost::array<(std::complex<(double)>,2)>)> self, std::vector< boost::array< std::complex< double >,2 > >::size_type size) -> _cavector2
        __init__(std::vector<(boost::array<(std::complex<(double)>,2)>)> self, std::vector< boost::array< std::complex< double >,2 > >::size_type size, _carray2 value) -> _cavector2
        """
        this = _sim2d.new__cavector2(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_carray2') -> "void":
        """push_back(_cavector2 self, _carray2 x)"""
        return _sim2d._cavector2_push_back(self, x)


    def front(self) -> "std::vector< boost::array< std::complex< double >,2 > >::value_type const &":
        """front(_cavector2 self) -> _carray2"""
        return _sim2d._cavector2_front(self)


    def back(self) -> "std::vector< boost::array< std::complex< double >,2 > >::value_type const &":
        """back(_cavector2 self) -> _carray2"""
        return _sim2d._cavector2_back(self)


    def assign(self, n: 'std::vector< boost::array< std::complex< double >,2 > >::size_type', x: '_carray2') -> "void":
        """assign(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::size_type n, _carray2 x)"""
        return _sim2d._cavector2_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::size_type new_size)
        resize(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::size_type new_size, _carray2 x)
        """
        return _sim2d._cavector2_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::iterator pos, _carray2 x) -> std::vector< boost::array< std::complex< double >,2 > >::iterator
        insert(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::iterator pos, std::vector< boost::array< std::complex< double >,2 > >::size_type n, _carray2 x)
        """
        return _sim2d._cavector2_insert(self, *args)


    def reserve(self, n: 'std::vector< boost::array< std::complex< double >,2 > >::size_type') -> "void":
        """reserve(_cavector2 self, std::vector< boost::array< std::complex< double >,2 > >::size_type n)"""
        return _sim2d._cavector2_reserve(self, n)


    def capacity(self) -> "std::vector< boost::array< std::complex< double >,2 > >::size_type":
        """capacity(_cavector2 self) -> std::vector< boost::array< std::complex< double >,2 > >::size_type"""
        return _sim2d._cavector2_capacity(self)

    __swig_destroy__ = _sim2d.delete__cavector2
    __del__ = lambda self: None
_cavector2_swigregister = _sim2d._cavector2_swigregister
_cavector2_swigregister(_cavector2)

class _ccavector2(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ccavector2, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ccavector2, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ccavector2 self) -> SwigPyIterator"""
        return _sim2d._ccavector2_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ccavector2 self) -> bool"""
        return _sim2d._ccavector2___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ccavector2 self) -> bool"""
        return _sim2d._ccavector2___bool__(self)


    def __len__(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type":
        """__len__(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type"""
        return _sim2d._ccavector2___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type', j: 'std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type') -> "std::vector< std::vector< boost::array< std::complex< double >,2 >,std::allocator< boost::array< std::complex< double >,2 > > >,std::allocator< std::vector< boost::array< std::complex< double >,2 >,std::allocator< boost::array< std::complex< double >,2 > > > > > *":
        """__getslice__(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type j) -> _ccavector2"""
        return _sim2d._ccavector2___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type j)
        __setslice__(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type j, _ccavector2 v)
        """
        return _sim2d._ccavector2___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type', j: 'std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type') -> "void":
        """__delslice__(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type j)"""
        return _sim2d._ccavector2___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type i)
        __delitem__(_ccavector2 self, PySliceObject * slice)
        """
        return _sim2d._ccavector2___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::value_type const &":
        """
        __getitem__(_ccavector2 self, PySliceObject * slice) -> _ccavector2
        __getitem__(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type i) -> _cavector2
        """
        return _sim2d._ccavector2___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ccavector2 self, PySliceObject * slice, _ccavector2 v)
        __setitem__(_ccavector2 self, PySliceObject * slice)
        __setitem__(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::difference_type i, _cavector2 x)
        """
        return _sim2d._ccavector2___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::value_type":
        """pop(_ccavector2 self) -> _cavector2"""
        return _sim2d._ccavector2_pop(self)


    def append(self, x: '_cavector2') -> "void":
        """append(_ccavector2 self, _cavector2 x)"""
        return _sim2d._ccavector2_append(self, x)


    def empty(self) -> "bool":
        """empty(_ccavector2 self) -> bool"""
        return _sim2d._ccavector2_empty(self)


    def size(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type":
        """size(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type"""
        return _sim2d._ccavector2_size(self)


    def swap(self, v: '_ccavector2') -> "void":
        """swap(_ccavector2 self, _ccavector2 v)"""
        return _sim2d._ccavector2_swap(self, v)


    def begin(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator":
        """begin(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator"""
        return _sim2d._ccavector2_begin(self)


    def end(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator":
        """end(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator"""
        return _sim2d._ccavector2_end(self)


    def rbegin(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::reverse_iterator":
        """rbegin(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::reverse_iterator"""
        return _sim2d._ccavector2_rbegin(self)


    def rend(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::reverse_iterator":
        """rend(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::reverse_iterator"""
        return _sim2d._ccavector2_rend(self)


    def clear(self) -> "void":
        """clear(_ccavector2 self)"""
        return _sim2d._ccavector2_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::allocator_type":
        """get_allocator(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::allocator_type"""
        return _sim2d._ccavector2_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_ccavector2 self)"""
        return _sim2d._ccavector2_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator":
        """
        erase(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator pos) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator
        erase(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator first, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator last) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator
        """
        return _sim2d._ccavector2_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)> self) -> _ccavector2
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)> self, _ccavector2 arg2) -> _ccavector2
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)> self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type size) -> _ccavector2
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)> self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type size, _cavector2 value) -> _ccavector2
        """
        this = _sim2d.new__ccavector2(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_cavector2') -> "void":
        """push_back(_ccavector2 self, _cavector2 x)"""
        return _sim2d._ccavector2_push_back(self, x)


    def front(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::value_type const &":
        """front(_ccavector2 self) -> _cavector2"""
        return _sim2d._ccavector2_front(self)


    def back(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::value_type const &":
        """back(_ccavector2 self) -> _cavector2"""
        return _sim2d._ccavector2_back(self)


    def assign(self, n: 'std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type', x: '_cavector2') -> "void":
        """assign(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type n, _cavector2 x)"""
        return _sim2d._ccavector2_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type new_size)
        resize(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type new_size, _cavector2 x)
        """
        return _sim2d._ccavector2_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator pos, _cavector2 x) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator
        insert(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::iterator pos, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type n, _cavector2 x)
        """
        return _sim2d._ccavector2_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type') -> "void":
        """reserve(_ccavector2 self, std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type n)"""
        return _sim2d._ccavector2_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type":
        """capacity(_ccavector2 self) -> std::vector< std::vector< boost::array< std::complex< double >,2 > > >::size_type"""
        return _sim2d._ccavector2_capacity(self)

    __swig_destroy__ = _sim2d.delete__ccavector2
    __del__ = lambda self: None
_ccavector2_swigregister = _sim2d._ccavector2_swigregister
_ccavector2_swigregister(_ccavector2)

class _cccavector2(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cccavector2, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _cccavector2, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_cccavector2 self) -> SwigPyIterator"""
        return _sim2d._cccavector2_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_cccavector2 self) -> bool"""
        return _sim2d._cccavector2___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_cccavector2 self) -> bool"""
        return _sim2d._cccavector2___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type":
        """__len__(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type"""
        return _sim2d._cccavector2___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type', j: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type') -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 >,std::allocator< boost::array< std::complex< double >,2 > > >,std::allocator< std::vector< boost::array< std::complex< double >,2 >,std::allocator< boost::array< std::complex< double >,2 > > > > >,std::allocator< std::vector< std::vector< boost::array< std::complex< double >,2 >,std::allocator< boost::array< std::complex< double >,2 > > >,std::allocator< std::vector< boost::array< std::complex< double >,2 >,std::allocator< boost::array< std::complex< double >,2 > > > > > > > *":
        """__getslice__(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type j) -> _cccavector2"""
        return _sim2d._cccavector2___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type j)
        __setslice__(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type j, _cccavector2 v)
        """
        return _sim2d._cccavector2___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type', j: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type') -> "void":
        """__delslice__(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type j)"""
        return _sim2d._cccavector2___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type i)
        __delitem__(_cccavector2 self, PySliceObject * slice)
        """
        return _sim2d._cccavector2___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::value_type const &":
        """
        __getitem__(_cccavector2 self, PySliceObject * slice) -> _cccavector2
        __getitem__(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type i) -> _ccavector2
        """
        return _sim2d._cccavector2___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_cccavector2 self, PySliceObject * slice, _cccavector2 v)
        __setitem__(_cccavector2 self, PySliceObject * slice)
        __setitem__(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::difference_type i, _ccavector2 x)
        """
        return _sim2d._cccavector2___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::value_type":
        """pop(_cccavector2 self) -> _ccavector2"""
        return _sim2d._cccavector2_pop(self)


    def append(self, x: '_ccavector2') -> "void":
        """append(_cccavector2 self, _ccavector2 x)"""
        return _sim2d._cccavector2_append(self, x)


    def empty(self) -> "bool":
        """empty(_cccavector2 self) -> bool"""
        return _sim2d._cccavector2_empty(self)


    def size(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type":
        """size(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type"""
        return _sim2d._cccavector2_size(self)


    def swap(self, v: '_cccavector2') -> "void":
        """swap(_cccavector2 self, _cccavector2 v)"""
        return _sim2d._cccavector2_swap(self, v)


    def begin(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator":
        """begin(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator"""
        return _sim2d._cccavector2_begin(self)


    def end(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator":
        """end(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator"""
        return _sim2d._cccavector2_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::reverse_iterator":
        """rbegin(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::reverse_iterator"""
        return _sim2d._cccavector2_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::reverse_iterator":
        """rend(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::reverse_iterator"""
        return _sim2d._cccavector2_rend(self)


    def clear(self) -> "void":
        """clear(_cccavector2 self)"""
        return _sim2d._cccavector2_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::allocator_type":
        """get_allocator(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::allocator_type"""
        return _sim2d._cccavector2_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_cccavector2 self)"""
        return _sim2d._cccavector2_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator":
        """
        erase(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator pos) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator
        erase(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator first, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator last) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator
        """
        return _sim2d._cccavector2_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)>)> self) -> _cccavector2
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)>)> self, _cccavector2 arg2) -> _cccavector2
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)>)> self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type size) -> _cccavector2
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,2)>)>)>)> self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type size, _ccavector2 value) -> _cccavector2
        """
        this = _sim2d.new__cccavector2(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_ccavector2') -> "void":
        """push_back(_cccavector2 self, _ccavector2 x)"""
        return _sim2d._cccavector2_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::value_type const &":
        """front(_cccavector2 self) -> _ccavector2"""
        return _sim2d._cccavector2_front(self)


    def back(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::value_type const &":
        """back(_cccavector2 self) -> _ccavector2"""
        return _sim2d._cccavector2_back(self)


    def assign(self, n: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type', x: '_ccavector2') -> "void":
        """assign(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type n, _ccavector2 x)"""
        return _sim2d._cccavector2_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type new_size)
        resize(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type new_size, _ccavector2 x)
        """
        return _sim2d._cccavector2_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator pos, _ccavector2 x) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator
        insert(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::iterator pos, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type n, _ccavector2 x)
        """
        return _sim2d._cccavector2_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type') -> "void":
        """reserve(_cccavector2 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type n)"""
        return _sim2d._cccavector2_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type":
        """capacity(_cccavector2 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,2 > > > >::size_type"""
        return _sim2d._cccavector2_capacity(self)

    __swig_destroy__ = _sim2d.delete__cccavector2
    __del__ = lambda self: None
_cccavector2_swigregister = _sim2d._cccavector2_swigregister
_cccavector2_swigregister(_cccavector2)

class _carray3(_object):
    """Proxy of C++ boost::array<(std::complex<(double)>,3)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _carray3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _carray3, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(boost::array<(std::complex<(double)>,3)> self) -> _carray3"""
        this = _sim2d.new__carray3()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete__carray3
    __del__ = lambda self: None

    def swap(self, b: '_carray3') -> "void":
        """swap(_carray3 self, _carray3 b)"""
        return _sim2d._carray3_swap(self, b)


    def __getitem__(self, idx: 'unsigned int') -> "std::complex< double >":
        """__getitem__(_carray3 self, unsigned int idx) -> std::complex< double >"""
        return _sim2d._carray3___getitem__(self, idx)


    def __setitem__(self, idx: 'unsigned int', val: 'std::complex< double >') -> "void":
        """__setitem__(_carray3 self, unsigned int idx, std::complex< double > val)"""
        return _sim2d._carray3___setitem__(self, idx, val)


    def __len__(self) -> "unsigned int":
        """__len__(_carray3 self) -> unsigned int"""
        return _sim2d._carray3___len__(self)


    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

    def __str__(self):
        return str(tuple(self))

    def __repr__(self):
        return repr(tuple(self))

_carray3_swigregister = _sim2d._carray3_swigregister
_carray3_swigregister(_carray3)

class _cavector3(collections.MutableSequence):
    """Proxy of C++ std::vector<(boost::array<(std::complex<(double)>,3)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cavector3, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _cavector3, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_cavector3 self) -> SwigPyIterator"""
        return _sim2d._cavector3_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_cavector3 self) -> bool"""
        return _sim2d._cavector3___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_cavector3 self) -> bool"""
        return _sim2d._cavector3___bool__(self)


    def __len__(self) -> "std::vector< boost::array< std::complex< double >,3 > >::size_type":
        """__len__(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::size_type"""
        return _sim2d._cavector3___len__(self)


    def __getslice__(self, i: 'std::vector< boost::array< std::complex< double >,3 > >::difference_type', j: 'std::vector< boost::array< std::complex< double >,3 > >::difference_type') -> "std::vector< boost::array< std::complex< double >,3 >,std::allocator< boost::array< std::complex< double >,3 > > > *":
        """__getslice__(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::difference_type i, std::vector< boost::array< std::complex< double >,3 > >::difference_type j) -> _cavector3"""
        return _sim2d._cavector3___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::difference_type i, std::vector< boost::array< std::complex< double >,3 > >::difference_type j)
        __setslice__(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::difference_type i, std::vector< boost::array< std::complex< double >,3 > >::difference_type j, _cavector3 v)
        """
        return _sim2d._cavector3___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< boost::array< std::complex< double >,3 > >::difference_type', j: 'std::vector< boost::array< std::complex< double >,3 > >::difference_type') -> "void":
        """__delslice__(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::difference_type i, std::vector< boost::array< std::complex< double >,3 > >::difference_type j)"""
        return _sim2d._cavector3___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::difference_type i)
        __delitem__(_cavector3 self, PySliceObject * slice)
        """
        return _sim2d._cavector3___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< boost::array< std::complex< double >,3 > >::value_type const &":
        """
        __getitem__(_cavector3 self, PySliceObject * slice) -> _cavector3
        __getitem__(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::difference_type i) -> _carray3
        """
        return _sim2d._cavector3___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_cavector3 self, PySliceObject * slice, _cavector3 v)
        __setitem__(_cavector3 self, PySliceObject * slice)
        __setitem__(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::difference_type i, _carray3 x)
        """
        return _sim2d._cavector3___setitem__(self, *args)


    def pop(self) -> "std::vector< boost::array< std::complex< double >,3 > >::value_type":
        """pop(_cavector3 self) -> _carray3"""
        return _sim2d._cavector3_pop(self)


    def append(self, x: '_carray3') -> "void":
        """append(_cavector3 self, _carray3 x)"""
        return _sim2d._cavector3_append(self, x)


    def empty(self) -> "bool":
        """empty(_cavector3 self) -> bool"""
        return _sim2d._cavector3_empty(self)


    def size(self) -> "std::vector< boost::array< std::complex< double >,3 > >::size_type":
        """size(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::size_type"""
        return _sim2d._cavector3_size(self)


    def swap(self, v: '_cavector3') -> "void":
        """swap(_cavector3 self, _cavector3 v)"""
        return _sim2d._cavector3_swap(self, v)


    def begin(self) -> "std::vector< boost::array< std::complex< double >,3 > >::iterator":
        """begin(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::iterator"""
        return _sim2d._cavector3_begin(self)


    def end(self) -> "std::vector< boost::array< std::complex< double >,3 > >::iterator":
        """end(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::iterator"""
        return _sim2d._cavector3_end(self)


    def rbegin(self) -> "std::vector< boost::array< std::complex< double >,3 > >::reverse_iterator":
        """rbegin(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::reverse_iterator"""
        return _sim2d._cavector3_rbegin(self)


    def rend(self) -> "std::vector< boost::array< std::complex< double >,3 > >::reverse_iterator":
        """rend(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::reverse_iterator"""
        return _sim2d._cavector3_rend(self)


    def clear(self) -> "void":
        """clear(_cavector3 self)"""
        return _sim2d._cavector3_clear(self)


    def get_allocator(self) -> "std::vector< boost::array< std::complex< double >,3 > >::allocator_type":
        """get_allocator(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::allocator_type"""
        return _sim2d._cavector3_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_cavector3 self)"""
        return _sim2d._cavector3_pop_back(self)


    def erase(self, *args) -> "std::vector< boost::array< std::complex< double >,3 > >::iterator":
        """
        erase(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::iterator pos) -> std::vector< boost::array< std::complex< double >,3 > >::iterator
        erase(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::iterator first, std::vector< boost::array< std::complex< double >,3 > >::iterator last) -> std::vector< boost::array< std::complex< double >,3 > >::iterator
        """
        return _sim2d._cavector3_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(boost::array<(std::complex<(double)>,3)>)> self) -> _cavector3
        __init__(std::vector<(boost::array<(std::complex<(double)>,3)>)> self, _cavector3 arg2) -> _cavector3
        __init__(std::vector<(boost::array<(std::complex<(double)>,3)>)> self, std::vector< boost::array< std::complex< double >,3 > >::size_type size) -> _cavector3
        __init__(std::vector<(boost::array<(std::complex<(double)>,3)>)> self, std::vector< boost::array< std::complex< double >,3 > >::size_type size, _carray3 value) -> _cavector3
        """
        this = _sim2d.new__cavector3(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_carray3') -> "void":
        """push_back(_cavector3 self, _carray3 x)"""
        return _sim2d._cavector3_push_back(self, x)


    def front(self) -> "std::vector< boost::array< std::complex< double >,3 > >::value_type const &":
        """front(_cavector3 self) -> _carray3"""
        return _sim2d._cavector3_front(self)


    def back(self) -> "std::vector< boost::array< std::complex< double >,3 > >::value_type const &":
        """back(_cavector3 self) -> _carray3"""
        return _sim2d._cavector3_back(self)


    def assign(self, n: 'std::vector< boost::array< std::complex< double >,3 > >::size_type', x: '_carray3') -> "void":
        """assign(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::size_type n, _carray3 x)"""
        return _sim2d._cavector3_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::size_type new_size)
        resize(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::size_type new_size, _carray3 x)
        """
        return _sim2d._cavector3_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::iterator pos, _carray3 x) -> std::vector< boost::array< std::complex< double >,3 > >::iterator
        insert(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::iterator pos, std::vector< boost::array< std::complex< double >,3 > >::size_type n, _carray3 x)
        """
        return _sim2d._cavector3_insert(self, *args)


    def reserve(self, n: 'std::vector< boost::array< std::complex< double >,3 > >::size_type') -> "void":
        """reserve(_cavector3 self, std::vector< boost::array< std::complex< double >,3 > >::size_type n)"""
        return _sim2d._cavector3_reserve(self, n)


    def capacity(self) -> "std::vector< boost::array< std::complex< double >,3 > >::size_type":
        """capacity(_cavector3 self) -> std::vector< boost::array< std::complex< double >,3 > >::size_type"""
        return _sim2d._cavector3_capacity(self)

    __swig_destroy__ = _sim2d.delete__cavector3
    __del__ = lambda self: None
_cavector3_swigregister = _sim2d._cavector3_swigregister
_cavector3_swigregister(_cavector3)

class _ccavector3(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ccavector3, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ccavector3, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ccavector3 self) -> SwigPyIterator"""
        return _sim2d._ccavector3_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ccavector3 self) -> bool"""
        return _sim2d._ccavector3___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ccavector3 self) -> bool"""
        return _sim2d._ccavector3___bool__(self)


    def __len__(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type":
        """__len__(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type"""
        return _sim2d._ccavector3___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type', j: 'std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type') -> "std::vector< std::vector< boost::array< std::complex< double >,3 >,std::allocator< boost::array< std::complex< double >,3 > > >,std::allocator< std::vector< boost::array< std::complex< double >,3 >,std::allocator< boost::array< std::complex< double >,3 > > > > > *":
        """__getslice__(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type j) -> _ccavector3"""
        return _sim2d._ccavector3___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type j)
        __setslice__(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type j, _ccavector3 v)
        """
        return _sim2d._ccavector3___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type', j: 'std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type') -> "void":
        """__delslice__(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type i, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type j)"""
        return _sim2d._ccavector3___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type i)
        __delitem__(_ccavector3 self, PySliceObject * slice)
        """
        return _sim2d._ccavector3___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::value_type const &":
        """
        __getitem__(_ccavector3 self, PySliceObject * slice) -> _ccavector3
        __getitem__(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type i) -> _cavector3
        """
        return _sim2d._ccavector3___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ccavector3 self, PySliceObject * slice, _ccavector3 v)
        __setitem__(_ccavector3 self, PySliceObject * slice)
        __setitem__(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::difference_type i, _cavector3 x)
        """
        return _sim2d._ccavector3___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::value_type":
        """pop(_ccavector3 self) -> _cavector3"""
        return _sim2d._ccavector3_pop(self)


    def append(self, x: '_cavector3') -> "void":
        """append(_ccavector3 self, _cavector3 x)"""
        return _sim2d._ccavector3_append(self, x)


    def empty(self) -> "bool":
        """empty(_ccavector3 self) -> bool"""
        return _sim2d._ccavector3_empty(self)


    def size(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type":
        """size(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type"""
        return _sim2d._ccavector3_size(self)


    def swap(self, v: '_ccavector3') -> "void":
        """swap(_ccavector3 self, _ccavector3 v)"""
        return _sim2d._ccavector3_swap(self, v)


    def begin(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator":
        """begin(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator"""
        return _sim2d._ccavector3_begin(self)


    def end(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator":
        """end(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator"""
        return _sim2d._ccavector3_end(self)


    def rbegin(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::reverse_iterator":
        """rbegin(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::reverse_iterator"""
        return _sim2d._ccavector3_rbegin(self)


    def rend(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::reverse_iterator":
        """rend(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::reverse_iterator"""
        return _sim2d._ccavector3_rend(self)


    def clear(self) -> "void":
        """clear(_ccavector3 self)"""
        return _sim2d._ccavector3_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::allocator_type":
        """get_allocator(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::allocator_type"""
        return _sim2d._ccavector3_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_ccavector3 self)"""
        return _sim2d._ccavector3_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator":
        """
        erase(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator pos) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator
        erase(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator first, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator last) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator
        """
        return _sim2d._ccavector3_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)> self) -> _ccavector3
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)> self, _ccavector3 arg2) -> _ccavector3
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)> self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type size) -> _ccavector3
        __init__(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)> self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type size, _cavector3 value) -> _ccavector3
        """
        this = _sim2d.new__ccavector3(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_cavector3') -> "void":
        """push_back(_ccavector3 self, _cavector3 x)"""
        return _sim2d._ccavector3_push_back(self, x)


    def front(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::value_type const &":
        """front(_ccavector3 self) -> _cavector3"""
        return _sim2d._ccavector3_front(self)


    def back(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::value_type const &":
        """back(_ccavector3 self) -> _cavector3"""
        return _sim2d._ccavector3_back(self)


    def assign(self, n: 'std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type', x: '_cavector3') -> "void":
        """assign(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type n, _cavector3 x)"""
        return _sim2d._ccavector3_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type new_size)
        resize(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type new_size, _cavector3 x)
        """
        return _sim2d._ccavector3_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator pos, _cavector3 x) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator
        insert(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::iterator pos, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type n, _cavector3 x)
        """
        return _sim2d._ccavector3_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type') -> "void":
        """reserve(_ccavector3 self, std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type n)"""
        return _sim2d._ccavector3_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type":
        """capacity(_ccavector3 self) -> std::vector< std::vector< boost::array< std::complex< double >,3 > > >::size_type"""
        return _sim2d._ccavector3_capacity(self)

    __swig_destroy__ = _sim2d.delete__ccavector3
    __del__ = lambda self: None
_ccavector3_swigregister = _sim2d._ccavector3_swigregister
_ccavector3_swigregister(_ccavector3)

class _cccavector3(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)>)> class."""

    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cccavector3, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _cccavector3, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_cccavector3 self) -> SwigPyIterator"""
        return _sim2d._cccavector3_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_cccavector3 self) -> bool"""
        return _sim2d._cccavector3___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_cccavector3 self) -> bool"""
        return _sim2d._cccavector3___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type":
        """__len__(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type"""
        return _sim2d._cccavector3___len__(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type', j: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type') -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 >,std::allocator< boost::array< std::complex< double >,3 > > >,std::allocator< std::vector< boost::array< std::complex< double >,3 >,std::allocator< boost::array< std::complex< double >,3 > > > > >,std::allocator< std::vector< std::vector< boost::array< std::complex< double >,3 >,std::allocator< boost::array< std::complex< double >,3 > > >,std::allocator< std::vector< boost::array< std::complex< double >,3 >,std::allocator< boost::array< std::complex< double >,3 > > > > > > > *":
        """__getslice__(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type j) -> _cccavector3"""
        return _sim2d._cccavector3___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type j)
        __setslice__(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type j, _cccavector3 v)
        """
        return _sim2d._cccavector3___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type', j: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type') -> "void":
        """__delslice__(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type i, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type j)"""
        return _sim2d._cccavector3___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type i)
        __delitem__(_cccavector3 self, PySliceObject * slice)
        """
        return _sim2d._cccavector3___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::value_type const &":
        """
        __getitem__(_cccavector3 self, PySliceObject * slice) -> _cccavector3
        __getitem__(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type i) -> _ccavector3
        """
        return _sim2d._cccavector3___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_cccavector3 self, PySliceObject * slice, _cccavector3 v)
        __setitem__(_cccavector3 self, PySliceObject * slice)
        __setitem__(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::difference_type i, _ccavector3 x)
        """
        return _sim2d._cccavector3___setitem__(self, *args)


    def pop(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::value_type":
        """pop(_cccavector3 self) -> _ccavector3"""
        return _sim2d._cccavector3_pop(self)


    def append(self, x: '_ccavector3') -> "void":
        """append(_cccavector3 self, _ccavector3 x)"""
        return _sim2d._cccavector3_append(self, x)


    def empty(self) -> "bool":
        """empty(_cccavector3 self) -> bool"""
        return _sim2d._cccavector3_empty(self)


    def size(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type":
        """size(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type"""
        return _sim2d._cccavector3_size(self)


    def swap(self, v: '_cccavector3') -> "void":
        """swap(_cccavector3 self, _cccavector3 v)"""
        return _sim2d._cccavector3_swap(self, v)


    def begin(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator":
        """begin(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator"""
        return _sim2d._cccavector3_begin(self)


    def end(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator":
        """end(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator"""
        return _sim2d._cccavector3_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::reverse_iterator":
        """rbegin(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::reverse_iterator"""
        return _sim2d._cccavector3_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::reverse_iterator":
        """rend(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::reverse_iterator"""
        return _sim2d._cccavector3_rend(self)


    def clear(self) -> "void":
        """clear(_cccavector3 self)"""
        return _sim2d._cccavector3_clear(self)


    def get_allocator(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::allocator_type":
        """get_allocator(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::allocator_type"""
        return _sim2d._cccavector3_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(_cccavector3 self)"""
        return _sim2d._cccavector3_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator":
        """
        erase(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator pos) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator
        erase(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator first, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator last) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator
        """
        return _sim2d._cccavector3_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)>)> self) -> _cccavector3
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)>)> self, _cccavector3 arg2) -> _cccavector3
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)>)> self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type size) -> _cccavector3
        __init__(std::vector<(std::vector<(std::vector<(boost::array<(std::complex<(double)>,3)>)>)>)> self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type size, _ccavector3 value) -> _cccavector3
        """
        this = _sim2d.new__cccavector3(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: '_ccavector3') -> "void":
        """push_back(_cccavector3 self, _ccavector3 x)"""
        return _sim2d._cccavector3_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::value_type const &":
        """front(_cccavector3 self) -> _ccavector3"""
        return _sim2d._cccavector3_front(self)


    def back(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::value_type const &":
        """back(_cccavector3 self) -> _ccavector3"""
        return _sim2d._cccavector3_back(self)


    def assign(self, n: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type', x: '_ccavector3') -> "void":
        """assign(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type n, _ccavector3 x)"""
        return _sim2d._cccavector3_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type new_size)
        resize(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type new_size, _ccavector3 x)
        """
        return _sim2d._cccavector3_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator pos, _ccavector3 x) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator
        insert(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::iterator pos, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type n, _ccavector3 x)
        """
        return _sim2d._cccavector3_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type') -> "void":
        """reserve(_cccavector3 self, std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type n)"""
        return _sim2d._cccavector3_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type":
        """capacity(_cccavector3 self) -> std::vector< std::vector< std::vector< boost::array< std::complex< double >,3 > > > >::size_type"""
        return _sim2d._cccavector3_capacity(self)

    __swig_destroy__ = _sim2d.delete__cccavector3
    __del__ = lambda self: None
_cccavector3_swigregister = _sim2d._cccavector3_swigregister
_cccavector3_swigregister(_cccavector3)


_sim2d.NDIM_swigconstant(_sim2d)
NDIM = _sim2d.NDIM

_sim2d.DIMROTATIONS_swigconstant(_sim2d)
DIMROTATIONS = _sim2d.DIMROTATIONS

def vec(*args) -> "Vec3":
    """
    vec() -> Vec
    vec(double x, double y) -> Vec2
    vec(double x, double y, double z) -> Vec3
    """
    return _sim2d.vec(*args)

def cross(*args) -> "Vec2":
    """
    cross(Vec3 v1, Vec3 v2) -> Vec3
    cross(Vec2 v1, Vec2 v2) -> flt
    cross(Vec2 v, flt n) -> Vec2
    """
    return _sim2d.cross(*args)

def perp(v: 'Vec2') -> "Vec2":
    """perp(Vec2 v) -> Vec2"""
    return _sim2d.perp(v)

def perpto(r: 'Vec', to: 'Vec') -> "Vec":
    """perpto(Vec r, Vec to) -> Vec"""
    return _sim2d.perpto(r, to)

def rotate(*args) -> "Vec3":
    """
    rotate(Vec2 v, uint i) -> Vec2
    rotate(Vec3 v, uint i) -> Vec3
    """
    return _sim2d.rotate(*args)

def rotate_inv(*args) -> "Vec3":
    """
    rotate_inv(Vec2 v, uint i) -> Vec2
    rotate_inv(Vec3 v, uint i) -> Vec3
    """
    return _sim2d.rotate_inv(*args)

def flip(*args) -> "Vec3":
    """
    flip(Vec2 v) -> Vec2
    flip(Vec3 v) -> Vec3
    """
    return _sim2d.flip(*args)

def rotate_flip(*args) -> "Vec3":
    """
    rotate_flip(Vec2 v, uint i) -> Vec2
    rotate_flip(Vec3 v, uint i) -> Vec3
    """
    return _sim2d.rotate_flip(*args)

def rotate_flip_inv(*args) -> "Vec3":
    """
    rotate_flip_inv(Vec2 v, uint i) -> Vec2
    rotate_flip_inv(Vec3 v, uint i) -> Vec3
    """
    return _sim2d.rotate_flip_inv(*args)

def vecsize() -> "uint":
    """vecsize() -> uint"""
    return _sim2d.vecsize()

def rand01() -> "flt":
    """rand01() -> flt"""
    return _sim2d.rand01()

def rand_vec() -> "Vec":
    """rand_vec() -> Vec"""
    return _sim2d.rand_vec()

def rand_vec_boxed() -> "Vec":
    """rand_vec_boxed() -> Vec"""
    return _sim2d.rand_vec_boxed()

def seed(*args) -> "unsigned int":
    """
    seed(unsigned int n) -> unsigned int
    seed() -> unsigned int
    """
    return _sim2d.seed(*args)
class GaussVec(_object):
    """Proxy of C++ GaussVec class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GaussVec, name)
    __repr__ = _swig_repr

    def __init__(self, sigma: 'flt'):
        """__init__(GaussVec self, flt sigma) -> GaussVec"""
        this = _sim2d.new_GaussVec(sigma)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set(self, sigma: 'flt') -> "void":
        """set(GaussVec self, flt sigma)"""
        return _sim2d.GaussVec_set(self, sigma)


    def generate(self) -> "Vec":
        """generate(GaussVec self) -> Vec"""
        return _sim2d.GaussVec_generate(self)

    __swig_destroy__ = _sim2d.delete_GaussVec
    __del__ = lambda self: None
GaussVec_swigregister = _sim2d.GaussVec_swigregister
GaussVec_swigregister(GaussVec)
cvar = _sim2d.cvar
OVERNDIM = cvar.OVERNDIM

class BivariateGauss(_object):
    """Proxy of C++ BivariateGauss class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BivariateGauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BivariateGauss, name)
    __repr__ = _swig_repr

    def __init__(self, s1: 'flt const'=1, s2: 'flt const'=1, corr: 'flt const'=0):
        """
        __init__(BivariateGauss self, flt const s1=1, flt const s2=1, flt const corr=0) -> BivariateGauss
        __init__(BivariateGauss self, flt const s1=1, flt const s2=1) -> BivariateGauss
        __init__(BivariateGauss self, flt const s1=1) -> BivariateGauss
        __init__(BivariateGauss self) -> BivariateGauss
        """
        this = _sim2d.new_BivariateGauss(s1, s2, corr)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set(self, s1: 'flt const', s2: 'flt const', corr: 'flt const') -> "void":
        """set(BivariateGauss self, flt const s1, flt const s2, flt const corr)"""
        return _sim2d.BivariateGauss_set(self, s1, s2, corr)


    def generate(self) -> "Eigen::Matrix< flt,1,2 >":
        """generate(BivariateGauss self) -> Eigen::Matrix< flt,1,2 >"""
        return _sim2d.BivariateGauss_generate(self)


    def gen_vec(self) -> "Vec":
        """gen_vec(BivariateGauss self) -> Vec"""
        return _sim2d.BivariateGauss_gen_vec(self)


    def gen_vecs(self) -> "VecPair":
        """gen_vecs(BivariateGauss self) -> VecPair"""
        return _sim2d.BivariateGauss_gen_vecs(self)

    __swig_destroy__ = _sim2d.delete_BivariateGauss
    __del__ = lambda self: None
BivariateGauss_swigregister = _sim2d.BivariateGauss_swigregister
BivariateGauss_swigregister(BivariateGauss)


def to_LD(e: 'double') -> "long double":
    """to_LD(double e) -> long double"""
    return _sim2d.to_LD(e)

def from_LD(e: 'long double') -> "double":
    """from_LD(long double e) -> double"""
    return _sim2d.from_LD(e)

def LDVector(dists: 'dvector') -> "std::vector< long double,std::allocator< long double > >":
    """LDVector(dvector dists) -> ldvector"""
    return _sim2d.LDVector(dists)

def to_buffer(arr: 'std::vector< Vec *,std::allocator< Vec * > >', buffer: 'double *') -> "bool":
    """to_buffer(std::vector< Vec *,std::allocator< Vec * > > arr, double * buffer) -> bool"""
    return _sim2d.to_buffer(arr, buffer)
class Box(_object):
    """Proxy of C++ Box class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Box, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Box, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def diff(self, r1: 'Vec', r2: 'Vec') -> "Vec":
        """diff(Box self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.Box_diff(self, r1, r2)


    def V(self) -> "flt":
        """V(Box self) -> flt"""
        return _sim2d.Box_V(self)

    __swig_destroy__ = _sim2d.delete_Box
    __del__ = lambda self: None
Box_swigregister = _sim2d.Box_swigregister
Box_swigregister(Box)


def vec_mod(r1: 'Vec', r2: 'Vec') -> "Vec":
    """vec_mod(Vec r1, Vec r2) -> Vec"""
    return _sim2d.vec_mod(r1, r2)
class InfiniteBox(Box):
    """Proxy of C++ InfiniteBox class."""

    __swig_setmethods__ = {}
    for _s in [Box]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfiniteBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfiniteBox, name)
    __repr__ = _swig_repr

    def diff(self, r1: 'Vec', r2: 'Vec') -> "Vec":
        """diff(InfiniteBox self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.InfiniteBox_diff(self, r1, r2)


    def V(self) -> "flt":
        """V(InfiniteBox self) -> flt"""
        return _sim2d.InfiniteBox_V(self)


    def __init__(self):
        """__init__(InfiniteBox self) -> InfiniteBox"""
        this = _sim2d.new_InfiniteBox()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_InfiniteBox
    __del__ = lambda self: None
InfiniteBox_swigregister = _sim2d.InfiniteBox_swigregister
InfiniteBox_swigregister(InfiniteBox)

class OriginBox(Box):
    """Proxy of C++ OriginBox class."""

    __swig_setmethods__ = {}
    for _s in [Box]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OriginBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OriginBox, name)
    __repr__ = _swig_repr

    def diff(self, *args) -> "Vec":
        """
        diff(OriginBox self, Vec r1, Vec r2) -> Vec
        diff(OriginBox self, Vec r1, Vec r2, boost::array< int,2 > boxes) -> Vec
        """
        return _sim2d.OriginBox_diff(self, *args)


    def box_round(self, r1: 'Vec', r2: 'Vec') -> "boost::array< int,2 >":
        """box_round(OriginBox self, Vec r1, Vec r2) -> boost::array< int,2 >"""
        return _sim2d.OriginBox_box_round(self, r1, r2)


    def __init__(self, *args):
        """
        __init__(OriginBox self, Vec size) -> OriginBox
        __init__(OriginBox self, flt L) -> OriginBox
        """
        this = _sim2d.new_OriginBox(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def V(self) -> "flt":
        """V(OriginBox self) -> flt"""
        return _sim2d.OriginBox_V(self)


    def L(self) -> "flt":
        """L(OriginBox self) -> flt"""
        return _sim2d.OriginBox_L(self)


    def resize(self, *args) -> "flt":
        """
        resize(OriginBox self, flt factor) -> flt
        resize(OriginBox self, flt factor, AtomGroup atoms) -> flt
        """
        return _sim2d.OriginBox_resize(self, *args)


    def resize_to(self, *args) -> "flt":
        """
        resize_to(OriginBox self, Vec newsize) -> flt
        resize_to(OriginBox self, Vec newsize, AtomGroup atoms) -> flt
        """
        return _sim2d.OriginBox_resize_to(self, *args)


    def resize_to_V(self, *args) -> "flt":
        """
        resize_to_V(OriginBox self, flt newV) -> flt
        resize_to_V(OriginBox self, flt newV, AtomGroup atoms) -> flt
        """
        return _sim2d.OriginBox_resize_to_V(self, *args)


    def resize_to_L(self, *args) -> "flt":
        """
        resize_to_L(OriginBox self, flt newL) -> flt
        resize_to_L(OriginBox self, flt newL, AtomGroup atoms) -> flt
        """
        return _sim2d.OriginBox_resize_to_L(self, *args)


    def rand_loc(self) -> "Vec":
        """rand_loc(OriginBox self) -> Vec"""
        return _sim2d.OriginBox_rand_loc(self)


    def box_shape(self) -> "Vec":
        """box_shape(OriginBox self) -> Vec"""
        return _sim2d.OriginBox_box_shape(self)


    def pure_shear_to(self, *args) -> "void":
        """
        pure_shear_to(OriginBox self, flt epsilon)
        pure_shear_to(OriginBox self, flt epsilon, AtomGroup atoms)
        """
        return _sim2d.OriginBox_pure_shear_to(self, *args)

    __swig_destroy__ = _sim2d.delete_OriginBox
    __del__ = lambda self: None
OriginBox_swigregister = _sim2d.OriginBox_swigregister
OriginBox_swigregister(OriginBox)

class LeesEdwardsBox(OriginBox):
    """Proxy of C++ LeesEdwardsBox class."""

    __swig_setmethods__ = {}
    for _s in [OriginBox]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LeesEdwardsBox, name, value)
    __swig_getmethods__ = {}
    for _s in [OriginBox]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LeesEdwardsBox, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LeesEdwardsBox self, Vec size, flt gamma=0.0) -> LeesEdwardsBox
        __init__(LeesEdwardsBox self, Vec size) -> LeesEdwardsBox
        __init__(LeesEdwardsBox self, flt L, flt gamma=0.0) -> LeesEdwardsBox
        __init__(LeesEdwardsBox self, flt L) -> LeesEdwardsBox
        """
        this = _sim2d.new_LeesEdwardsBox(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def diff(self, *args) -> "Vec":
        """
        diff(LeesEdwardsBox self, Vec r1, Vec r2) -> Vec
        diff(LeesEdwardsBox self, Vec r1, Vec r2, boost::array< int,2 > boxes) -> Vec
        """
        return _sim2d.LeesEdwardsBox_diff(self, *args)


    def box_round(self, r1: 'Vec', r2: 'Vec') -> "boost::array< int,2 >":
        """box_round(LeesEdwardsBox self, Vec r1, Vec r2) -> boost::array< int,2 >"""
        return _sim2d.LeesEdwardsBox_box_round(self, r1, r2)


    def get_gamma(self) -> "flt":
        """get_gamma(LeesEdwardsBox self) -> flt"""
        return _sim2d.LeesEdwardsBox_get_gamma(self)


    def shear(self, *args) -> "void":
        """
        shear(LeesEdwardsBox self, flt dgamma)
        shear(LeesEdwardsBox self, flt dgamma, AtomGroup atoms)
        """
        return _sim2d.LeesEdwardsBox_shear(self, *args)


    def shear_to(self, *args) -> "void":
        """
        shear_to(LeesEdwardsBox self, flt gamma)
        shear_to(LeesEdwardsBox self, flt gamma, AtomGroup atoms)
        """
        return _sim2d.LeesEdwardsBox_shear_to(self, *args)


    def non_affine(self, v: 'Vec') -> "Vec":
        """non_affine(LeesEdwardsBox self, Vec v) -> Vec"""
        return _sim2d.LeesEdwardsBox_non_affine(self, v)


    def affine(self, v: 'Vec') -> "Vec":
        """affine(LeesEdwardsBox self, Vec v) -> Vec"""
        return _sim2d.LeesEdwardsBox_affine(self, v)

    __swig_destroy__ = _sim2d.delete_LeesEdwardsBox
    __del__ = lambda self: None
LeesEdwardsBox_swigregister = _sim2d.LeesEdwardsBox_swigregister
LeesEdwardsBox_swigregister(LeesEdwardsBox)

class SCBox(Box):
    """Proxy of C++ SCBox class."""

    __swig_setmethods__ = {}
    for _s in [Box]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCBox, name)
    __repr__ = _swig_repr

    def __init__(self, L: 'flt', R: 'flt'):
        """__init__(SCBox self, flt L, flt R) -> SCBox"""
        this = _sim2d.new_SCBox(L, R)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def diff(self, r1: 'Vec', r2: 'Vec') -> "Vec":
        """diff(SCBox self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.SCBox_diff(self, r1, r2)


    def V(self) -> "flt":
        """V(SCBox self) -> flt"""
        return _sim2d.SCBox_V(self)


    def dist(self, r1: 'Vec') -> "Vec":
        """dist(SCBox self, Vec r1) -> Vec"""
        return _sim2d.SCBox_dist(self, r1)


    def edge_dist(self, r1: 'Vec') -> "Vec":
        """edge_dist(SCBox self, Vec r1) -> Vec"""
        return _sim2d.SCBox_edge_dist(self, r1)


    def inside(self, r1: 'Vec', buffer: 'flt'=0.0) -> "bool":
        """
        inside(SCBox self, Vec r1, flt buffer=0.0) -> bool
        inside(SCBox self, Vec r1) -> bool
        """
        return _sim2d.SCBox_inside(self, r1, buffer)


    def rand_loc(self, min_dist_to_wall: 'flt'=0.0) -> "Vec":
        """
        rand_loc(SCBox self, flt min_dist_to_wall=0.0) -> Vec
        rand_loc(SCBox self) -> Vec
        """
        return _sim2d.SCBox_rand_loc(self, min_dist_to_wall)


    def length(self) -> "flt":
        """length(SCBox self) -> flt"""
        return _sim2d.SCBox_length(self)


    def radius(self) -> "flt":
        """radius(SCBox self) -> flt"""
        return _sim2d.SCBox_radius(self)

    __swig_destroy__ = _sim2d.delete_SCBox
    __del__ = lambda self: None
SCBox_swigregister = _sim2d.SCBox_swigregister
SCBox_swigregister(SCBox)

class Atom(_object):
    """Proxy of C++ Atom class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Atom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Atom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _sim2d.Atom_x_set
    __swig_getmethods__["x"] = _sim2d.Atom_x_get
    if _newclass:
        x = _swig_property(_sim2d.Atom_x_get, _sim2d.Atom_x_set)
    __swig_setmethods__["v"] = _sim2d.Atom_v_set
    __swig_getmethods__["v"] = _sim2d.Atom_v_get
    if _newclass:
        v = _swig_property(_sim2d.Atom_v_get, _sim2d.Atom_v_set)
    __swig_setmethods__["a"] = _sim2d.Atom_a_set
    __swig_getmethods__["a"] = _sim2d.Atom_a_get
    if _newclass:
        a = _swig_property(_sim2d.Atom_a_get, _sim2d.Atom_a_set)
    __swig_setmethods__["f"] = _sim2d.Atom_f_set
    __swig_getmethods__["f"] = _sim2d.Atom_f_get
    if _newclass:
        f = _swig_property(_sim2d.Atom_f_get, _sim2d.Atom_f_set)
    __swig_setmethods__["m"] = _sim2d.Atom_m_set
    __swig_getmethods__["m"] = _sim2d.Atom_m_get
    if _newclass:
        m = _swig_property(_sim2d.Atom_m_get, _sim2d.Atom_m_set)

    def __getstate__(self):
        return (tuple(self.x),tuple(self.v),tuple(self.f), tuple(self.a))

    def __setstate__(self, lst):
        self.x, self.v, self.f, self.a = [Vec(*r) for r in lst]

    def __str__(self):
        if hasattr(self, 'name'):
            return "<Atom %s>" % self.name
        return "<Atom>"

    def __repr__(self):
    #ifdef VEC2D
        x,y = tuple(self.x)
        if hasattr(self, 'name'):
            return "<Atom %s at (%.2f,%.2f)>" % (self.name,x,y)
        return "<Atom at (%.2f,%.2f)>" % (x,y)
    #else
        x,y,z = tuple(self.x)
        if hasattr(self, 'name'):
            return "<Atom %s at (%.2f,%.2f,%.2f)>" % (self.name,x,y,z)
        return "<Atom at (%.2f,%.2f,%.2f)>" % (x,y,z)
    #endif


    def __init__(self):
        """__init__(Atom self) -> Atom"""
        this = _sim2d.new_Atom()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_Atom
    __del__ = lambda self: None
Atom_swigregister = _sim2d.Atom_swigregister
Atom_swigregister(Atom)

class AtomRef(_object):
    """Proxy of C++ AtomRef class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtomRef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AtomRef, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AtomRef self) -> AtomRef
        __init__(AtomRef self, Atom a) -> AtomRef
        """
        this = _sim2d.new_AtomRef(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __ref__(self) -> "Atom &":
        """__ref__(AtomRef self) -> Atom"""
        return _sim2d.AtomRef___ref__(self)


    def __deref__(self) -> "Atom *":
        """__deref__(AtomRef self) -> Atom"""
        return _sim2d.AtomRef___deref__(self)


    def __eq__(self, *args) -> "bool":
        """
        __eq__(AtomRef self, AtomRef other) -> bool
        __eq__(AtomRef self, Atom other) -> bool
        """
        return _sim2d.AtomRef___eq__(self, *args)


    def __ne__(self, other: 'AtomRef') -> "bool":
        """__ne__(AtomRef self, AtomRef other) -> bool"""
        return _sim2d.AtomRef___ne__(self, other)


    def __lt__(self, other: 'AtomRef') -> "bool":
        """__lt__(AtomRef self, AtomRef other) -> bool"""
        return _sim2d.AtomRef___lt__(self, other)


    def __le__(self, other: 'AtomRef') -> "bool":
        """__le__(AtomRef self, AtomRef other) -> bool"""
        return _sim2d.AtomRef___le__(self, other)


    def __ge__(self, other: 'AtomRef') -> "bool":
        """__ge__(AtomRef self, AtomRef other) -> bool"""
        return _sim2d.AtomRef___ge__(self, other)


    def __gt__(self, other: 'AtomRef') -> "bool":
        """__gt__(AtomRef self, AtomRef other) -> bool"""
        return _sim2d.AtomRef___gt__(self, other)


    def is_null(self) -> "bool":
        """is_null(AtomRef self) -> bool"""
        return _sim2d.AtomRef_is_null(self)

    __swig_destroy__ = _sim2d.delete_AtomRef
    __del__ = lambda self: None
    __swig_setmethods__["x"] = _sim2d.AtomRef_x_set
    __swig_getmethods__["x"] = _sim2d.AtomRef_x_get
    if _newclass:
        x = _swig_property(_sim2d.AtomRef_x_get, _sim2d.AtomRef_x_set)
    __swig_setmethods__["v"] = _sim2d.AtomRef_v_set
    __swig_getmethods__["v"] = _sim2d.AtomRef_v_get
    if _newclass:
        v = _swig_property(_sim2d.AtomRef_v_get, _sim2d.AtomRef_v_set)
    __swig_setmethods__["a"] = _sim2d.AtomRef_a_set
    __swig_getmethods__["a"] = _sim2d.AtomRef_a_get
    if _newclass:
        a = _swig_property(_sim2d.AtomRef_a_get, _sim2d.AtomRef_a_set)
    __swig_setmethods__["f"] = _sim2d.AtomRef_f_set
    __swig_getmethods__["f"] = _sim2d.AtomRef_f_get
    if _newclass:
        f = _swig_property(_sim2d.AtomRef_f_get, _sim2d.AtomRef_f_set)
    __swig_setmethods__["m"] = _sim2d.AtomRef_m_set
    __swig_getmethods__["m"] = _sim2d.AtomRef_m_get
    if _newclass:
        m = _swig_property(_sim2d.AtomRef_m_get, _sim2d.AtomRef_m_set)
AtomRef_swigregister = _sim2d.AtomRef_swigregister
AtomRef_swigregister(AtomRef)

class AtomID(AtomRef):
    """Proxy of C++ AtomID class."""

    __swig_setmethods__ = {}
    for _s in [AtomRef]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtomID, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomRef]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AtomID, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AtomID self) -> AtomID
        __init__(AtomID self, Atom a, uint n) -> AtomID
        """
        this = _sim2d.new_AtomID(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def n(self) -> "uint":
        """n(AtomID self) -> uint"""
        return _sim2d.AtomID_n(self)


    def __str__(self):
        return "<AtomID %s>" % self.n()

    def __repr__(self):
        if len(self.x) == 2:
            x,y = tuple(self.x)
            return "<AtomID %s at (%.2f,%.2f)>" % (self.n(),x,y)
        else:
            x,y,z = tuple(self.x)
            return "<AtomID %s at (%.2f,%.2f,%.2f)>" % (self.n(),x,y,z)

    __swig_destroy__ = _sim2d.delete_AtomID
    __del__ = lambda self: None
AtomID_swigregister = _sim2d.AtomID_swigregister
AtomID_swigregister(AtomID)

class IDPair(_object):
    """Proxy of C++ IDPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IDPair self) -> IDPair
        __init__(IDPair self, AtomID a, AtomID b) -> IDPair
        """
        this = _sim2d.new_IDPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def first(self) -> "AtomID":
        """first(IDPair self) -> AtomID"""
        return _sim2d.IDPair_first(self)


    def last(self) -> "AtomID":
        """last(IDPair self) -> AtomID"""
        return _sim2d.IDPair_last(self)


    def __iter__(self):
        return iter((self.first(), self.last()))

    __swig_destroy__ = _sim2d.delete_IDPair
    __del__ = lambda self: None
IDPair_swigregister = _sim2d.IDPair_swigregister
IDPair_swigregister(IDPair)

class AtomGroup(_object):
    """Proxy of C++ AtomGroup class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtomGroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AtomGroup, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def vec(self) -> "AtomVec &":
        """vec(AtomGroup self) -> AtomVec"""
        return _sim2d.AtomGroup_vec(self)


    def get(self, n: 'cuint') -> "Atom &":
        """get(AtomGroup self, cuint n) -> Atom"""
        return _sim2d.AtomGroup_get(self, n)


    def get_id(self, n: 'cuint') -> "AtomID":
        """get_id(AtomGroup self, cuint n) -> AtomID"""
        return _sim2d.AtomGroup_get_id(self, n)


    def size(self) -> "uint":
        """size(AtomGroup self) -> uint"""
        return _sim2d.AtomGroup_size(self)


    def begin(self) -> "AtomIter":
        """begin(AtomGroup self) -> AtomIter"""
        return _sim2d.AtomGroup_begin(self)


    def end(self) -> "AtomIter":
        """end(AtomGroup self) -> AtomIter"""
        return _sim2d.AtomGroup_end(self)


    def com(self) -> "Vec":
        """com(AtomGroup self) -> Vec"""
        return _sim2d.AtomGroup_com(self)


    def com_force(self) -> "Vec":
        """com_force(AtomGroup self) -> Vec"""
        return _sim2d.AtomGroup_com_force(self)


    def com_velocity(self) -> "Vec":
        """com_velocity(AtomGroup self) -> Vec"""
        return _sim2d.AtomGroup_com_velocity(self)


    def mass(self) -> "flt":
        """mass(AtomGroup self) -> flt"""
        return _sim2d.AtomGroup_mass(self)


    def kinetic_energy(self, *args) -> "flt":
        """
        kinetic_energy(AtomGroup self, Vec const originvelocity) -> flt
        kinetic_energy(AtomGroup self) -> flt
        """
        return _sim2d.AtomGroup_kinetic_energy(self, *args)


    def momentum(self) -> "Vec":
        """momentum(AtomGroup self) -> Vec"""
        return _sim2d.AtomGroup_momentum(self)


    def gyradius(self) -> "flt":
        """gyradius(AtomGroup self) -> flt"""
        return _sim2d.AtomGroup_gyradius(self)


    def torque(self, loc: 'Vec const') -> "flt":
        """torque(AtomGroup self, Vec const loc) -> flt"""
        return _sim2d.AtomGroup_torque(self, loc)


    def moment(self, *args) -> "flt":
        """
        moment(AtomGroup self, Vec const loc) -> flt
        moment(AtomGroup self) -> flt
        """
        return _sim2d.AtomGroup_moment(self, *args)


    def angular_momentum(self, *args) -> "flt":
        """
        angular_momentum(AtomGroup self, Vec const loc) -> flt
        angular_momentum(AtomGroup self) -> flt
        """
        return _sim2d.AtomGroup_angular_momentum(self, *args)


    def omega(self, *args) -> "flt":
        """
        omega(AtomGroup self, Vec const loc) -> flt
        omega(AtomGroup self) -> flt
        """
        return _sim2d.AtomGroup_omega(self, *args)


    def add_omega(self, *args) -> "void":
        """
        add_omega(AtomGroup self, flt w, Vec origin)
        add_omega(AtomGroup self, flt w)
        """
        return _sim2d.AtomGroup_add_omega(self, *args)


    def reset_L(self) -> "void":
        """reset_L(AtomGroup self)"""
        return _sim2d.AtomGroup_reset_L(self)


    def add_velocity(self, v: 'Vec') -> "void":
        """add_velocity(AtomGroup self, Vec v)"""
        return _sim2d.AtomGroup_add_velocity(self, v)


    def reset_com_velocity(self) -> "void":
        """reset_com_velocity(AtomGroup self)"""
        return _sim2d.AtomGroup_reset_com_velocity(self)


    def randomize_velocities(self, T: 'flt') -> "void":
        """randomize_velocities(AtomGroup self, flt T)"""
        return _sim2d.AtomGroup_randomize_velocities(self, T)


    def reset_forces(self) -> "void":
        """reset_forces(AtomGroup self)"""
        return _sim2d.AtomGroup_reset_forces(self)

    __swig_destroy__ = _sim2d.delete_AtomGroup
    __del__ = lambda self: None

    def __iter__(self):
        for i in range(self.size()):
            yield self.get_id(i)

AtomGroup_swigregister = _sim2d.AtomGroup_swigregister
AtomGroup_swigregister(AtomGroup)

class AtomVec(AtomGroup):
    """Proxy of C++ AtomVec class."""

    __swig_setmethods__ = {}
    for _s in [AtomGroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtomVec, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomGroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AtomVec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AtomVec self, dvector masses) -> AtomVec
        __init__(AtomVec self, uint N, flt mass) -> AtomVec
        __init__(AtomVec self, AtomVec other) -> AtomVec
        """
        this = _sim2d.new_AtomVec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def vec(self) -> "AtomVec &":
        """vec(AtomVec self) -> AtomVec"""
        return _sim2d.AtomVec_vec(self)


    def get_id(self, n: 'cuint') -> "AtomID":
        """get_id(AtomVec self, cuint n) -> AtomID"""
        return _sim2d.AtomVec_get_id(self, n)


    def size(self) -> "uint":
        """size(AtomVec self) -> uint"""
        return _sim2d.AtomVec_size(self)

    __swig_destroy__ = _sim2d.delete_AtomVec
    __del__ = lambda self: None

    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def __len__(self):
        return self.size()

    def __getitem__(self, obj):
        return self.get_id(obj)

    def __str__(self):
        return str(list(self))

    #def __setitem__(self, obj, val):
    #    return self.set(obj, val)

    def __getstate__(self):
        return ([self.getmass(i) for i in range(self.N())],
                    [a.__getstate__() for a in self])

    def __setstate__(self, lst):
        masses, atomstates = lst
        self.__init__(fvector(masses))
        for i, atomstate in enumerate(atomstates):
    #~ print "i:",i
            a = self.get(i)
            a.__setstate__(atomstate)

AtomVec_swigregister = _sim2d.AtomVec_swigregister
AtomVec_swigregister(AtomVec)

class SubGroup(AtomGroup):
    """Proxy of C++ SubGroup class."""

    __swig_setmethods__ = {}
    for _s in [AtomGroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomGroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SubGroup, name)
    __repr__ = _swig_repr

    def __init__(self, atoms: 'boost::shared_ptr< AtomVec >'):
        """__init__(SubGroup self, boost::shared_ptr< AtomVec > atoms) -> SubGroup"""
        this = _sim2d.new_SubGroup(atoms)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def vec(self) -> "AtomVec &":
        """vec(SubGroup self) -> AtomVec"""
        return _sim2d.SubGroup_vec(self)


    def get(self, n: 'cuint') -> "Atom &":
        """get(SubGroup self, cuint n) -> Atom"""
        return _sim2d.SubGroup_get(self, n)


    def add(self, a: 'AtomID') -> "void":
        """add(SubGroup self, AtomID a)"""
        return _sim2d.SubGroup_add(self, a)


    def get_id(self, n: 'cuint') -> "AtomID":
        """get_id(SubGroup self, cuint n) -> AtomID"""
        return _sim2d.SubGroup_get_id(self, n)


    def size(self) -> "uint":
        """size(SubGroup self) -> uint"""
        return _sim2d.SubGroup_size(self)

    __swig_destroy__ = _sim2d.delete_SubGroup
    __del__ = lambda self: None
SubGroup_swigregister = _sim2d.SubGroup_swigregister
SubGroup_swigregister(SubGroup)

class StateTracker(_object):
    """Proxy of C++ StateTracker class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StateTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StateTracker, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def update(self, box: 'Box') -> "void":
        """update(StateTracker self, Box box)"""
        return _sim2d.StateTracker_update(self, box)

    __swig_destroy__ = _sim2d.delete_StateTracker
    __del__ = lambda self: None
StateTracker_swigregister = _sim2d.StateTracker_swigregister
StateTracker_swigregister(StateTracker)

class PairList(_object):
    """Proxy of C++ PairList class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairList, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(PairList self) -> PairList"""
        this = _sim2d.new_PairList()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def ensure(self, *args) -> "void":
        """
        ensure(PairList self, AtomID a)
        ensure(PairList self, idvector ps)
        ensure(PairList self, AtomGroup group)
        """
        return _sim2d.PairList_ensure(self, *args)


    def has_pair(self, a1: 'AtomID', a2: 'AtomID') -> "bool":
        """has_pair(PairList self, AtomID a1, AtomID a2) -> bool"""
        return _sim2d.PairList_has_pair(self, a1, a2)


    def add_pair(self, a1: 'AtomID', a2: 'AtomID') -> "void":
        """add_pair(PairList self, AtomID a1, AtomID a2)"""
        return _sim2d.PairList_add_pair(self, a1, a2)


    def erase_pair(self, a1: 'AtomID', a2: 'AtomID') -> "void":
        """erase_pair(PairList self, AtomID a1, AtomID a2)"""
        return _sim2d.PairList_erase_pair(self, a1, a2)


    def get_pairs(self, a: 'AtomID') -> "std::set< AtomID >":
        """get_pairs(PairList self, AtomID a) -> std::set< AtomID >"""
        return _sim2d.PairList_get_pairs(self, a)


    def begin(self, a: 'AtomID') -> "std::set< AtomID,std::less< AtomID >,std::allocator< AtomID > >::iterator":
        """begin(PairList self, AtomID a) -> std::set< AtomID,std::less< AtomID >,std::allocator< AtomID > >::iterator"""
        return _sim2d.PairList_begin(self, a)


    def end(self, a: 'AtomID') -> "std::set< AtomID,std::less< AtomID >,std::allocator< AtomID > >::iterator":
        """end(PairList self, AtomID a) -> std::set< AtomID,std::less< AtomID >,std::allocator< AtomID > >::iterator"""
        return _sim2d.PairList_end(self, a)


    def size(self) -> "uint":
        """size(PairList self) -> uint"""
        return _sim2d.PairList_size(self)


    def clear(self) -> "void":
        """clear(PairList self)"""
        return _sim2d.PairList_clear(self)

    __swig_destroy__ = _sim2d.delete_PairList
    __del__ = lambda self: None
PairList_swigregister = _sim2d.PairList_swigregister
PairList_swigregister(PairList)

class NeighborList(StateTracker):
    """Proxy of C++ NeighborList class."""

    __swig_setmethods__ = {}
    for _s in [StateTracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NeighborList, name, value)
    __swig_getmethods__ = {}
    for _s in [StateTracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NeighborList, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', atoms: 'boost::shared_ptr< AtomVec >', skin: 'flt const'):
        """__init__(NeighborList self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atoms, flt const skin) -> NeighborList"""
        this = _sim2d.new_NeighborList(box, atoms, skin)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update(self, newbox: 'Box') -> "void":
        """update(NeighborList self, Box newbox)"""
        return _sim2d.NeighborList_update(self, newbox)


    def update_list(self, force: 'bool'=True) -> "bool":
        """
        update_list(NeighborList self, bool force=True) -> bool
        update_list(NeighborList self) -> bool
        """
        return _sim2d.NeighborList_update_list(self, force)


    def vec(self) -> "AtomVec &":
        """vec(NeighborList self) -> AtomVec"""
        return _sim2d.NeighborList_vec(self)


    def which(self) -> "uint":
        """which(NeighborList self) -> uint"""
        return _sim2d.NeighborList_which(self)


    def numpairs(self) -> "uint":
        """numpairs(NeighborList self) -> uint"""
        return _sim2d.NeighborList_numpairs(self)


    def ignore(self, a: 'AtomID', b: 'AtomID') -> "void":
        """ignore(NeighborList self, AtomID a, AtomID b)"""
        return _sim2d.NeighborList_ignore(self, a, b)


    def add(self, a: 'AtomID', diameter: 'flt') -> "void":
        """add(NeighborList self, AtomID a, flt diameter)"""
        return _sim2d.NeighborList_add(self, a, diameter)


    def ignore_size(self) -> "uint":
        """ignore_size(NeighborList self) -> uint"""
        return _sim2d.NeighborList_ignore_size(self)


    def size(self) -> "uint":
        """size(NeighborList self) -> uint"""
        return _sim2d.NeighborList_size(self)


    def begin(self) -> "std::vector< IDPair,std::allocator< IDPair > >::iterator":
        """begin(NeighborList self) -> std::vector< IDPair,std::allocator< IDPair > >::iterator"""
        return _sim2d.NeighborList_begin(self)


    def end(self) -> "std::vector< IDPair,std::allocator< IDPair > >::iterator":
        """end(NeighborList self) -> std::vector< IDPair,std::allocator< IDPair > >::iterator"""
        return _sim2d.NeighborList_end(self)


    def get(self, i: 'uint') -> "IDPair":
        """get(NeighborList self, uint i) -> IDPair"""
        return _sim2d.NeighborList_get(self, i)

    __swig_destroy__ = _sim2d.delete_NeighborList
    __del__ = lambda self: None

    def __getitem__(self, i: 'size_t') -> "IDPair":
        """__getitem__(NeighborList self, size_t i) -> IDPair"""
        return _sim2d.NeighborList___getitem__(self, i)


    def __iter__(self):
        for i in range(self.numpairs()):
            yield self[i]

NeighborList_swigregister = _sim2d.NeighborList_swigregister
NeighborList_swigregister(NeighborList)

class Grid(_object):
    """Proxy of C++ Grid class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Grid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Grid, name)
    __repr__ = _swig_repr
    __swig_setmethods__["box"] = _sim2d.Grid_box_set
    __swig_getmethods__["box"] = _sim2d.Grid_box_get
    if _newclass:
        box = _swig_property(_sim2d.Grid_box_get, _sim2d.Grid_box_set)
    __swig_setmethods__["atoms"] = _sim2d.Grid_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.Grid_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.Grid_atoms_get, _sim2d.Grid_atoms_set)
    __swig_setmethods__["minwidth"] = _sim2d.Grid_minwidth_set
    __swig_getmethods__["minwidth"] = _sim2d.Grid_minwidth_get
    if _newclass:
        minwidth = _swig_property(_sim2d.Grid_minwidth_get, _sim2d.Grid_minwidth_set)
    __swig_setmethods__["goalwidth"] = _sim2d.Grid_goalwidth_set
    __swig_getmethods__["goalwidth"] = _sim2d.Grid_goalwidth_get
    if _newclass:
        goalwidth = _swig_property(_sim2d.Grid_goalwidth_get, _sim2d.Grid_goalwidth_set)
    __swig_setmethods__["widths"] = _sim2d.Grid_widths_set
    __swig_getmethods__["widths"] = _sim2d.Grid_widths_get
    if _newclass:
        widths = _swig_property(_sim2d.Grid_widths_get, _sim2d.Grid_widths_set)
    __swig_setmethods__["gridlocs"] = _sim2d.Grid_gridlocs_set
    __swig_getmethods__["gridlocs"] = _sim2d.Grid_gridlocs_get
    if _newclass:
        gridlocs = _swig_property(_sim2d.Grid_gridlocs_get, _sim2d.Grid_gridlocs_set)

    def neighbors(self, i: 'uint') -> "std::vector< uint >":
        """neighbors(Grid self, uint i) -> uintvector"""
        return _sim2d.Grid_neighbors(self, i)


    def get_loc(self, v: 'Vec', bsize: 'Vec') -> "uint":
        """get_loc(Grid self, Vec v, Vec bsize) -> uint"""
        return _sim2d.Grid_get_loc(self, v, bsize)


    def __init__(self, *args):
        """
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, uint const width=1) -> Grid
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms) -> Grid
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, uintvector width) -> Grid
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const minwidth, flt const goalwidth) -> Grid
        """
        this = _sim2d.new_Grid(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def optimize_widths(self) -> "void":
        """optimize_widths(Grid self)"""
        return _sim2d.Grid_optimize_widths(self)


    def make_grid(self) -> "void":
        """make_grid(Grid self)"""
        return _sim2d.Grid_make_grid(self)


    def begin(self) -> "Grid::iterator":
        """begin(Grid self) -> GridIterator"""
        return _sim2d.Grid_begin(self)


    def end(self) -> "Grid::iterator":
        """end(Grid self) -> GridIterator"""
        return _sim2d.Grid_end(self)


    def pairs(self, a: 'AtomID') -> "Grid::pair_iter":
        """pairs(Grid self, AtomID a) -> GridPairedIterator"""
        return _sim2d.Grid_pairs(self, a)


    def time_to_edge(self, *args) -> "flt":
        """
        time_to_edge(Grid self, Atom a) -> flt
        time_to_edge(Grid self, uint i) -> flt
        """
        return _sim2d.Grid_time_to_edge(self, *args)


    def all_pairs(self, *args) -> "std::vector< AtomID >":
        """
        all_pairs(Grid self) -> idpairvector
        all_pairs(Grid self, AtomID a) -> idvector
        """
        return _sim2d.Grid_all_pairs(self, *args)


    def numcells(self, *args) -> "uint":
        """
        numcells(Grid self, uint i) -> uint
        numcells(Grid self) -> uint
        """
        return _sim2d.Grid_numcells(self, *args)

    __swig_destroy__ = _sim2d.delete_Grid
    __del__ = lambda self: None
Grid_swigregister = _sim2d.Grid_swigregister
Grid_swigregister(Grid)

class GridPairedIterator(_object):
    """Proxy of C++ GridPairedIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridPairedIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GridPairedIterator, name)
    __repr__ = _swig_repr

    def __init__(self, grid: 'Grid', a: 'AtomID'):
        """__init__(GridPairedIterator self, Grid grid, AtomID a) -> GridPairedIterator"""
        this = _sim2d.new_GridPairedIterator(grid, a)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __ref__(self) -> "AtomID":
        """__ref__(GridPairedIterator self) -> AtomID"""
        return _sim2d.GridPairedIterator___ref__(self)


    def __eq__(self, *args) -> "bool":
        """
        __eq__(GridPairedIterator self, GridPairedIterator other) -> bool
        __eq__(GridPairedIterator self, GridPairedIterator::end_type const other) -> bool
        """
        return _sim2d.GridPairedIterator___eq__(self, *args)


    def __ne__(self, *args) -> "bool":
        """
        __ne__(GridPairedIterator self, GridPairedIterator other) -> bool
        __ne__(GridPairedIterator self, GridPairedIterator::end_type const other) -> bool
        """
        return _sim2d.GridPairedIterator___ne__(self, *args)


    def end(self) -> "GridPairedIterator::end_type":
        """end(GridPairedIterator self) -> GridPairedIterator::end_type"""
        return _sim2d.GridPairedIterator_end(self)

    __swig_destroy__ = _sim2d.delete_GridPairedIterator
    __del__ = lambda self: None
GridPairedIterator_swigregister = _sim2d.GridPairedIterator_swigregister
GridPairedIterator_swigregister(GridPairedIterator)

class GridIterator(_object):
    """Proxy of C++ GridIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GridIterator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GridIterator self, Grid grid) -> GridIterator
        __init__(GridIterator self, Grid grid, std::vector< std::set< AtomID,std::less< AtomID >,std::allocator< AtomID > >,std::allocator< std::set< AtomID,std::less< AtomID >,std::allocator< AtomID > > > >::iterator cell1) -> GridIterator
        """
        this = _sim2d.new_GridIterator(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __ref__(self) -> "IDPair":
        """__ref__(GridIterator self) -> IDPair"""
        return _sim2d.GridIterator___ref__(self)


    def __eq__(self, other: 'GridIterator') -> "bool":
        """__eq__(GridIterator self, GridIterator other) -> bool"""
        return _sim2d.GridIterator___eq__(self, other)


    def __ne__(self, other: 'GridIterator') -> "bool":
        """__ne__(GridIterator self, GridIterator other) -> bool"""
        return _sim2d.GridIterator___ne__(self, other)

    __swig_destroy__ = _sim2d.delete_GridIterator
    __del__ = lambda self: None
GridIterator_swigregister = _sim2d.GridIterator_swigregister
GridIterator_swigregister(GridIterator)

class Interaction(_object):
    """Proxy of C++ Interaction class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interaction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interaction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def energy(self, box: 'Box') -> "flt":
        """energy(Interaction self, Box box) -> flt"""
        return _sim2d.Interaction_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(Interaction self, Box box)"""
        return _sim2d.Interaction_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(Interaction self, Box box) -> flt"""
        return _sim2d.Interaction_set_forces_get_pressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(Interaction self, Box box) -> flt"""
        return _sim2d.Interaction_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(Interaction self, Box box) -> Matrix"""
        return _sim2d.Interaction_stress(self, box)

    __swig_destroy__ = _sim2d.delete_Interaction
    __del__ = lambda self: None
Interaction_swigregister = _sim2d.Interaction_swigregister
Interaction_swigregister(Interaction)

class InteractPair(_object):
    """Proxy of C++ InteractPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InteractPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InteractPair, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def energy(self, diff: 'Vec const') -> "flt":
        """energy(InteractPair self, Vec const diff) -> flt"""
        return _sim2d.InteractPair_energy(self, diff)


    def forces(self, diff: 'Vec const') -> "Vec":
        """forces(InteractPair self, Vec const diff) -> Vec"""
        return _sim2d.InteractPair_forces(self, diff)

    __swig_destroy__ = _sim2d.delete_InteractPair
    __del__ = lambda self: None
InteractPair_swigregister = _sim2d.InteractPair_swigregister
InteractPair_swigregister(InteractPair)

class LJRepulsive(_object):
    """Proxy of C++ LJRepulsive class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJRepulsive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJRepulsive, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const'):
        """__init__(LJRepulsive self, flt const epsilon, flt const sigma) -> LJRepulsive"""
        this = _sim2d.new_LJRepulsive(epsilon, sigma)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, *args) -> "flt":
        """
        energy(LJRepulsive self, Vec const diff, flt const eps, flt const sig) -> flt
        energy(LJRepulsive self, Vec const & diff) -> flt
        """
        return _sim2d.LJRepulsive_energy(self, *args)


    def forces(self, *args) -> "Vec":
        """
        forces(LJRepulsive self, Vec const diff, flt const eps, flt const sig) -> Vec
        forces(LJRepulsive self, Vec const & diff) -> Vec
        """
        return _sim2d.LJRepulsive_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJRepulsive
    __del__ = lambda self: None
LJRepulsive_swigregister = _sim2d.LJRepulsive_swigregister
LJRepulsive_swigregister(LJRepulsive)
LJr0 = cvar.LJr0
LJr0sq = cvar.LJr0sq

class LJAttract(_object):
    """Proxy of C++ LJAttract class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttract, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttract, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const'):
        """__init__(LJAttract self, flt const epsilon, flt const sigma) -> LJAttract"""
        this = _sim2d.new_LJAttract(epsilon, sigma)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, *args) -> "flt":
        """
        energy(LJAttract self, Vec const diff, flt const eps, flt const sig) -> flt
        energy(LJAttract self, flt const rsig) -> flt
        energy(LJAttract self, Vec const & diff) -> flt
        """
        return _sim2d.LJAttract_energy(self, *args)


    def forces(self, *args) -> "Vec":
        """
        forces(LJAttract self, Vec const diff, flt const eps, flt const sig) -> Vec
        forces(LJAttract self, flt const rsig) -> flt
        forces(LJAttract self, Vec const & diff) -> Vec
        """
        return _sim2d.LJAttract_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAttract
    __del__ = lambda self: None
LJAttract_swigregister = _sim2d.LJAttract_swigregister
LJAttract_swigregister(LJAttract)

class LJAttractCut(_object):
    """Proxy of C++ LJAttractCut class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractCut, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const', cutsig: 'flt const'):
        """__init__(LJAttractCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJAttractCut"""
        this = _sim2d.new_LJAttractCut(epsilon, sigma, cutsig)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, *args) -> "flt":
        """
        energy(LJAttractCut self, Vec const diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJAttractCut self, Vec const & diff) -> flt
        """
        return _sim2d.LJAttractCut_energy(self, *args)


    def forces(self, *args) -> "Vec":
        """
        forces(LJAttractCut self, Vec const diff, flt const eps, flt const sig, flt const cutsig) -> Vec
        forces(LJAttractCut self, Vec const & diff) -> Vec
        """
        return _sim2d.LJAttractCut_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAttractCut
    __del__ = lambda self: None
LJAttractCut_swigregister = _sim2d.LJAttractCut_swigregister
LJAttractCut_swigregister(LJAttractCut)

class LennardJonesCut(_object):
    """Proxy of C++ LennardJonesCut class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LennardJonesCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LennardJonesCut, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const', cutsig: 'flt const'):
        """__init__(LennardJonesCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LennardJonesCut"""
        this = _sim2d.new_LennardJonesCut(epsilon, sigma, cutsig)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, diff: 'Vec const &') -> "flt":
        """energy(LennardJonesCut self, Vec const & diff) -> flt"""
        return _sim2d.LennardJonesCut_energy(self, diff)


    def forces(self, *args) -> "Vec":
        """
        forces(LennardJonesCut self, Vec const diff, flt const eps, flt const sig, flt const cutsig) -> Vec
        forces(LennardJonesCut self, flt const rsig, flt const cutsig) -> flt
        forces(LennardJonesCut self, Vec const & diff) -> Vec
        """
        return _sim2d.LennardJonesCut_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LennardJonesCut
    __del__ = lambda self: None
LennardJonesCut_swigregister = _sim2d.LennardJonesCut_swigregister
LennardJonesCut_swigregister(LennardJonesCut)

class Spring(InteractPair):
    """Proxy of C++ Spring class."""

    __swig_setmethods__ = {}
    for _s in [InteractPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spring, name, value)
    __swig_getmethods__ = {}
    for _s in [InteractPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Spring, name)
    __repr__ = _swig_repr

    def __init__(self, k: 'flt const', x0: 'flt const'):
        """__init__(Spring self, flt const k, flt const x0) -> Spring"""
        this = _sim2d.new_Spring(k, x0)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, diff: 'Vec const') -> "flt":
        """energy(Spring self, Vec const diff) -> flt"""
        return _sim2d.Spring_energy(self, diff)


    def forces(self, diff: 'Vec const') -> "Vec":
        """forces(Spring self, Vec const diff) -> Vec"""
        return _sim2d.Spring_forces(self, diff)

    __swig_destroy__ = _sim2d.delete_Spring
    __del__ = lambda self: None
Spring_swigregister = _sim2d.Spring_swigregister
Spring_swigregister(Spring)

class BondAngle(_object):
    """Proxy of C++ BondAngle class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BondAngle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BondAngle, name)
    __repr__ = _swig_repr

    def __init__(self, k: 'flt const', theta: 'flt const', cosine: 'bool const'=False):
        """
        __init__(BondAngle self, flt const k, flt const theta, bool const cosine=False) -> BondAngle
        __init__(BondAngle self, flt const k, flt const theta) -> BondAngle
        """
        this = _sim2d.new_BondAngle(k, theta, cosine)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_angle(r1: 'Vec const &', r2: 'Vec const &') -> "flt":
        """get_angle(Vec const & r1, Vec const & r2) -> flt"""
        return _sim2d.BondAngle_get_angle(r1, r2)

    if _newclass:
        get_angle = staticmethod(get_angle)
    __swig_getmethods__["get_angle"] = lambda x: get_angle

    def energy(self, diff1: 'Vec const &', diff2: 'Vec const &') -> "flt":
        """energy(BondAngle self, Vec const & diff1, Vec const & diff2) -> flt"""
        return _sim2d.BondAngle_energy(self, diff1, diff2)


    def forces(self, diff1: 'Vec const &', diff2: 'Vec const &') -> "boost::array< Vec,3 >":
        """forces(BondAngle self, Vec const & diff1, Vec const & diff2) -> boost::array< Vec,3 >"""
        return _sim2d.BondAngle_forces(self, diff1, diff2)

    __swig_destroy__ = _sim2d.delete_BondAngle
    __del__ = lambda self: None
BondAngle_swigregister = _sim2d.BondAngle_swigregister
BondAngle_swigregister(BondAngle)

def BondAngle_get_angle(r1: 'Vec const &', r2: 'Vec const &') -> "flt":
    """BondAngle_get_angle(Vec const & r1, Vec const & r2) -> flt"""
    return _sim2d.BondAngle_get_angle(r1, r2)

class ElectricScreened(InteractPair):
    """Proxy of C++ ElectricScreened class."""

    __swig_setmethods__ = {}
    for _s in [InteractPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElectricScreened, name, value)
    __swig_getmethods__ = {}
    for _s in [InteractPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElectricScreened, name)
    __repr__ = _swig_repr

    def __init__(self, screenLength: 'flt const', q1: 'flt const', q2: 'flt const', cutoff: 'flt const'):
        """__init__(ElectricScreened self, flt const screenLength, flt const q1, flt const q2, flt const cutoff) -> ElectricScreened"""
        this = _sim2d.new_ElectricScreened(screenLength, q1, q2, cutoff)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(*args) -> "flt":
        """
        energy(Vec const r) -> flt
        energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
        energy(flt const r, flt const qaqb, flt const screen) -> flt
        """
        return _sim2d.ElectricScreened_energy(*args)

    if _newclass:
        energy = staticmethod(energy)
    __swig_getmethods__["energy"] = lambda x: energy

    def forces(*args) -> "Vec":
        """
        forces(Vec const r) -> Vec
        forces(Vec const r, flt const qaqb, flt const screen, flt const cutoff=0) -> Vec
        forces(Vec const r, flt const qaqb, flt const screen) -> Vec
        """
        return _sim2d.ElectricScreened_forces(*args)

    if _newclass:
        forces = staticmethod(forces)
    __swig_getmethods__["forces"] = lambda x: forces
    __swig_destroy__ = _sim2d.delete_ElectricScreened
    __del__ = lambda self: None
ElectricScreened_swigregister = _sim2d.ElectricScreened_swigregister
ElectricScreened_swigregister(ElectricScreened)

def ElectricScreened_energy(*args) -> "flt":
    """
    energy(Vec const r) -> flt
    energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
    ElectricScreened_energy(flt const r, flt const qaqb, flt const screen) -> flt
    """
    return _sim2d.ElectricScreened_energy(*args)

def ElectricScreened_forces(*args) -> "Vec":
    """
    forces(Vec const r) -> Vec
    forces(Vec const r, flt const qaqb, flt const screen, flt const cutoff=0) -> Vec
    ElectricScreened_forces(Vec const r, flt const qaqb, flt const screen) -> Vec
    """
    return _sim2d.ElectricScreened_forces(*args)

class FixedForceAtom(_object):
    """Proxy of C++ FixedForceAtom class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedForceAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FixedForceAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["F"] = _sim2d.FixedForceAtom_F_set
    __swig_getmethods__["F"] = _sim2d.FixedForceAtom_F_get
    if _newclass:
        F = _swig_property(_sim2d.FixedForceAtom_F_get, _sim2d.FixedForceAtom_F_set)
    __swig_setmethods__["a"] = _sim2d.FixedForceAtom_a_set
    __swig_getmethods__["a"] = _sim2d.FixedForceAtom_a_get
    if _newclass:
        a = _swig_property(_sim2d.FixedForceAtom_a_get, _sim2d.FixedForceAtom_a_set)

    def __init__(self, F: 'Vec', a: 'AtomID'):
        """__init__(FixedForceAtom self, Vec F, AtomID a) -> FixedForceAtom"""
        this = _sim2d.new_FixedForceAtom(F, a)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(FixedForceAtom self, Box box) -> flt"""
        return _sim2d.FixedForceAtom_energy(self, box)


    def set_force(self, box: 'Box') -> "void":
        """set_force(FixedForceAtom self, Box box)"""
        return _sim2d.FixedForceAtom_set_force(self, box)

    __swig_destroy__ = _sim2d.delete_FixedForceAtom
    __del__ = lambda self: None
FixedForceAtom_swigregister = _sim2d.FixedForceAtom_swigregister
FixedForceAtom_swigregister(FixedForceAtom)

class FixedForce(Interaction):
    """Proxy of C++ FixedForce class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedForce, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FixedForce self, std::vector< FixedForceAtom > atoms) -> FixedForce
        __init__(FixedForce self) -> FixedForce
        """
        this = _sim2d.new_FixedForce(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(FixedForce self, FixedForceAtom a)
        add(FixedForce self, Vec F, AtomID a)
        add(FixedForce self, flt x, flt y, AtomID a)
        """
        return _sim2d.FixedForce_add(self, *args)


    def size(self) -> "uint":
        """size(FixedForce self) -> uint"""
        return _sim2d.FixedForce_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(FixedForce self, Box box) -> flt"""
        return _sim2d.FixedForce_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(FixedForce self, Box box)"""
        return _sim2d.FixedForce_set_forces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(FixedForce self, Box box) -> flt"""
        return _sim2d.FixedForce_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_FixedForce
    __del__ = lambda self: None
FixedForce_swigregister = _sim2d.FixedForce_swigregister
FixedForce_swigregister(FixedForce)

class FixedForceRegionAtom(AtomID):
    """Proxy of C++ FixedForceRegionAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedForceRegionAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedForceRegionAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["direction"] = _sim2d.FixedForceRegionAtom_direction_set
    __swig_getmethods__["direction"] = _sim2d.FixedForceRegionAtom_direction_get
    if _newclass:
        direction = _swig_property(_sim2d.FixedForceRegionAtom_direction_get, _sim2d.FixedForceRegionAtom_direction_set)
    __swig_setmethods__["boundaries"] = _sim2d.FixedForceRegionAtom_boundaries_set
    __swig_getmethods__["boundaries"] = _sim2d.FixedForceRegionAtom_boundaries_get
    if _newclass:
        boundaries = _swig_property(_sim2d.FixedForceRegionAtom_boundaries_get, _sim2d.FixedForceRegionAtom_boundaries_set)
    __swig_setmethods__["Fs"] = _sim2d.FixedForceRegionAtom_Fs_set
    __swig_getmethods__["Fs"] = _sim2d.FixedForceRegionAtom_Fs_get
    if _newclass:
        Fs = _swig_property(_sim2d.FixedForceRegionAtom_Fs_get, _sim2d.FixedForceRegionAtom_Fs_set)

    def __init__(self, a: 'AtomID', direction: 'Vec', boundaries: 'dvector', Fs: 'dvector'):
        """__init__(FixedForceRegionAtom self, AtomID a, Vec direction, dvector boundaries, dvector Fs) -> FixedForceRegionAtom"""
        this = _sim2d.new_FixedForceRegionAtom(a, direction, boundaries, Fs)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(FixedForceRegionAtom self, Box box) -> flt"""
        return _sim2d.FixedForceRegionAtom_energy(self, box)


    def set_force(self, box: 'Box') -> "void":
        """set_force(FixedForceRegionAtom self, Box box)"""
        return _sim2d.FixedForceRegionAtom_set_force(self, box)

    __swig_destroy__ = _sim2d.delete_FixedForceRegionAtom
    __del__ = lambda self: None
FixedForceRegionAtom_swigregister = _sim2d.FixedForceRegionAtom_swigregister
FixedForceRegionAtom_swigregister(FixedForceRegionAtom)

class FixedForceRegion(Interaction):
    """Proxy of C++ FixedForceRegion class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedForceRegion, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedForceRegion, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FixedForceRegion self, std::vector< FixedForceRegionAtom > atoms) -> FixedForceRegion
        __init__(FixedForceRegion self) -> FixedForceRegion
        """
        this = _sim2d.new_FixedForceRegion(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(FixedForceRegion self, FixedForceRegionAtom a)
        add(FixedForceRegion self, AtomID a, Vec dir, dvector bound, dvector F)
        """
        return _sim2d.FixedForceRegion_add(self, *args)


    def size(self) -> "uint":
        """size(FixedForceRegion self) -> uint"""
        return _sim2d.FixedForceRegion_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(FixedForceRegion self, Box box) -> flt"""
        return _sim2d.FixedForceRegion_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(FixedForceRegion self, Box box)"""
        return _sim2d.FixedForceRegion_set_forces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(FixedForceRegion self, Box box) -> flt"""
        return _sim2d.FixedForceRegion_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_FixedForceRegion
    __del__ = lambda self: None
FixedForceRegion_swigregister = _sim2d.FixedForceRegion_swigregister
FixedForceRegion_swigregister(FixedForceRegion)

class FixedSpringAtom(_object):
    """Proxy of C++ FixedSpringAtom class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedSpringAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FixedSpringAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["loc"] = _sim2d.FixedSpringAtom_loc_set
    __swig_getmethods__["loc"] = _sim2d.FixedSpringAtom_loc_get
    if _newclass:
        loc = _swig_property(_sim2d.FixedSpringAtom_loc_get, _sim2d.FixedSpringAtom_loc_set)
    __swig_setmethods__["k"] = _sim2d.FixedSpringAtom_k_set
    __swig_getmethods__["k"] = _sim2d.FixedSpringAtom_k_get
    if _newclass:
        k = _swig_property(_sim2d.FixedSpringAtom_k_get, _sim2d.FixedSpringAtom_k_set)
    __swig_setmethods__["usecoord"] = _sim2d.FixedSpringAtom_usecoord_set
    __swig_getmethods__["usecoord"] = _sim2d.FixedSpringAtom_usecoord_get
    if _newclass:
        usecoord = _swig_property(_sim2d.FixedSpringAtom_usecoord_get, _sim2d.FixedSpringAtom_usecoord_set)
    __swig_setmethods__["a"] = _sim2d.FixedSpringAtom_a_set
    __swig_getmethods__["a"] = _sim2d.FixedSpringAtom_a_get
    if _newclass:
        a = _swig_property(_sim2d.FixedSpringAtom_a_get, _sim2d.FixedSpringAtom_a_set)

    def __init__(self, a: 'AtomID', loc: 'Vec', k: 'flt', usex: 'bool'=True, usey: 'bool'=True, usez: 'bool'=True):
        """
        __init__(FixedSpringAtom self, AtomID a, Vec loc, flt k, bool usex=True, bool usey=True, bool usez=True) -> FixedSpringAtom
        __init__(FixedSpringAtom self, AtomID a, Vec loc, flt k, bool usex=True, bool usey=True) -> FixedSpringAtom
        __init__(FixedSpringAtom self, AtomID a, Vec loc, flt k, bool usex=True) -> FixedSpringAtom
        __init__(FixedSpringAtom self, AtomID a, Vec loc, flt k) -> FixedSpringAtom
        """
        this = _sim2d.new_FixedSpringAtom(a, loc, k, usex, usey, usez)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(FixedSpringAtom self, Box box) -> flt"""
        return _sim2d.FixedSpringAtom_energy(self, box)


    def set_force(self, box: 'Box') -> "void":
        """set_force(FixedSpringAtom self, Box box)"""
        return _sim2d.FixedSpringAtom_set_force(self, box)

    __swig_destroy__ = _sim2d.delete_FixedSpringAtom
    __del__ = lambda self: None
FixedSpringAtom_swigregister = _sim2d.FixedSpringAtom_swigregister
FixedSpringAtom_swigregister(FixedSpringAtom)

class FixedSpring(Interaction):
    """Proxy of C++ FixedSpring class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedSpring, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FixedSpring self, std::vector< FixedSpringAtom > atoms) -> FixedSpring
        __init__(FixedSpring self) -> FixedSpring
        """
        this = _sim2d.new_FixedSpring(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(FixedSpring self, FixedSpringAtom a)
        add(FixedSpring self, AtomID a, Vec loc, flt k, bool usex=True, bool usey=True, bool usez=True)
        add(FixedSpring self, AtomID a, Vec loc, flt k, bool usex=True, bool usey=True)
        add(FixedSpring self, AtomID a, Vec loc, flt k, bool usex=True)
        add(FixedSpring self, AtomID a, Vec loc, flt k)
        """
        return _sim2d.FixedSpring_add(self, *args)


    def size(self) -> "uint":
        """size(FixedSpring self) -> uint"""
        return _sim2d.FixedSpring_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(FixedSpring self, Box box) -> flt"""
        return _sim2d.FixedSpring_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(FixedSpring self, Box box)"""
        return _sim2d.FixedSpring_set_forces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(FixedSpring self, Box box) -> flt"""
        return _sim2d.FixedSpring_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_FixedSpring
    __del__ = lambda self: None
FixedSpring_swigregister = _sim2d.FixedSpring_swigregister
FixedSpring_swigregister(FixedSpring)

class COMSpring(Interaction):
    """Proxy of C++ COMSpring class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, COMSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, COMSpring, name)
    __repr__ = _swig_repr

    def __init__(self, g1: 'AtomGroup', g2: 'AtomGroup', k: 'flt', x0: 'flt'=0):
        """
        __init__(COMSpring self, AtomGroup g1, AtomGroup g2, flt k, flt x0=0) -> COMSpring
        __init__(COMSpring self, AtomGroup g1, AtomGroup g2, flt k) -> COMSpring
        """
        this = _sim2d.new_COMSpring(g1, g2, k, x0)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(COMSpring self, Box box) -> flt"""
        return _sim2d.COMSpring_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(COMSpring self, Box box)"""
        return _sim2d.COMSpring_set_forces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(COMSpring self, Box box) -> flt"""
        return _sim2d.COMSpring_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_COMSpring
    __del__ = lambda self: None
COMSpring_swigregister = _sim2d.COMSpring_swigregister
COMSpring_swigregister(COMSpring)


_sim2d.FIXED_swigconstant(_sim2d)
FIXED = _sim2d.FIXED

_sim2d.UNIFORM_swigconstant(_sim2d)
UNIFORM = _sim2d.UNIFORM

_sim2d.GAUSSIAN_swigconstant(_sim2d)
GAUSSIAN = _sim2d.GAUSSIAN
class RandomForceAtom(AtomRef):
    """Proxy of C++ RandomForceAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomRef]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RandomForceAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomRef]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RandomForceAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["force_mag"] = _sim2d.RandomForceAtom_force_mag_set
    __swig_getmethods__["force_mag"] = _sim2d.RandomForceAtom_force_mag_get
    if _newclass:
        force_mag = _swig_property(_sim2d.RandomForceAtom_force_mag_get, _sim2d.RandomForceAtom_force_mag_set)
    __swig_setmethods__["freq"] = _sim2d.RandomForceAtom_freq_set
    __swig_getmethods__["freq"] = _sim2d.RandomForceAtom_freq_get
    if _newclass:
        freq = _swig_property(_sim2d.RandomForceAtom_freq_get, _sim2d.RandomForceAtom_freq_set)
    __swig_setmethods__["force_type"] = _sim2d.RandomForceAtom_force_type_set
    __swig_getmethods__["force_type"] = _sim2d.RandomForceAtom_force_type_get
    if _newclass:
        force_type = _swig_property(_sim2d.RandomForceAtom_force_type_get, _sim2d.RandomForceAtom_force_type_set)

    def __init__(self, a: 'AtomID', force_mag: 'flt', freq: 'flt', force_type: 'RandomForceType'=UNIFORM):
        """
        __init__(RandomForceAtom self, AtomID a, flt force_mag, flt freq, RandomForceType force_type=UNIFORM) -> RandomForceAtom
        __init__(RandomForceAtom self, AtomID a, flt force_mag, flt freq) -> RandomForceAtom
        """
        this = _sim2d.new_RandomForceAtom(a, force_mag, freq, force_type)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_RandomForceAtom
    __del__ = lambda self: None
RandomForceAtom_swigregister = _sim2d.RandomForceAtom_swigregister
RandomForceAtom_swigregister(RandomForceAtom)

class RandomForce(Interaction):
    """Proxy of C++ RandomForce class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RandomForce, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RandomForce, name)
    __repr__ = _swig_repr
    __swig_setmethods__["group"] = _sim2d.RandomForce_group_set
    __swig_getmethods__["group"] = _sim2d.RandomForce_group_get
    if _newclass:
        group = _swig_property(_sim2d.RandomForce_group_get, _sim2d.RandomForce_group_set)

    def __init__(self, *args):
        """
        __init__(RandomForce self) -> RandomForce
        __init__(RandomForce self, AtomGroup agroup, flt force_mag, flt freq, RandomForceType force_type=UNIFORM) -> RandomForce
        __init__(RandomForce self, AtomGroup agroup, flt force_mag, flt freq) -> RandomForce
        """
        this = _sim2d.new_RandomForce(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def size(self) -> "uint":
        """size(RandomForce self) -> uint"""
        return _sim2d.RandomForce_size(self)


    def get(self, i: 'uint') -> "RandomForceAtom":
        """get(RandomForce self, uint i) -> RandomForceAtom"""
        return _sim2d.RandomForce_get(self, i)


    def add(self, a: 'RandomForceAtom', replace: 'bool'=True) -> "bool":
        """
        add(RandomForce self, RandomForceAtom a, bool replace=True) -> bool
        add(RandomForce self, RandomForceAtom a) -> bool
        """
        return _sim2d.RandomForce_add(self, a, replace)


    def energy(self, box: 'Box') -> "flt":
        """energy(RandomForce self, Box box) -> flt"""
        return _sim2d.RandomForce_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(RandomForce self, Box box)"""
        return _sim2d.RandomForce_set_forces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(RandomForce self, Box box) -> flt"""
        return _sim2d.RandomForce_pressure(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(RandomForce self, Box box) -> flt"""
        return _sim2d.RandomForce_set_forces_get_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_RandomForce
    __del__ = lambda self: None
RandomForce_swigregister = _sim2d.RandomForce_swigregister
RandomForce_swigregister(RandomForce)


_sim2d.BOXED_swigconstant(_sim2d)
BOXED = _sim2d.BOXED

_sim2d.UNBOXED_swigconstant(_sim2d)
UNBOXED = _sim2d.UNBOXED

_sim2d.FIXEDBOX_swigconstant(_sim2d)
FIXEDBOX = _sim2d.FIXEDBOX
class BondGrouping(_object):
    """Proxy of C++ BondGrouping class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BondGrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BondGrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2d.BondGrouping_k_set
    __swig_getmethods__["k"] = _sim2d.BondGrouping_k_get
    if _newclass:
        k = _swig_property(_sim2d.BondGrouping_k_get, _sim2d.BondGrouping_k_set)
    __swig_setmethods__["x0"] = _sim2d.BondGrouping_x0_set
    __swig_getmethods__["x0"] = _sim2d.BondGrouping_x0_get
    if _newclass:
        x0 = _swig_property(_sim2d.BondGrouping_x0_get, _sim2d.BondGrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2d.BondGrouping_a1_set
    __swig_getmethods__["a1"] = _sim2d.BondGrouping_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.BondGrouping_a1_get, _sim2d.BondGrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2d.BondGrouping_a2_set
    __swig_getmethods__["a2"] = _sim2d.BondGrouping_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.BondGrouping_a2_get, _sim2d.BondGrouping_a2_set)
    __swig_setmethods__["diff_type"] = _sim2d.BondGrouping_diff_type_set
    __swig_getmethods__["diff_type"] = _sim2d.BondGrouping_diff_type_get
    if _newclass:
        diff_type = _swig_property(_sim2d.BondGrouping_diff_type_get, _sim2d.BondGrouping_diff_type_set)
    __swig_setmethods__["fixed_box"] = _sim2d.BondGrouping_fixed_box_set
    __swig_getmethods__["fixed_box"] = _sim2d.BondGrouping_fixed_box_get
    if _newclass:
        fixed_box = _swig_property(_sim2d.BondGrouping_fixed_box_get, _sim2d.BondGrouping_fixed_box_set)

    def __init__(self, k: 'flt', x0: 'flt', a1: 'AtomID', a2: 'AtomID', diff: 'BondDiffType'=UNBOXED, box: 'OriginBox'=None):
        """
        __init__(BondGrouping self, flt k, flt x0, AtomID a1, AtomID a2, BondDiffType diff=UNBOXED, OriginBox box=None) -> BondGrouping
        __init__(BondGrouping self, flt k, flt x0, AtomID a1, AtomID a2, BondDiffType diff=UNBOXED) -> BondGrouping
        __init__(BondGrouping self, flt k, flt x0, AtomID a1, AtomID a2) -> BondGrouping
        """
        this = _sim2d.new_BondGrouping(k, x0, a1, a2, diff, box)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def diff(self, box: 'Box') -> "Vec":
        """diff(BondGrouping self, Box box) -> Vec"""
        return _sim2d.BondGrouping_diff(self, box)


    def get_fixed(self, i: 'uint') -> "int":
        """get_fixed(BondGrouping self, uint i) -> int"""
        return _sim2d.BondGrouping_get_fixed(self, i)


    def same_atoms(self, other: 'BondGrouping') -> "bool":
        """same_atoms(BondGrouping self, BondGrouping other) -> bool"""
        return _sim2d.BondGrouping_same_atoms(self, other)

    __swig_destroy__ = _sim2d.delete_BondGrouping
    __del__ = lambda self: None
BondGrouping_swigregister = _sim2d.BondGrouping_swigregister
BondGrouping_swigregister(BondGrouping)

class BondPairs(Interaction):
    """Proxy of C++ BondPairs class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BondPairs, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BondPairs, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BondPairs self, std::vector< BondGrouping > pairs, bool zeropressure=True) -> BondPairs
        __init__(BondPairs self, std::vector< BondGrouping > pairs) -> BondPairs
        __init__(BondPairs self, bool zeropressure=True) -> BondPairs
        __init__(BondPairs self) -> BondPairs
        """
        this = _sim2d.new_BondPairs(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add_forced(self, b: 'BondGrouping') -> "void":
        """add_forced(BondPairs self, BondGrouping b)"""
        return _sim2d.BondPairs_add_forced(self, b)


    def add(self, *args) -> "bool":
        """
        add(BondPairs self, BondGrouping b, bool replace=True) -> bool
        add(BondPairs self, BondGrouping b) -> bool
        add(BondPairs self, flt k, flt x0, AtomID a1, AtomID a2, bool replace=True) -> bool
        add(BondPairs self, flt k, flt x0, AtomID a1, AtomID a2) -> bool
        add(BondPairs self, flt k, AtomID a1, AtomID a2, bool replace=True) -> bool
        add(BondPairs self, flt k, AtomID a1, AtomID a2) -> bool
        """
        return _sim2d.BondPairs_add(self, *args)


    def size(self) -> "uint":
        """size(BondPairs self) -> uint"""
        return _sim2d.BondPairs_size(self)


    def get(self, i: 'uint') -> "BondGrouping":
        """get(BondPairs self, uint i) -> BondGrouping"""
        return _sim2d.BondPairs_get(self, i)


    def mean_dists(self, box: 'Box') -> "flt":
        """mean_dists(BondPairs self, Box box) -> flt"""
        return _sim2d.BondPairs_mean_dists(self, box)


    def std_dists(self, box: 'Box') -> "flt":
        """std_dists(BondPairs self, Box box) -> flt"""
        return _sim2d.BondPairs_std_dists(self, box)


    def energy(self, box: 'Box') -> "flt":
        """energy(BondPairs self, Box box) -> flt"""
        return _sim2d.BondPairs_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(BondPairs self, Box box)"""
        return _sim2d.BondPairs_set_forces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(BondPairs self, Box box) -> flt"""
        return _sim2d.BondPairs_pressure(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(BondPairs self, Box box) -> flt"""
        return _sim2d.BondPairs_set_forces_get_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_BondPairs
    __del__ = lambda self: None
BondPairs_swigregister = _sim2d.BondPairs_swigregister
BondPairs_swigregister(BondPairs)

class AngleGrouping(_object):
    """Proxy of C++ AngleGrouping class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngleGrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngleGrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2d.AngleGrouping_k_set
    __swig_getmethods__["k"] = _sim2d.AngleGrouping_k_get
    if _newclass:
        k = _swig_property(_sim2d.AngleGrouping_k_get, _sim2d.AngleGrouping_k_set)
    __swig_setmethods__["x0"] = _sim2d.AngleGrouping_x0_set
    __swig_getmethods__["x0"] = _sim2d.AngleGrouping_x0_get
    if _newclass:
        x0 = _swig_property(_sim2d.AngleGrouping_x0_get, _sim2d.AngleGrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2d.AngleGrouping_a1_set
    __swig_getmethods__["a1"] = _sim2d.AngleGrouping_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.AngleGrouping_a1_get, _sim2d.AngleGrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2d.AngleGrouping_a2_set
    __swig_getmethods__["a2"] = _sim2d.AngleGrouping_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.AngleGrouping_a2_get, _sim2d.AngleGrouping_a2_set)
    __swig_setmethods__["a3"] = _sim2d.AngleGrouping_a3_set
    __swig_getmethods__["a3"] = _sim2d.AngleGrouping_a3_get
    if _newclass:
        a3 = _swig_property(_sim2d.AngleGrouping_a3_get, _sim2d.AngleGrouping_a3_set)

    def __init__(self, k: 'flt', x0: 'flt', a1: 'AtomID', a2: 'AtomID', a3: 'AtomID'):
        """__init__(AngleGrouping self, flt k, flt x0, AtomID a1, AtomID a2, AtomID a3) -> AngleGrouping"""
        this = _sim2d.new_AngleGrouping(k, x0, a1, a2, a3)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def same_atoms(self, other: 'AngleGrouping') -> "bool":
        """same_atoms(AngleGrouping self, AngleGrouping other) -> bool"""
        return _sim2d.AngleGrouping_same_atoms(self, other)

    __swig_destroy__ = _sim2d.delete_AngleGrouping
    __del__ = lambda self: None
AngleGrouping_swigregister = _sim2d.AngleGrouping_swigregister
AngleGrouping_swigregister(AngleGrouping)

class AngleTriples(Interaction):
    """Proxy of C++ AngleTriples class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngleTriples, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AngleTriples, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AngleTriples self, std::vector< AngleGrouping > triples) -> AngleTriples
        __init__(AngleTriples self) -> AngleTriples
        """
        this = _sim2d.new_AngleTriples(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, *args) -> "bool":
        """
        add(AngleTriples self, AngleGrouping b, bool replace=True) -> bool
        add(AngleTriples self, AngleGrouping b) -> bool
        add(AngleTriples self, flt k, flt x0, AtomID a1, AtomID a2, AtomID a3, bool replace=True) -> bool
        add(AngleTriples self, flt k, flt x0, AtomID a1, AtomID a2, AtomID a3) -> bool
        add(AngleTriples self, flt k, AtomID a1, AtomID a2, AtomID a3, bool replace=True) -> bool
        add(AngleTriples self, flt k, AtomID a1, AtomID a2, AtomID a3) -> bool
        """
        return _sim2d.AngleTriples_add(self, *args)


    def add_forced(self, b: 'AngleGrouping') -> "void":
        """add_forced(AngleTriples self, AngleGrouping b)"""
        return _sim2d.AngleTriples_add_forced(self, b)


    def energy(self, box: 'Box') -> "flt":
        """energy(AngleTriples self, Box box) -> flt"""
        return _sim2d.AngleTriples_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(AngleTriples self, Box box) -> flt"""
        return _sim2d.AngleTriples_pressure(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(AngleTriples self, Box box)"""
        return _sim2d.AngleTriples_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(AngleTriples self, Box box) -> flt"""
        return _sim2d.AngleTriples_set_forces_get_pressure(self, box)


    def size(self) -> "uint":
        """size(AngleTriples self) -> uint"""
        return _sim2d.AngleTriples_size(self)


    def mean_dists(self) -> "flt":
        """mean_dists(AngleTriples self) -> flt"""
        return _sim2d.AngleTriples_mean_dists(self)


    def std_dists(self) -> "flt":
        """std_dists(AngleTriples self) -> flt"""
        return _sim2d.AngleTriples_std_dists(self)

    __swig_destroy__ = _sim2d.delete_AngleTriples
    __del__ = lambda self: None
AngleTriples_swigregister = _sim2d.AngleTriples_swigregister
AngleTriples_swigregister(AngleTriples)

class ForcePair(_object):
    """Proxy of C++ ForcePair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForcePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ForcePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2d.ForcePair_a1_set
    __swig_getmethods__["a1"] = _sim2d.ForcePair_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.ForcePair_a1_get, _sim2d.ForcePair_a1_set)
    __swig_setmethods__["a2"] = _sim2d.ForcePair_a2_set
    __swig_getmethods__["a2"] = _sim2d.ForcePair_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.ForcePair_a2_get, _sim2d.ForcePair_a2_set)
    __swig_setmethods__["fij"] = _sim2d.ForcePair_fij_set
    __swig_getmethods__["fij"] = _sim2d.ForcePair_fij_get
    if _newclass:
        fij = _swig_property(_sim2d.ForcePair_fij_get, _sim2d.ForcePair_fij_set)

    def __init__(self):
        """__init__(ForcePair self) -> ForcePair"""
        this = _sim2d.new_ForcePair()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_ForcePair
    __del__ = lambda self: None
ForcePair_swigregister = _sim2d.ForcePair_swigregister
ForcePair_swigregister(ForcePair)

class ForcePairX(_object):
    """Proxy of C++ ForcePairX class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForcePairX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ForcePairX, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2d.ForcePairX_a1_set
    __swig_getmethods__["a1"] = _sim2d.ForcePairX_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.ForcePairX_a1_get, _sim2d.ForcePairX_a1_set)
    __swig_setmethods__["a2"] = _sim2d.ForcePairX_a2_set
    __swig_getmethods__["a2"] = _sim2d.ForcePairX_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.ForcePairX_a2_get, _sim2d.ForcePairX_a2_set)
    __swig_setmethods__["xij"] = _sim2d.ForcePairX_xij_set
    __swig_getmethods__["xij"] = _sim2d.ForcePairX_xij_get
    if _newclass:
        xij = _swig_property(_sim2d.ForcePairX_xij_get, _sim2d.ForcePairX_xij_set)
    __swig_setmethods__["fij"] = _sim2d.ForcePairX_fij_set
    __swig_getmethods__["fij"] = _sim2d.ForcePairX_fij_get
    if _newclass:
        fij = _swig_property(_sim2d.ForcePairX_fij_get, _sim2d.ForcePairX_fij_set)

    def __init__(self):
        """__init__(ForcePairX self) -> ForcePairX"""
        this = _sim2d.new_ForcePairX()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_ForcePairX
    __del__ = lambda self: None
ForcePairX_swigregister = _sim2d.ForcePairX_swigregister
ForcePairX_swigregister(ForcePairX)

class FPairXFunct(_object):
    """Proxy of C++ FPairXFunct class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FPairXFunct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FPairXFunct, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def run(self, arg2: 'ForcePairX') -> "void":
        """run(FPairXFunct self, ForcePairX arg2)"""
        return _sim2d.FPairXFunct_run(self, arg2)

    __swig_destroy__ = _sim2d.delete_FPairXFunct
    __del__ = lambda self: None
FPairXFunct_swigregister = _sim2d.FPairXFunct_swigregister
FPairXFunct_swigregister(FPairXFunct)

class InteractionPairsX(Interaction):
    """Proxy of C++ InteractionPairsX class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InteractionPairsX, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InteractionPairsX, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_forces(self, *args) -> "void":
        """
        set_forces(InteractionPairsX self, Box box)
        set_forces(InteractionPairsX self, Box box, FPairXFunct arg3)
        """
        return _sim2d.InteractionPairsX_set_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_InteractionPairsX
    __del__ = lambda self: None
InteractionPairsX_swigregister = _sim2d.InteractionPairsX_swigregister
InteractionPairsX_swigregister(InteractionPairsX)

class Charged(AtomID):
    """Proxy of C++ Charged class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charged, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charged, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q"] = _sim2d.Charged_q_set
    __swig_getmethods__["q"] = _sim2d.Charged_q_get
    if _newclass:
        q = _swig_property(_sim2d.Charged_q_get, _sim2d.Charged_q_set)

    def __init__(self, *args):
        """
        __init__(Charged self) -> Charged
        __init__(Charged self, flt q, AtomID a) -> Charged
        """
        this = _sim2d.new_Charged(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_Charged
    __del__ = lambda self: None
Charged_swigregister = _sim2d.Charged_swigregister
Charged_swigregister(Charged)

class ChargePair(_object):
    """Proxy of C++ ChargePair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChargePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChargePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q1q2"] = _sim2d.ChargePair_q1q2_set
    __swig_getmethods__["q1q2"] = _sim2d.ChargePair_q1q2_get
    if _newclass:
        q1q2 = _swig_property(_sim2d.ChargePair_q1q2_get, _sim2d.ChargePair_q1q2_set)
    __swig_setmethods__["atom1"] = _sim2d.ChargePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.ChargePair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.ChargePair_atom1_get, _sim2d.ChargePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.ChargePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.ChargePair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.ChargePair_atom2_get, _sim2d.ChargePair_atom2_set)

    def __init__(self, a1: 'Charged', a2: 'Charged'):
        """__init__(ChargePair self, Charged a1, Charged a2) -> ChargePair"""
        this = _sim2d.new_ChargePair(a1, a2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_ChargePair
    __del__ = lambda self: None
ChargePair_swigregister = _sim2d.ChargePair_swigregister
ChargePair_swigregister(ChargePair)

class EpsSigAtom(AtomID):
    """Proxy of C++ EpsSigAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EpsSigAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EpsSigAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.EpsSigAtom_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.EpsSigAtom_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.EpsSigAtom_epsilon_get, _sim2d.EpsSigAtom_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2d.EpsSigAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.EpsSigAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.EpsSigAtom_sigma_get, _sim2d.EpsSigAtom_sigma_set)

    def __init__(self, *args):
        """
        __init__(EpsSigAtom self) -> EpsSigAtom
        __init__(EpsSigAtom self, AtomID a, flt epsilon, flt sigma) -> EpsSigAtom
        __init__(EpsSigAtom self, AtomID a, EpsSigAtom other) -> EpsSigAtom
        """
        this = _sim2d.new_EpsSigAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_size(self) -> "flt":
        """max_size(EpsSigAtom self) -> flt"""
        return _sim2d.EpsSigAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_EpsSigAtom
    __del__ = lambda self: None
EpsSigAtom_swigregister = _sim2d.EpsSigAtom_swigregister
EpsSigAtom_swigregister(EpsSigAtom)

class LJRepulsePair(_object):
    """Proxy of C++ LJRepulsePair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJRepulsePair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJRepulsePair_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.LJRepulsePair_epsilon_get, _sim2d.LJRepulsePair_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2d.LJRepulsePair_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJRepulsePair_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LJRepulsePair_sigma_get, _sim2d.LJRepulsePair_sigma_set)
    __swig_setmethods__["atom1"] = _sim2d.LJRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJRepulsePair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJRepulsePair_atom1_get, _sim2d.LJRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJRepulsePair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJRepulsePair_atom2_get, _sim2d.LJRepulsePair_atom2_set)

    def __init__(self, LJ1: 'EpsSigAtom', LJ2: 'EpsSigAtom'):
        """__init__(LJRepulsePair self, EpsSigAtom LJ1, EpsSigAtom LJ2) -> LJRepulsePair"""
        this = _sim2d.new_LJRepulsePair(LJ1, LJ2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJRepulsePair self, Box box) -> flt"""
        return _sim2d.LJRepulsePair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJRepulsePair self, Box box) -> Vec"""
        return _sim2d.LJRepulsePair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJRepulsePair
    __del__ = lambda self: None
LJRepulsePair_swigregister = _sim2d.LJRepulsePair_swigregister
LJRepulsePair_swigregister(LJRepulsePair)

class EpsSigCutAtom(EpsSigAtom):
    """Proxy of C++ EpsSigCutAtom class."""

    __swig_setmethods__ = {}
    for _s in [EpsSigAtom]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EpsSigCutAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [EpsSigAtom]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EpsSigCutAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sigcut"] = _sim2d.EpsSigCutAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.EpsSigCutAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.EpsSigCutAtom_sigcut_get, _sim2d.EpsSigCutAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(EpsSigCutAtom self) -> EpsSigCutAtom
        __init__(EpsSigCutAtom self, AtomID a, flt epsilon, flt sigma, flt cut) -> EpsSigCutAtom
        __init__(EpsSigCutAtom self, AtomID a, EpsSigCutAtom other) -> EpsSigCutAtom
        """
        this = _sim2d.new_EpsSigCutAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_size(self) -> "flt":
        """max_size(EpsSigCutAtom self) -> flt"""
        return _sim2d.EpsSigCutAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_EpsSigCutAtom
    __del__ = lambda self: None
EpsSigCutAtom_swigregister = _sim2d.EpsSigCutAtom_swigregister
EpsSigCutAtom_swigregister(EpsSigCutAtom)

class IEpsISigCutAtom(AtomID):
    """Proxy of C++ IEpsISigCutAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEpsISigCutAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEpsISigCutAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.IEpsISigCutAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.IEpsISigCutAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.IEpsISigCutAtom_epsilons_get, _sim2d.IEpsISigCutAtom_epsilons_set)
    __swig_setmethods__["sigmas"] = _sim2d.IEpsISigCutAtom_sigmas_set
    __swig_getmethods__["sigmas"] = _sim2d.IEpsISigCutAtom_sigmas_get
    if _newclass:
        sigmas = _swig_property(_sim2d.IEpsISigCutAtom_sigmas_get, _sim2d.IEpsISigCutAtom_sigmas_set)
    __swig_setmethods__["indx"] = _sim2d.IEpsISigCutAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.IEpsISigCutAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.IEpsISigCutAtom_indx_get, _sim2d.IEpsISigCutAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.IEpsISigCutAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.IEpsISigCutAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.IEpsISigCutAtom_sigcut_get, _sim2d.IEpsISigCutAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(IEpsISigCutAtom self) -> IEpsISigCutAtom
        __init__(IEpsISigCutAtom self, AtomID a, dvector epsilons, dvector sigmas, uint indx, flt cut) -> IEpsISigCutAtom
        __init__(IEpsISigCutAtom self, AtomID a, IEpsISigCutAtom other) -> IEpsISigCutAtom
        """
        this = _sim2d.new_IEpsISigCutAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_epsilon(self, other: 'IEpsISigCutAtom') -> "flt":
        """get_epsilon(IEpsISigCutAtom self, IEpsISigCutAtom other) -> flt"""
        return _sim2d.IEpsISigCutAtom_get_epsilon(self, other)


    def get_sigma(self, other: 'IEpsISigCutAtom') -> "flt":
        """get_sigma(IEpsISigCutAtom self, IEpsISigCutAtom other) -> flt"""
        return _sim2d.IEpsISigCutAtom_get_sigma(self, other)


    def max_size(self) -> "flt":
        """max_size(IEpsISigCutAtom self) -> flt"""
        return _sim2d.IEpsISigCutAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_IEpsISigCutAtom
    __del__ = lambda self: None
IEpsISigCutAtom_swigregister = _sim2d.IEpsISigCutAtom_swigregister
IEpsISigCutAtom_swigregister(IEpsISigCutAtom)

class LennardJonesCutPair(_object):
    """Proxy of C++ LennardJonesCutPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LennardJonesCutPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LennardJonesCutPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.LennardJonesCutPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.LennardJonesCutPair_inter_get
    if _newclass:
        inter = _swig_property(_sim2d.LennardJonesCutPair_inter_get, _sim2d.LennardJonesCutPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.LennardJonesCutPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LennardJonesCutPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LennardJonesCutPair_atom1_get, _sim2d.LennardJonesCutPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LennardJonesCutPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LennardJonesCutPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LennardJonesCutPair_atom2_get, _sim2d.LennardJonesCutPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LennardJonesCutPair self, EpsSigCutAtom a1, EpsSigCutAtom a2) -> LennardJonesCutPair
        __init__(LennardJonesCutPair self, IEpsISigCutAtom a1, IEpsISigCutAtom a2) -> LennardJonesCutPair
        """
        this = _sim2d.new_LennardJonesCutPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LennardJonesCutPair self, Box box) -> flt"""
        return _sim2d.LennardJonesCutPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LennardJonesCutPair self, Box box) -> Vec"""
        return _sim2d.LennardJonesCutPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LennardJonesCutPair
    __del__ = lambda self: None
LennardJonesCutPair_swigregister = _sim2d.LennardJonesCutPair_swigregister
LennardJonesCutPair_swigregister(LennardJonesCutPair)

class IEpsSigCutAtom(AtomID):
    """Proxy of C++ IEpsSigCutAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEpsSigCutAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEpsSigCutAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.IEpsSigCutAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.IEpsSigCutAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.IEpsSigCutAtom_epsilons_get, _sim2d.IEpsSigCutAtom_epsilons_set)
    __swig_setmethods__["indx"] = _sim2d.IEpsSigCutAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.IEpsSigCutAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.IEpsSigCutAtom_indx_get, _sim2d.IEpsSigCutAtom_indx_set)
    __swig_setmethods__["sigma"] = _sim2d.IEpsSigCutAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.IEpsSigCutAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.IEpsSigCutAtom_sigma_get, _sim2d.IEpsSigCutAtom_sigma_set)
    __swig_setmethods__["sigcut"] = _sim2d.IEpsSigCutAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.IEpsSigCutAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.IEpsSigCutAtom_sigcut_get, _sim2d.IEpsSigCutAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(IEpsSigCutAtom self) -> IEpsSigCutAtom
        __init__(IEpsSigCutAtom self, AtomID a, dvector epsilons, uint indx, flt sigma, flt cut) -> IEpsSigCutAtom
        __init__(IEpsSigCutAtom self, AtomID a, IEpsSigCutAtom other) -> IEpsSigCutAtom
        """
        this = _sim2d.new_IEpsSigCutAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_epsilon(self, other: 'IEpsSigCutAtom') -> "flt":
        """get_epsilon(IEpsSigCutAtom self, IEpsSigCutAtom other) -> flt"""
        return _sim2d.IEpsSigCutAtom_get_epsilon(self, other)


    def max_size(self) -> "flt":
        """max_size(IEpsSigCutAtom self) -> flt"""
        return _sim2d.IEpsSigCutAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_IEpsSigCutAtom
    __del__ = lambda self: None
IEpsSigCutAtom_swigregister = _sim2d.IEpsSigCutAtom_swigregister
IEpsSigCutAtom_swigregister(IEpsSigCutAtom)

class LJAttractCutPair(_object):
    """Proxy of C++ LJAttractCutPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractCutPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractCutPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.LJAttractCutPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.LJAttractCutPair_inter_get
    if _newclass:
        inter = _swig_property(_sim2d.LJAttractCutPair_inter_get, _sim2d.LJAttractCutPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractCutPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractCutPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJAttractCutPair_atom1_get, _sim2d.LJAttractCutPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractCutPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractCutPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJAttractCutPair_atom2_get, _sim2d.LJAttractCutPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LJAttractCutPair self, EpsSigCutAtom a1, EpsSigCutAtom a2) -> LJAttractCutPair
        __init__(LJAttractCutPair self, IEpsISigCutAtom a1, IEpsISigCutAtom a2) -> LJAttractCutPair
        __init__(LJAttractCutPair self, IEpsSigCutAtom a1, IEpsSigCutAtom a2) -> LJAttractCutPair
        """
        this = _sim2d.new_LJAttractCutPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJAttractCutPair self, Box box) -> flt"""
        return _sim2d.LJAttractCutPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJAttractCutPair self, Box box) -> Vec"""
        return _sim2d.LJAttractCutPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJAttractCutPair
    __del__ = lambda self: None
LJAttractCutPair_swigregister = _sim2d.LJAttractCutPair_swigregister
LJAttractCutPair_swigregister(LJAttractCutPair)

class IEpsRepsSigExpCutAtom(AtomID):
    """Proxy of C++ IEpsRepsSigExpCutAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEpsRepsSigExpCutAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEpsRepsSigExpCutAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.IEpsRepsSigExpCutAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.IEpsRepsSigExpCutAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.IEpsRepsSigExpCutAtom_epsilons_get, _sim2d.IEpsRepsSigExpCutAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2d.IEpsRepsSigExpCutAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.IEpsRepsSigExpCutAtom_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.IEpsRepsSigExpCutAtom_repeps_get, _sim2d.IEpsRepsSigExpCutAtom_repeps_set)
    __swig_setmethods__["sigma"] = _sim2d.IEpsRepsSigExpCutAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.IEpsRepsSigExpCutAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.IEpsRepsSigExpCutAtom_sigma_get, _sim2d.IEpsRepsSigExpCutAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.IEpsRepsSigExpCutAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.IEpsRepsSigExpCutAtom_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.IEpsRepsSigExpCutAtom_exponent_get, _sim2d.IEpsRepsSigExpCutAtom_exponent_set)
    __swig_setmethods__["indx"] = _sim2d.IEpsRepsSigExpCutAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.IEpsRepsSigExpCutAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.IEpsRepsSigExpCutAtom_indx_get, _sim2d.IEpsRepsSigExpCutAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.IEpsRepsSigExpCutAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.IEpsRepsSigExpCutAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.IEpsRepsSigExpCutAtom_sigcut_get, _sim2d.IEpsRepsSigExpCutAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(IEpsRepsSigExpCutAtom self) -> IEpsRepsSigExpCutAtom
        __init__(IEpsRepsSigExpCutAtom self, AtomID a, dvector epsilons, flt repeps, flt sigma, flt n, uint indx, flt cut) -> IEpsRepsSigExpCutAtom
        __init__(IEpsRepsSigExpCutAtom self, AtomID a, IEpsRepsSigExpCutAtom other) -> IEpsRepsSigExpCutAtom
        """
        this = _sim2d.new_IEpsRepsSigExpCutAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_epsilon(self, other: 'IEpsRepsSigExpCutAtom') -> "flt":
        """get_epsilon(IEpsRepsSigExpCutAtom self, IEpsRepsSigExpCutAtom other) -> flt"""
        return _sim2d.IEpsRepsSigExpCutAtom_get_epsilon(self, other)


    def get_sigma(self, other: 'IEpsRepsSigExpCutAtom') -> "flt":
        """get_sigma(IEpsRepsSigExpCutAtom self, IEpsRepsSigExpCutAtom other) -> flt"""
        return _sim2d.IEpsRepsSigExpCutAtom_get_sigma(self, other)


    def max_size(self) -> "flt":
        """max_size(IEpsRepsSigExpCutAtom self) -> flt"""
        return _sim2d.IEpsRepsSigExpCutAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_IEpsRepsSigExpCutAtom
    __del__ = lambda self: None
IEpsRepsSigExpCutAtom_swigregister = _sim2d.IEpsRepsSigExpCutAtom_swigregister
IEpsRepsSigExpCutAtom_swigregister(IEpsRepsSigExpCutAtom)

class LJishPair(_object):
    """Proxy of C++ LJishPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJishPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJishPair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJishPair_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.LJishPair_epsilon_get, _sim2d.LJishPair_epsilon_set)
    __swig_setmethods__["repeps"] = _sim2d.LJishPair_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJishPair_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.LJishPair_repeps_get, _sim2d.LJishPair_repeps_set)
    __swig_setmethods__["sigma"] = _sim2d.LJishPair_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJishPair_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LJishPair_sigma_get, _sim2d.LJishPair_sigma_set)
    __swig_setmethods__["n"] = _sim2d.LJishPair_n_set
    __swig_getmethods__["n"] = _sim2d.LJishPair_n_get
    if _newclass:
        n = _swig_property(_sim2d.LJishPair_n_get, _sim2d.LJishPair_n_set)
    __swig_setmethods__["cut_distance"] = _sim2d.LJishPair_cut_distance_set
    __swig_getmethods__["cut_distance"] = _sim2d.LJishPair_cut_distance_get
    if _newclass:
        cut_distance = _swig_property(_sim2d.LJishPair_cut_distance_get, _sim2d.LJishPair_cut_distance_set)
    __swig_setmethods__["cut_energy"] = _sim2d.LJishPair_cut_energy_set
    __swig_getmethods__["cut_energy"] = _sim2d.LJishPair_cut_energy_get
    if _newclass:
        cut_energy = _swig_property(_sim2d.LJishPair_cut_energy_get, _sim2d.LJishPair_cut_energy_set)
    __swig_setmethods__["atom1"] = _sim2d.LJishPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJishPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJishPair_atom1_get, _sim2d.LJishPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJishPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJishPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJishPair_atom2_get, _sim2d.LJishPair_atom2_set)

    def __init__(self, LJ1: 'IEpsRepsSigExpCutAtom', LJ2: 'IEpsRepsSigExpCutAtom'):
        """__init__(LJishPair self, IEpsRepsSigExpCutAtom LJ1, IEpsRepsSigExpCutAtom LJ2) -> LJishPair"""
        this = _sim2d.new_LJishPair(LJ1, LJ2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJishPair self, Box box) -> flt"""
        return _sim2d.LJishPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJishPair self, Box box) -> Vec"""
        return _sim2d.LJishPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJishPair
    __del__ = lambda self: None
LJishPair_swigregister = _sim2d.LJishPair_swigregister
LJishPair_swigregister(LJishPair)

class LJAttractRepulsePair(_object):
    """Proxy of C++ LJAttractRepulsePair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LJAttractRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LJAttractRepulsePair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LJAttractRepulsePair_eps_get, _sim2d.LJAttractRepulsePair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractRepulsePair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LJAttractRepulsePair_sig_get, _sim2d.LJAttractRepulsePair_sig_set)
    __swig_setmethods__["cut_distance"] = _sim2d.LJAttractRepulsePair_cut_distance_set
    __swig_getmethods__["cut_distance"] = _sim2d.LJAttractRepulsePair_cut_distance_get
    if _newclass:
        cut_distance = _swig_property(_sim2d.LJAttractRepulsePair_cut_distance_get, _sim2d.LJAttractRepulsePair_cut_distance_set)
    __swig_setmethods__["cut_energy"] = _sim2d.LJAttractRepulsePair_cut_energy_set
    __swig_getmethods__["cut_energy"] = _sim2d.LJAttractRepulsePair_cut_energy_get
    if _newclass:
        cut_energy = _swig_property(_sim2d.LJAttractRepulsePair_cut_energy_get, _sim2d.LJAttractRepulsePair_cut_energy_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractRepulsePair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJAttractRepulsePair_atom1_get, _sim2d.LJAttractRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractRepulsePair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJAttractRepulsePair_atom2_get, _sim2d.LJAttractRepulsePair_atom2_set)

    def __init__(self, a1: 'IEpsSigCutAtom', a2: 'IEpsSigCutAtom'):
        """__init__(LJAttractRepulsePair self, IEpsSigCutAtom a1, IEpsSigCutAtom a2) -> LJAttractRepulsePair"""
        this = _sim2d.new_LJAttractRepulsePair(a1, a2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJAttractRepulsePair self, Box box) -> flt"""
        return _sim2d.LJAttractRepulsePair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJAttractRepulsePair self, Box box) -> Vec"""
        return _sim2d.LJAttractRepulsePair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulsePair
    __del__ = lambda self: None
LJAttractRepulsePair_swigregister = _sim2d.LJAttractRepulsePair_swigregister
LJAttractRepulsePair_swigregister(LJAttractRepulsePair)

class IEpsRepsSigCutAtom(AtomID):
    """Proxy of C++ IEpsRepsSigCutAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEpsRepsSigCutAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEpsRepsSigCutAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.IEpsRepsSigCutAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.IEpsRepsSigCutAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.IEpsRepsSigCutAtom_epsilons_get, _sim2d.IEpsRepsSigCutAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2d.IEpsRepsSigCutAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.IEpsRepsSigCutAtom_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.IEpsRepsSigCutAtom_repeps_get, _sim2d.IEpsRepsSigCutAtom_repeps_set)
    __swig_setmethods__["sig"] = _sim2d.IEpsRepsSigCutAtom_sig_set
    __swig_getmethods__["sig"] = _sim2d.IEpsRepsSigCutAtom_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.IEpsRepsSigCutAtom_sig_get, _sim2d.IEpsRepsSigCutAtom_sig_set)
    __swig_setmethods__["indx"] = _sim2d.IEpsRepsSigCutAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.IEpsRepsSigCutAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.IEpsRepsSigCutAtom_indx_get, _sim2d.IEpsRepsSigCutAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.IEpsRepsSigCutAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.IEpsRepsSigCutAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.IEpsRepsSigCutAtom_sigcut_get, _sim2d.IEpsRepsSigCutAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(IEpsRepsSigCutAtom self) -> IEpsRepsSigCutAtom
        __init__(IEpsRepsSigCutAtom self, AtomID a, dvector epsilons, flt repeps, flt sigma, uint indx, flt cut) -> IEpsRepsSigCutAtom
        __init__(IEpsRepsSigCutAtom self, AtomID a, IEpsRepsSigCutAtom other) -> IEpsRepsSigCutAtom
        """
        this = _sim2d.new_IEpsRepsSigCutAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_epsilon(self, other: 'IEpsRepsSigCutAtom') -> "flt":
        """get_epsilon(IEpsRepsSigCutAtom self, IEpsRepsSigCutAtom other) -> flt"""
        return _sim2d.IEpsRepsSigCutAtom_get_epsilon(self, other)


    def max_size(self) -> "flt":
        """max_size(IEpsRepsSigCutAtom self) -> flt"""
        return _sim2d.IEpsRepsSigCutAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_IEpsRepsSigCutAtom
    __del__ = lambda self: None
IEpsRepsSigCutAtom_swigregister = _sim2d.IEpsRepsSigCutAtom_swigregister
IEpsRepsSigCutAtom_swigregister(IEpsRepsSigCutAtom)

class LJAttractFixedRepulsePair(_object):
    """Proxy of C++ LJAttractFixedRepulsePair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LJAttractFixedRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LJAttractFixedRepulsePair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LJAttractFixedRepulsePair_eps_get, _sim2d.LJAttractFixedRepulsePair_eps_set)
    __swig_setmethods__["repeps"] = _sim2d.LJAttractFixedRepulsePair_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJAttractFixedRepulsePair_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.LJAttractFixedRepulsePair_repeps_get, _sim2d.LJAttractFixedRepulsePair_repeps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractFixedRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractFixedRepulsePair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LJAttractFixedRepulsePair_sig_get, _sim2d.LJAttractFixedRepulsePair_sig_set)
    __swig_setmethods__["cut_distance"] = _sim2d.LJAttractFixedRepulsePair_cut_distance_set
    __swig_getmethods__["cut_distance"] = _sim2d.LJAttractFixedRepulsePair_cut_distance_get
    if _newclass:
        cut_distance = _swig_property(_sim2d.LJAttractFixedRepulsePair_cut_distance_get, _sim2d.LJAttractFixedRepulsePair_cut_distance_set)
    __swig_setmethods__["cut_energy"] = _sim2d.LJAttractFixedRepulsePair_cut_energy_set
    __swig_getmethods__["cut_energy"] = _sim2d.LJAttractFixedRepulsePair_cut_energy_get
    if _newclass:
        cut_energy = _swig_property(_sim2d.LJAttractFixedRepulsePair_cut_energy_get, _sim2d.LJAttractFixedRepulsePair_cut_energy_set)
    __swig_setmethods__["attract"] = _sim2d.LJAttractFixedRepulsePair_attract_set
    __swig_getmethods__["attract"] = _sim2d.LJAttractFixedRepulsePair_attract_get
    if _newclass:
        attract = _swig_property(_sim2d.LJAttractFixedRepulsePair_attract_get, _sim2d.LJAttractFixedRepulsePair_attract_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractFixedRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractFixedRepulsePair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJAttractFixedRepulsePair_atom1_get, _sim2d.LJAttractFixedRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractFixedRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractFixedRepulsePair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJAttractFixedRepulsePair_atom2_get, _sim2d.LJAttractFixedRepulsePair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LJAttractFixedRepulsePair self) -> LJAttractFixedRepulsePair
        __init__(LJAttractFixedRepulsePair self, IEpsRepsSigCutAtom a1, IEpsRepsSigCutAtom a2) -> LJAttractFixedRepulsePair
        """
        this = _sim2d.new_LJAttractFixedRepulsePair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJAttractFixedRepulsePair self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulsePair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJAttractFixedRepulsePair self, Box box) -> Vec"""
        return _sim2d.LJAttractFixedRepulsePair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulsePair
    __del__ = lambda self: None
LJAttractFixedRepulsePair_swigregister = _sim2d.LJAttractFixedRepulsePair_swigregister
LJAttractFixedRepulsePair_swigregister(LJAttractFixedRepulsePair)

class EisMclachlanAtom(AtomID):
    """Proxy of C++ EisMclachlanAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dist"] = _sim2d.EisMclachlanAtom_dist_set
    __swig_getmethods__["dist"] = _sim2d.EisMclachlanAtom_dist_get
    if _newclass:
        dist = _swig_property(_sim2d.EisMclachlanAtom_dist_get, _sim2d.EisMclachlanAtom_dist_set)
    __swig_setmethods__["sigmai"] = _sim2d.EisMclachlanAtom_sigmai_set
    __swig_getmethods__["sigmai"] = _sim2d.EisMclachlanAtom_sigmai_get
    if _newclass:
        sigmai = _swig_property(_sim2d.EisMclachlanAtom_sigmai_get, _sim2d.EisMclachlanAtom_sigmai_set)

    def __init__(self, *args):
        """
        __init__(EisMclachlanAtom self) -> EisMclachlanAtom
        __init__(EisMclachlanAtom self, AtomID a, flt dist, flt sigmai) -> EisMclachlanAtom
        __init__(EisMclachlanAtom self, AtomID a, EisMclachlanAtom other) -> EisMclachlanAtom
        """
        this = _sim2d.new_EisMclachlanAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_size(self) -> "flt":
        """max_size(EisMclachlanAtom self) -> flt"""
        return _sim2d.EisMclachlanAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_EisMclachlanAtom
    __del__ = lambda self: None
EisMclachlanAtom_swigregister = _sim2d.EisMclachlanAtom_swigregister
EisMclachlanAtom_swigregister(EisMclachlanAtom)

class EisMclachlanPair(_object):
    """Proxy of C++ EisMclachlanPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["c0"] = _sim2d.EisMclachlanPair_c0_set
    __swig_getmethods__["c0"] = _sim2d.EisMclachlanPair_c0_get
    if _newclass:
        c0 = _swig_property(_sim2d.EisMclachlanPair_c0_get, _sim2d.EisMclachlanPair_c0_set)
    __swig_setmethods__["c1"] = _sim2d.EisMclachlanPair_c1_set
    __swig_getmethods__["c1"] = _sim2d.EisMclachlanPair_c1_get
    if _newclass:
        c1 = _swig_property(_sim2d.EisMclachlanPair_c1_get, _sim2d.EisMclachlanPair_c1_set)
    __swig_setmethods__["c2"] = _sim2d.EisMclachlanPair_c2_set
    __swig_getmethods__["c2"] = _sim2d.EisMclachlanPair_c2_get
    if _newclass:
        c2 = _swig_property(_sim2d.EisMclachlanPair_c2_get, _sim2d.EisMclachlanPair_c2_set)
    __swig_setmethods__["cutoff"] = _sim2d.EisMclachlanPair_cutoff_set
    __swig_getmethods__["cutoff"] = _sim2d.EisMclachlanPair_cutoff_get
    if _newclass:
        cutoff = _swig_property(_sim2d.EisMclachlanPair_cutoff_get, _sim2d.EisMclachlanPair_cutoff_set)
    __swig_setmethods__["atom1"] = _sim2d.EisMclachlanPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.EisMclachlanPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.EisMclachlanPair_atom1_get, _sim2d.EisMclachlanPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.EisMclachlanPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.EisMclachlanPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.EisMclachlanPair_atom2_get, _sim2d.EisMclachlanPair_atom2_set)

    def __init__(self, a1: 'EisMclachlanAtom', a2: 'EisMclachlanAtom'):
        """__init__(EisMclachlanPair self, EisMclachlanAtom a1, EisMclachlanAtom a2) -> EisMclachlanPair"""
        this = _sim2d.new_EisMclachlanPair(a1, a2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(EisMclachlanPair self, Box box) -> flt"""
        return _sim2d.EisMclachlanPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(EisMclachlanPair self, Box box) -> Vec"""
        return _sim2d.EisMclachlanPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_EisMclachlanPair
    __del__ = lambda self: None
EisMclachlanPair_swigregister = _sim2d.EisMclachlanPair_swigregister
EisMclachlanPair_swigregister(EisMclachlanPair)

class EpsSigExpAtom(AtomID):
    """Proxy of C++ EpsSigExpAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EpsSigExpAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EpsSigExpAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.EpsSigExpAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.EpsSigExpAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.EpsSigExpAtom_eps_get, _sim2d.EpsSigExpAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.EpsSigExpAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.EpsSigExpAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.EpsSigExpAtom_sigma_get, _sim2d.EpsSigExpAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.EpsSigExpAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.EpsSigExpAtom_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.EpsSigExpAtom_exponent_get, _sim2d.EpsSigExpAtom_exponent_set)

    def __init__(self, *args):
        """
        __init__(EpsSigExpAtom self) -> EpsSigExpAtom
        __init__(EpsSigExpAtom self, AtomID a, flt eps, flt sigma, flt exponent) -> EpsSigExpAtom
        __init__(EpsSigExpAtom self, AtomID a, EpsSigExpAtom other) -> EpsSigExpAtom
        """
        this = _sim2d.new_EpsSigExpAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_size(self) -> "flt":
        """max_size(EpsSigExpAtom self) -> flt"""
        return _sim2d.EpsSigExpAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_EpsSigExpAtom
    __del__ = lambda self: None
EpsSigExpAtom_swigregister = _sim2d.EpsSigExpAtom_swigregister
EpsSigExpAtom_swigregister(EpsSigExpAtom)

class EnergyForce(_object):
    """Proxy of C++ EnergyForce class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyForce, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyForce, name)
    __repr__ = _swig_repr
    __swig_setmethods__["f"] = _sim2d.EnergyForce_f_set
    __swig_getmethods__["f"] = _sim2d.EnergyForce_f_get
    if _newclass:
        f = _swig_property(_sim2d.EnergyForce_f_get, _sim2d.EnergyForce_f_set)
    __swig_setmethods__["E"] = _sim2d.EnergyForce_E_set
    __swig_getmethods__["E"] = _sim2d.EnergyForce_E_get
    if _newclass:
        E = _swig_property(_sim2d.EnergyForce_E_get, _sim2d.EnergyForce_E_set)

    def __init__(self, f: 'Vec', E: 'flt'):
        """__init__(EnergyForce self, Vec f, flt E) -> EnergyForce"""
        this = _sim2d.new_EnergyForce(f, E)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_EnergyForce
    __del__ = lambda self: None
EnergyForce_swigregister = _sim2d.EnergyForce_swigregister
EnergyForce_swigregister(EnergyForce)

class IEpsISigExpAtom(AtomID):
    """Proxy of C++ IEpsISigExpAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEpsISigExpAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEpsISigExpAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.IEpsISigExpAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.IEpsISigExpAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.IEpsISigExpAtom_epsilons_get, _sim2d.IEpsISigExpAtom_epsilons_set)
    __swig_setmethods__["sigmas"] = _sim2d.IEpsISigExpAtom_sigmas_set
    __swig_getmethods__["sigmas"] = _sim2d.IEpsISigExpAtom_sigmas_get
    if _newclass:
        sigmas = _swig_property(_sim2d.IEpsISigExpAtom_sigmas_get, _sim2d.IEpsISigExpAtom_sigmas_set)
    __swig_setmethods__["exponent"] = _sim2d.IEpsISigExpAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.IEpsISigExpAtom_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.IEpsISigExpAtom_exponent_get, _sim2d.IEpsISigExpAtom_exponent_set)
    __swig_setmethods__["indx"] = _sim2d.IEpsISigExpAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.IEpsISigExpAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.IEpsISigExpAtom_indx_get, _sim2d.IEpsISigExpAtom_indx_set)

    def __init__(self, *args):
        """
        __init__(IEpsISigExpAtom self) -> IEpsISigExpAtom
        __init__(IEpsISigExpAtom self, AtomID a, dvector epsilons, dvector sigmas, uint indx, flt exponent=2.5) -> IEpsISigExpAtom
        __init__(IEpsISigExpAtom self, AtomID a, dvector epsilons, dvector sigmas, uint indx) -> IEpsISigExpAtom
        __init__(IEpsISigExpAtom self, AtomID a, IEpsISigCutAtom other) -> IEpsISigExpAtom
        """
        this = _sim2d.new_IEpsISigExpAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_epsilon(self, other: 'IEpsISigExpAtom') -> "flt":
        """get_epsilon(IEpsISigExpAtom self, IEpsISigExpAtom other) -> flt"""
        return _sim2d.IEpsISigExpAtom_get_epsilon(self, other)


    def get_sigma(self, other: 'IEpsISigExpAtom') -> "flt":
        """get_sigma(IEpsISigExpAtom self, IEpsISigExpAtom other) -> flt"""
        return _sim2d.IEpsISigExpAtom_get_sigma(self, other)


    def max_size(self) -> "flt":
        """max_size(IEpsISigExpAtom self) -> flt"""
        return _sim2d.IEpsISigExpAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_IEpsISigExpAtom
    __del__ = lambda self: None
IEpsISigExpAtom_swigregister = _sim2d.IEpsISigExpAtom_swigregister
IEpsISigExpAtom_swigregister(IEpsISigExpAtom)

class RepulsionPair(_object):
    """Proxy of C++ RepulsionPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RepulsionPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RepulsionPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.RepulsionPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.RepulsionPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.RepulsionPair_eps_get, _sim2d.RepulsionPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.RepulsionPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.RepulsionPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.RepulsionPair_sig_get, _sim2d.RepulsionPair_sig_set)
    __swig_setmethods__["exponent"] = _sim2d.RepulsionPair_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.RepulsionPair_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.RepulsionPair_exponent_get, _sim2d.RepulsionPair_exponent_set)
    __swig_setmethods__["atom1"] = _sim2d.RepulsionPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.RepulsionPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.RepulsionPair_atom1_get, _sim2d.RepulsionPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.RepulsionPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.RepulsionPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.RepulsionPair_atom2_get, _sim2d.RepulsionPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(RepulsionPair self, EpsSigExpAtom a1, EpsSigExpAtom a2) -> RepulsionPair
        __init__(RepulsionPair self, IEpsISigExpAtom a1, IEpsISigExpAtom a2) -> RepulsionPair
        """
        this = _sim2d.new_RepulsionPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(RepulsionPair self, Box box) -> flt"""
        return _sim2d.RepulsionPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(RepulsionPair self, Box box) -> Vec"""
        return _sim2d.RepulsionPair_forces(self, box)


    def get_energy_forces(self, box: 'Box') -> "EnergyForce":
        """get_energy_forces(RepulsionPair self, Box box) -> EnergyForce"""
        return _sim2d.RepulsionPair_get_energy_forces(self, box)


    def fill(self, box: 'Box', fpair: 'ForcePairX') -> "void":
        """fill(RepulsionPair self, Box box, ForcePairX fpair)"""
        return _sim2d.RepulsionPair_fill(self, box, fpair)

    __swig_destroy__ = _sim2d.delete_RepulsionPair
    __del__ = lambda self: None
RepulsionPair_swigregister = _sim2d.RepulsionPair_swigregister
RepulsionPair_swigregister(RepulsionPair)

class EpsSigExpDragAtom(AtomID):
    """Proxy of C++ EpsSigExpDragAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EpsSigExpDragAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EpsSigExpDragAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.EpsSigExpDragAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.EpsSigExpDragAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.EpsSigExpDragAtom_eps_get, _sim2d.EpsSigExpDragAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.EpsSigExpDragAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.EpsSigExpDragAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.EpsSigExpDragAtom_sigma_get, _sim2d.EpsSigExpDragAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.EpsSigExpDragAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.EpsSigExpDragAtom_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.EpsSigExpDragAtom_exponent_get, _sim2d.EpsSigExpDragAtom_exponent_set)
    __swig_setmethods__["gamma"] = _sim2d.EpsSigExpDragAtom_gamma_set
    __swig_getmethods__["gamma"] = _sim2d.EpsSigExpDragAtom_gamma_get
    if _newclass:
        gamma = _swig_property(_sim2d.EpsSigExpDragAtom_gamma_get, _sim2d.EpsSigExpDragAtom_gamma_set)

    def __init__(self, *args):
        """
        __init__(EpsSigExpDragAtom self) -> EpsSigExpDragAtom
        __init__(EpsSigExpDragAtom self, AtomID a, flt eps, flt sigma, flt gamma, flt exponent=2.5) -> EpsSigExpDragAtom
        __init__(EpsSigExpDragAtom self, AtomID a, flt eps, flt sigma, flt gamma) -> EpsSigExpDragAtom
        __init__(EpsSigExpDragAtom self, AtomID a, EpsSigExpDragAtom other) -> EpsSigExpDragAtom
        """
        this = _sim2d.new_EpsSigExpDragAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_size(self) -> "flt":
        """max_size(EpsSigExpDragAtom self) -> flt"""
        return _sim2d.EpsSigExpDragAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_EpsSigExpDragAtom
    __del__ = lambda self: None
EpsSigExpDragAtom_swigregister = _sim2d.EpsSigExpDragAtom_swigregister
EpsSigExpDragAtom_swigregister(EpsSigExpDragAtom)

class RepulsionDragPair(_object):
    """Proxy of C++ RepulsionDragPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RepulsionDragPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RepulsionDragPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.RepulsionDragPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.RepulsionDragPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.RepulsionDragPair_eps_get, _sim2d.RepulsionDragPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.RepulsionDragPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.RepulsionDragPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.RepulsionDragPair_sig_get, _sim2d.RepulsionDragPair_sig_set)
    __swig_setmethods__["exponent"] = _sim2d.RepulsionDragPair_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.RepulsionDragPair_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.RepulsionDragPair_exponent_get, _sim2d.RepulsionDragPair_exponent_set)
    __swig_setmethods__["gamma"] = _sim2d.RepulsionDragPair_gamma_set
    __swig_getmethods__["gamma"] = _sim2d.RepulsionDragPair_gamma_get
    if _newclass:
        gamma = _swig_property(_sim2d.RepulsionDragPair_gamma_get, _sim2d.RepulsionDragPair_gamma_set)
    __swig_setmethods__["atom1"] = _sim2d.RepulsionDragPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.RepulsionDragPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.RepulsionDragPair_atom1_get, _sim2d.RepulsionDragPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.RepulsionDragPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.RepulsionDragPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.RepulsionDragPair_atom2_get, _sim2d.RepulsionDragPair_atom2_set)

    def __init__(self, a1: 'EpsSigExpDragAtom', a2: 'EpsSigExpDragAtom'):
        """__init__(RepulsionDragPair self, EpsSigExpDragAtom a1, EpsSigExpDragAtom a2) -> RepulsionDragPair"""
        this = _sim2d.new_RepulsionDragPair(a1, a2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(RepulsionDragPair self, Box box) -> flt"""
        return _sim2d.RepulsionDragPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(RepulsionDragPair self, Box box) -> Vec"""
        return _sim2d.RepulsionDragPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_RepulsionDragPair
    __del__ = lambda self: None
RepulsionDragPair_swigregister = _sim2d.RepulsionDragPair_swigregister
RepulsionDragPair_swigregister(RepulsionDragPair)

class LoisOhernAtom(AtomID):
    """Proxy of C++ LoisOhernAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisOhernAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisOhernAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisOhernAtom_eps_get, _sim2d.LoisOhernAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.LoisOhernAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LoisOhernAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LoisOhernAtom_sigma_get, _sim2d.LoisOhernAtom_sigma_set)
    __swig_setmethods__["C"] = _sim2d.LoisOhernAtom_C_set
    __swig_getmethods__["C"] = _sim2d.LoisOhernAtom_C_get
    if _newclass:
        C = _swig_property(_sim2d.LoisOhernAtom_C_get, _sim2d.LoisOhernAtom_C_set)
    __swig_setmethods__["l"] = _sim2d.LoisOhernAtom_l_set
    __swig_getmethods__["l"] = _sim2d.LoisOhernAtom_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisOhernAtom_l_get, _sim2d.LoisOhernAtom_l_set)

    def __init__(self, *args):
        """
        __init__(LoisOhernAtom self) -> LoisOhernAtom
        __init__(LoisOhernAtom self, AtomID a, flt eps, flt sigma, flt C, flt l) -> LoisOhernAtom
        __init__(LoisOhernAtom self, AtomID a, LoisOhernAtom other) -> LoisOhernAtom
        """
        this = _sim2d.new_LoisOhernAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_size(self) -> "flt":
        """max_size(LoisOhernAtom self) -> flt"""
        return _sim2d.LoisOhernAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_LoisOhernAtom
    __del__ = lambda self: None
LoisOhernAtom_swigregister = _sim2d.LoisOhernAtom_swigregister
LoisOhernAtom_swigregister(LoisOhernAtom)

class LoisOhernPair(_object):
    """Proxy of C++ LoisOhernPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisOhernPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisOhernPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisOhernPair_eps_get, _sim2d.LoisOhernPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.LoisOhernPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LoisOhernPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LoisOhernPair_sig_get, _sim2d.LoisOhernPair_sig_set)
    __swig_setmethods__["C"] = _sim2d.LoisOhernPair_C_set
    __swig_getmethods__["C"] = _sim2d.LoisOhernPair_C_get
    if _newclass:
        C = _swig_property(_sim2d.LoisOhernPair_C_get, _sim2d.LoisOhernPair_C_set)
    __swig_setmethods__["l"] = _sim2d.LoisOhernPair_l_set
    __swig_getmethods__["l"] = _sim2d.LoisOhernPair_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisOhernPair_l_get, _sim2d.LoisOhernPair_l_set)
    __swig_setmethods__["sigcut"] = _sim2d.LoisOhernPair_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LoisOhernPair_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LoisOhernPair_sigcut_get, _sim2d.LoisOhernPair_sigcut_set)
    __swig_setmethods__["atom1"] = _sim2d.LoisOhernPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LoisOhernPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LoisOhernPair_atom1_get, _sim2d.LoisOhernPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LoisOhernPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LoisOhernPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LoisOhernPair_atom2_get, _sim2d.LoisOhernPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LoisOhernPair self, LoisOhernAtom a1, LoisOhernAtom a2) -> LoisOhernPair
        __init__(LoisOhernPair self, LoisOhernAtom a1, LoisOhernAtom a2, flt eps, flt sig, flt C, flt l) -> LoisOhernPair
        """
        this = _sim2d.new_LoisOhernPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LoisOhernPair self, Box box) -> flt"""
        return _sim2d.LoisOhernPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LoisOhernPair self, Box box) -> Vec"""
        return _sim2d.LoisOhernPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LoisOhernPair
    __del__ = lambda self: None
LoisOhernPair_swigregister = _sim2d.LoisOhernPair_swigregister
LoisOhernPair_swigregister(LoisOhernPair)

class LoisOhernPairMinCLs(LoisOhernPair):
    """Proxy of C++ LoisOhernPairMinCLs class."""

    __swig_setmethods__ = {}
    for _s in [LoisOhernPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernPairMinCLs, name, value)
    __swig_getmethods__ = {}
    for _s in [LoisOhernPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernPairMinCLs, name)
    __repr__ = _swig_repr

    def __init__(self, a1: 'LoisOhernAtom', a2: 'LoisOhernAtom'):
        """__init__(LoisOhernPairMinCLs self, LoisOhernAtom a1, LoisOhernAtom a2) -> LoisOhernPairMinCLs"""
        this = _sim2d.new_LoisOhernPairMinCLs(a1, a2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_LoisOhernPairMinCLs
    __del__ = lambda self: None
LoisOhernPairMinCLs_swigregister = _sim2d.LoisOhernPairMinCLs_swigregister
LoisOhernPairMinCLs_swigregister(LoisOhernPairMinCLs)

class LoisLinAtom(AtomID):
    """Proxy of C++ LoisLinAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomID]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomID]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisLinAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisLinAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisLinAtom_eps_get, _sim2d.LoisLinAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.LoisLinAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LoisLinAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LoisLinAtom_sigma_get, _sim2d.LoisLinAtom_sigma_set)
    __swig_setmethods__["f"] = _sim2d.LoisLinAtom_f_set
    __swig_getmethods__["f"] = _sim2d.LoisLinAtom_f_get
    if _newclass:
        f = _swig_property(_sim2d.LoisLinAtom_f_get, _sim2d.LoisLinAtom_f_set)
    __swig_setmethods__["l"] = _sim2d.LoisLinAtom_l_set
    __swig_getmethods__["l"] = _sim2d.LoisLinAtom_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisLinAtom_l_get, _sim2d.LoisLinAtom_l_set)

    def __init__(self, *args):
        """
        __init__(LoisLinAtom self) -> LoisLinAtom
        __init__(LoisLinAtom self, AtomID a, flt eps, flt sigma, flt depth, flt width) -> LoisLinAtom
        __init__(LoisLinAtom self, AtomID a, LoisLinAtom other) -> LoisLinAtom
        """
        this = _sim2d.new_LoisLinAtom(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_size(self) -> "flt":
        """max_size(LoisLinAtom self) -> flt"""
        return _sim2d.LoisLinAtom_max_size(self)

    __swig_destroy__ = _sim2d.delete_LoisLinAtom
    __del__ = lambda self: None
LoisLinAtom_swigregister = _sim2d.LoisLinAtom_swigregister
LoisLinAtom_swigregister(LoisLinAtom)

class LoisLinPair(_object):
    """Proxy of C++ LoisLinPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisLinPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisLinPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisLinPair_eps_get, _sim2d.LoisLinPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.LoisLinPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LoisLinPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LoisLinPair_sig_get, _sim2d.LoisLinPair_sig_set)
    __swig_setmethods__["f"] = _sim2d.LoisLinPair_f_set
    __swig_getmethods__["f"] = _sim2d.LoisLinPair_f_get
    if _newclass:
        f = _swig_property(_sim2d.LoisLinPair_f_get, _sim2d.LoisLinPair_f_set)
    __swig_setmethods__["l"] = _sim2d.LoisLinPair_l_set
    __swig_getmethods__["l"] = _sim2d.LoisLinPair_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisLinPair_l_get, _sim2d.LoisLinPair_l_set)
    __swig_setmethods__["sigcut"] = _sim2d.LoisLinPair_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LoisLinPair_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LoisLinPair_sigcut_get, _sim2d.LoisLinPair_sigcut_set)
    __swig_setmethods__["atom1"] = _sim2d.LoisLinPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LoisLinPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LoisLinPair_atom1_get, _sim2d.LoisLinPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LoisLinPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LoisLinPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LoisLinPair_atom2_get, _sim2d.LoisLinPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LoisLinPair self, LoisLinAtom a1, LoisLinAtom a2) -> LoisLinPair
        __init__(LoisLinPair self, LoisLinAtom a1, LoisLinAtom a2, flt eps, flt sig, flt f, flt l) -> LoisLinPair
        """
        this = _sim2d.new_LoisLinPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LoisLinPair self, Box box) -> flt"""
        return _sim2d.LoisLinPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LoisLinPair self, Box box) -> Vec"""
        return _sim2d.LoisLinPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LoisLinPair
    __del__ = lambda self: None
LoisLinPair_swigregister = _sim2d.LoisLinPair_swigregister
LoisLinPair_swigregister(LoisLinPair)

class LoisLinPairMin(LoisLinPair):
    """Proxy of C++ LoisLinPairMin class."""

    __swig_setmethods__ = {}
    for _s in [LoisLinPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinPairMin, name, value)
    __swig_getmethods__ = {}
    for _s in [LoisLinPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinPairMin, name)
    __repr__ = _swig_repr

    def __init__(self, a1: 'LoisLinAtom', a2: 'LoisLinAtom'):
        """__init__(LoisLinPairMin self, LoisLinAtom a1, LoisLinAtom a2) -> LoisLinPairMin"""
        this = _sim2d.new_LoisLinPairMin(a1, a2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_LoisLinPairMin
    __del__ = lambda self: None
LoisLinPairMin_swigregister = _sim2d.LoisLinPairMin_swigregister
LoisLinPairMin_swigregister(LoisLinPairMin)

class Charges(Interaction):
    """Proxy of C++ Charges class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charges, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charges, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Charges self, flt screenlength, flt k=1, std::vector< Charged > atms) -> Charges
        __init__(Charges self, flt screenlength, flt k=1) -> Charges
        __init__(Charges self, flt screenlength) -> Charges
        """
        this = _sim2d.new_Charges(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(Charges self, Charged a)
        add(Charges self, AtomID a, flt q)
        """
        return _sim2d.Charges_add(self, *args)


    def ignore(self, *args) -> "void":
        """
        ignore(Charges self, AtomID a, AtomID b)
        ignore(Charges self, Atom a, Atom b)
        """
        return _sim2d.Charges_ignore(self, *args)


    def ignore_size(self) -> "uint":
        """ignore_size(Charges self) -> uint"""
        return _sim2d.Charges_ignore_size(self)


    def size(self) -> "uint":
        """size(Charges self) -> uint"""
        return _sim2d.Charges_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(Charges self, Box box) -> flt"""
        return _sim2d.Charges_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(Charges self, Box box) -> flt"""
        return _sim2d.Charges_pressure(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(Charges self, Box box)"""
        return _sim2d.Charges_set_forces(self, box)

    __swig_destroy__ = _sim2d.delete_Charges
    __del__ = lambda self: None
Charges_swigregister = _sim2d.Charges_swigregister
Charges_swigregister(Charges)

class WallAtom(AtomRef):
    """Proxy of C++ WallAtom class."""

    __swig_setmethods__ = {}
    for _s in [AtomRef]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WallAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomRef]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WallAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sigma"] = _sim2d.WallAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.WallAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.WallAtom_sigma_get, _sim2d.WallAtom_sigma_set)
    __swig_setmethods__["epsilon"] = _sim2d.WallAtom_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.WallAtom_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.WallAtom_epsilon_get, _sim2d.WallAtom_epsilon_set)

    def __init__(self, a: 'AtomID', sigma: 'flt', epsilon: 'flt'=1.0):
        """
        __init__(WallAtom self, AtomID a, flt sigma, flt epsilon=1.0) -> WallAtom
        __init__(WallAtom self, AtomID a, flt sigma) -> WallAtom
        """
        this = _sim2d.new_WallAtom(a, sigma, epsilon)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_WallAtom
    __del__ = lambda self: None
WallAtom_swigregister = _sim2d.WallAtom_swigregister
WallAtom_swigregister(WallAtom)

class SoftWall(Interaction):
    """Proxy of C++ SoftWall class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftWall, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SoftWall, name)
    __repr__ = _swig_repr

    def __init__(self, loc: 'Vec', norm: 'Vec', expt: 'flt'=2.0):
        """
        __init__(SoftWall self, Vec loc, Vec norm, flt expt=2.0) -> SoftWall
        __init__(SoftWall self, Vec loc, Vec norm) -> SoftWall
        """
        this = _sim2d.new_SoftWall(loc, norm, expt)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, a: 'WallAtom') -> "void":
        """add(SoftWall self, WallAtom a)"""
        return _sim2d.SoftWall_add(self, a)


    def energy(self, box: 'Box') -> "flt":
        """energy(SoftWall self, Box box) -> flt"""
        return _sim2d.SoftWall_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(SoftWall self, Box box)"""
        return _sim2d.SoftWall_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(SoftWall self, Box box) -> flt"""
        return _sim2d.SoftWall_set_forces_get_pressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(SoftWall self, Box box) -> flt"""
        return _sim2d.SoftWall_pressure(self, box)


    def set_location(self, newloc: 'Vec') -> "void":
        """set_location(SoftWall self, Vec newloc)"""
        return _sim2d.SoftWall_set_location(self, newloc)


    def get_location(self) -> "Vec":
        """get_location(SoftWall self) -> Vec"""
        return _sim2d.SoftWall_get_location(self)


    def set_normal(self, newNorm: 'Vec') -> "void":
        """set_normal(SoftWall self, Vec newNorm)"""
        return _sim2d.SoftWall_set_normal(self, newNorm)


    def get_normal(self) -> "Vec":
        """get_normal(SoftWall self) -> Vec"""
        return _sim2d.SoftWall_get_normal(self)


    def get_last_f(self) -> "flt":
        """get_last_f(SoftWall self) -> flt"""
        return _sim2d.SoftWall_get_last_f(self)

    __swig_destroy__ = _sim2d.delete_SoftWall
    __del__ = lambda self: None
SoftWall_swigregister = _sim2d.SoftWall_swigregister
SoftWall_swigregister(SoftWall)

class SoftWallCylinder(Interaction):
    """Proxy of C++ SoftWallCylinder class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftWallCylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SoftWallCylinder, name)
    __repr__ = _swig_repr

    def __init__(self, loc: 'Vec', axis: 'Vec', radius: 'flt', expt: 'flt'=2.0):
        """
        __init__(SoftWallCylinder self, Vec loc, Vec axis, flt radius, flt expt=2.0) -> SoftWallCylinder
        __init__(SoftWallCylinder self, Vec loc, Vec axis, flt radius) -> SoftWallCylinder
        """
        this = _sim2d.new_SoftWallCylinder(loc, axis, radius, expt)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, a: 'WallAtom') -> "void":
        """add(SoftWallCylinder self, WallAtom a)"""
        return _sim2d.SoftWallCylinder_add(self, a)


    def energy(self, box: 'Box') -> "flt":
        """energy(SoftWallCylinder self, Box box) -> flt"""
        return _sim2d.SoftWallCylinder_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(SoftWallCylinder self, Box box)"""
        return _sim2d.SoftWallCylinder_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(SoftWallCylinder self, Box box) -> flt"""
        return _sim2d.SoftWallCylinder_set_forces_get_pressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(SoftWallCylinder self, Box box) -> flt"""
        return _sim2d.SoftWallCylinder_pressure(self, box)


    def set_location(self, new_loc: 'Vec') -> "void":
        """set_location(SoftWallCylinder self, Vec new_loc)"""
        return _sim2d.SoftWallCylinder_set_location(self, new_loc)


    def get_location(self) -> "Vec":
        """get_location(SoftWallCylinder self) -> Vec"""
        return _sim2d.SoftWallCylinder_get_location(self)


    def set_axis(self, new_axis: 'Vec') -> "void":
        """set_axis(SoftWallCylinder self, Vec new_axis)"""
        return _sim2d.SoftWallCylinder_set_axis(self, new_axis)


    def get_axis(self) -> "Vec":
        """get_axis(SoftWallCylinder self) -> Vec"""
        return _sim2d.SoftWallCylinder_get_axis(self)


    def get_last_f(self) -> "flt":
        """get_last_f(SoftWallCylinder self) -> flt"""
        return _sim2d.SoftWallCylinder_get_last_f(self)

    __swig_destroy__ = _sim2d.delete_SoftWallCylinder
    __del__ = lambda self: None
SoftWallCylinder_swigregister = _sim2d.SoftWallCylinder_swigregister
SoftWallCylinder_swigregister(SoftWallCylinder)

class WalledBox2D(OriginBox):
    """Proxy of C++ WalledBox2D class."""

    __swig_setmethods__ = {}
    for _s in [OriginBox]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WalledBox2D, name, value)
    __swig_getmethods__ = {}
    for _s in [OriginBox]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WalledBox2D, name)
    __repr__ = _swig_repr

    def __init__(self, size: 'Vec', xwalled: 'bool', ywalled: 'bool', expt: 'flt'=2.0):
        """
        __init__(WalledBox2D self, Vec size, bool xwalled, bool ywalled, flt expt=2.0) -> WalledBox2D
        __init__(WalledBox2D self, Vec size, bool xwalled, bool ywalled) -> WalledBox2D
        """
        this = _sim2d.new_WalledBox2D(size, xwalled, ywalled, expt)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def diff(self, *args) -> "Vec":
        """
        diff(WalledBox2D self, Vec r1, Vec r2) -> Vec
        diff(WalledBox2D self, Vec r1, Vec r2, boost::array< int,2 > boxes) -> Vec
        """
        return _sim2d.WalledBox2D_diff(self, *args)


    def V(self) -> "flt":
        """V(WalledBox2D self) -> flt"""
        return _sim2d.WalledBox2D_V(self)


    def L(self) -> "flt":
        """L(WalledBox2D self) -> flt"""
        return _sim2d.WalledBox2D_L(self)


    def resize(self, factor: 'flt') -> "flt":
        """resize(WalledBox2D self, flt factor) -> flt"""
        return _sim2d.WalledBox2D_resize(self, factor)


    def resize_to_V(self, newV: 'flt') -> "flt":
        """resize_to_V(WalledBox2D self, flt newV) -> flt"""
        return _sim2d.WalledBox2D_resize_to_V(self, newV)


    def rand_loc(self, walldist: 'flt') -> "Vec":
        """rand_loc(WalledBox2D self, flt walldist) -> Vec"""
        return _sim2d.WalledBox2D_rand_loc(self, walldist)


    def get_walls(self) -> "std::vector< SoftWall * >":
        """get_walls(WalledBox2D self) -> std::vector< SoftWall * >"""
        return _sim2d.WalledBox2D_get_walls(self)

    __swig_destroy__ = _sim2d.delete_WalledBox2D
    __del__ = lambda self: None
WalledBox2D_swigregister = _sim2d.WalledBox2D_swigregister
WalledBox2D_swigregister(WalledBox2D)


def confine_range(minimum: 'flt', val: 'flt', maximum: 'flt') -> "flt":
    """confine_range(flt minimum, flt val, flt maximum) -> flt"""
    return _sim2d.confine_range(minimum, val, maximum)
class SCAtomVec(AtomGroup):
    """Proxy of C++ SCAtomVec class."""

    __swig_setmethods__ = {}
    for _s in [AtomGroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCAtomVec, name, value)
    __swig_getmethods__ = {}
    for _s in [AtomGroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCAtomVec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SCAtomVec self, dvector masses) -> SCAtomVec
        __init__(SCAtomVec self, uint N, flt mass) -> SCAtomVec
        """
        this = _sim2d.new_SCAtomVec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def vec(self) -> "AtomVec &":
        """vec(SCAtomVec self) -> AtomVec"""
        return _sim2d.SCAtomVec_vec(self)


    def get_id(self, n: 'cuint') -> "AtomID":
        """get_id(SCAtomVec self, cuint n) -> AtomID"""
        return _sim2d.SCAtomVec_get_id(self, n)


    def pair(self, n: 'cuint') -> "IDPair":
        """pair(SCAtomVec self, cuint n) -> IDPair"""
        return _sim2d.SCAtomVec_pair(self, n)


    def size(self) -> "uint":
        """size(SCAtomVec self) -> uint"""
        return _sim2d.SCAtomVec_size(self)


    def pairs(self) -> "uint":
        """pairs(SCAtomVec self) -> uint"""
        return _sim2d.SCAtomVec_pairs(self)


    def volume(diameter: 'flt', length: 'flt', dim: 'uint'=2) -> "flt":
        """
        volume(flt diameter, flt length, uint dim=2) -> flt
        volume(flt diameter, flt length) -> flt
        """
        return _sim2d.SCAtomVec_volume(diameter, length, dim)

    if _newclass:
        volume = staticmethod(volume)
    __swig_getmethods__["volume"] = lambda x: volume
    __swig_destroy__ = _sim2d.delete_SCAtomVec
    __del__ = lambda self: None

    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def all_pairs(self):
        for i in range(self.pairs()):
            yield self.pair(i)

    def __len__(self):
        return self.size()

    def __getitem__(self, obj):
        return self.get_id(obj)

    def __str__(self):
        return str(list(self))

SCAtomVec_swigregister = _sim2d.SCAtomVec_swigregister
SCAtomVec_swigregister(SCAtomVec)

def SCAtomVec_volume(diameter: 'flt', length: 'flt', dim: 'uint'=2) -> "flt":
    """
    volume(flt diameter, flt length, uint dim=2) -> flt
    SCAtomVec_volume(flt diameter, flt length) -> flt
    """
    return _sim2d.SCAtomVec_volume(diameter, length, dim)

class SpheroCylinderDiff(_object):
    """Proxy of C++ SpheroCylinderDiff class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpheroCylinderDiff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpheroCylinderDiff, name)
    __repr__ = _swig_repr
    __swig_setmethods__["delta"] = _sim2d.SpheroCylinderDiff_delta_set
    __swig_getmethods__["delta"] = _sim2d.SpheroCylinderDiff_delta_get
    if _newclass:
        delta = _swig_property(_sim2d.SpheroCylinderDiff_delta_get, _sim2d.SpheroCylinderDiff_delta_set)
    __swig_setmethods__["r"] = _sim2d.SpheroCylinderDiff_r_set
    __swig_getmethods__["r"] = _sim2d.SpheroCylinderDiff_r_get
    if _newclass:
        r = _swig_property(_sim2d.SpheroCylinderDiff_r_get, _sim2d.SpheroCylinderDiff_r_set)
    __swig_setmethods__["lambda1"] = _sim2d.SpheroCylinderDiff_lambda1_set
    __swig_getmethods__["lambda1"] = _sim2d.SpheroCylinderDiff_lambda1_get
    if _newclass:
        lambda1 = _swig_property(_sim2d.SpheroCylinderDiff_lambda1_get, _sim2d.SpheroCylinderDiff_lambda1_set)
    __swig_setmethods__["lambda2"] = _sim2d.SpheroCylinderDiff_lambda2_set
    __swig_getmethods__["lambda2"] = _sim2d.SpheroCylinderDiff_lambda2_get
    if _newclass:
        lambda2 = _swig_property(_sim2d.SpheroCylinderDiff_lambda2_get, _sim2d.SpheroCylinderDiff_lambda2_set)

    def __init__(self):
        """__init__(SpheroCylinderDiff self) -> SpheroCylinderDiff"""
        this = _sim2d.new_SpheroCylinderDiff()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_SpheroCylinderDiff
    __del__ = lambda self: None
SpheroCylinderDiff_swigregister = _sim2d.SpheroCylinderDiff_swigregister
SpheroCylinderDiff_swigregister(SpheroCylinderDiff)

class SCPair(_object):
    """Proxy of C++ SCPair class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SCPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["p1"] = _sim2d.SCPair_p1_set
    __swig_getmethods__["p1"] = _sim2d.SCPair_p1_get
    if _newclass:
        p1 = _swig_property(_sim2d.SCPair_p1_get, _sim2d.SCPair_p1_set)
    __swig_setmethods__["p2"] = _sim2d.SCPair_p2_set
    __swig_getmethods__["p2"] = _sim2d.SCPair_p2_get
    if _newclass:
        p2 = _swig_property(_sim2d.SCPair_p2_get, _sim2d.SCPair_p2_set)
    __swig_setmethods__["l1"] = _sim2d.SCPair_l1_set
    __swig_getmethods__["l1"] = _sim2d.SCPair_l1_get
    if _newclass:
        l1 = _swig_property(_sim2d.SCPair_l1_get, _sim2d.SCPair_l1_set)
    __swig_setmethods__["l2"] = _sim2d.SCPair_l2_set
    __swig_getmethods__["l2"] = _sim2d.SCPair_l2_get
    if _newclass:
        l2 = _swig_property(_sim2d.SCPair_l2_get, _sim2d.SCPair_l2_set)

    def __init__(self, *args):
        """
        __init__(SCPair self, IDPair p1, IDPair p2, flt l1, flt l2) -> SCPair
        __init__(SCPair self, IDPair p1, IDPair p2, flt l) -> SCPair
        __init__(SCPair self, SCPair other) -> SCPair
        """
        this = _sim2d.new_SCPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def nearest_location(self, box: 'Box') -> "SpheroCylinderDiff":
        """nearest_location(SCPair self, Box box) -> SpheroCylinderDiff"""
        return _sim2d.SCPair_nearest_location(self, box)


    def apply_force(self, *args) -> "void":
        """
        apply_force(SCPair self, Box box, Vec f, SpheroCylinderDiff diff, flt I1, flt I2)
        apply_force(SCPair self, Box box, Vec f, SpheroCylinderDiff diff, flt I)
        """
        return _sim2d.SCPair_apply_force(self, *args)

    __swig_destroy__ = _sim2d.delete_SCPair
    __del__ = lambda self: None
SCPair_swigregister = _sim2d.SCPair_swigregister
SCPair_swigregister(SCPair)

class SCSpringPair(SCPair):
    """Proxy of C++ SCSpringPair class."""

    __swig_setmethods__ = {}
    for _s in [SCPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCSpringPair, name, value)
    __swig_getmethods__ = {}
    for _s in [SCPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCSpringPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.SCSpringPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.SCSpringPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.SCSpringPair_eps_get, _sim2d.SCSpringPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.SCSpringPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.SCSpringPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.SCSpringPair_sig_get, _sim2d.SCSpringPair_sig_set)

    def __init__(self, *args):
        """
        __init__(SCSpringPair self, IDPair p1, IDPair p2, flt eps, flt sig, flt l1, flt l2) -> SCSpringPair
        __init__(SCSpringPair self, IDPair p1, IDPair p2, flt eps, flt sig, flt l) -> SCSpringPair
        """
        this = _sim2d.new_SCSpringPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def max_dist(self) -> "flt":
        """max_dist(SCSpringPair self) -> flt"""
        return _sim2d.SCSpringPair_max_dist(self)


    def max_delta(self) -> "flt":
        """max_delta(SCSpringPair self) -> flt"""
        return _sim2d.SCSpringPair_max_delta(self)


    def energy(self, box: 'Box', diff: 'SpheroCylinderDiff') -> "flt":
        """energy(SCSpringPair self, Box box, SpheroCylinderDiff diff) -> flt"""
        return _sim2d.SCSpringPair_energy(self, box, diff)


    def forces(self, box: 'Box', diff: 'SpheroCylinderDiff') -> "Vec":
        """forces(SCSpringPair self, Box box, SpheroCylinderDiff diff) -> Vec"""
        return _sim2d.SCSpringPair_forces(self, box, diff)

    __swig_destroy__ = _sim2d.delete_SCSpringPair
    __del__ = lambda self: None
SCSpringPair_swigregister = _sim2d.SCSpringPair_swigregister
SCSpringPair_swigregister(SCSpringPair)

class SCSpringList(Interaction):
    """Proxy of C++ SCSpringList class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCSpringList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCSpringList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SCSpringList self, SCAtomVec scs, flt eps, flt sig, flt l) -> SCSpringList
        __init__(SCSpringList self, SCAtomVec scs, flt eps, flt sig, dvector ls) -> SCSpringList
        """
        this = _sim2d.new_SCSpringList(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(SCSpringList self, Box box) -> flt"""
        return _sim2d.SCSpringList_energy(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(SCSpringList self, Box box)"""
        return _sim2d.SCSpringList_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(SCSpringList self, Box box) -> flt"""
        return _sim2d.SCSpringList_set_forces_get_pressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(SCSpringList self, Box box) -> flt"""
        return _sim2d.SCSpringList_pressure(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(SCSpringList self, Box box) -> Matrix"""
        return _sim2d.SCSpringList_set_forces_get_stress(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(SCSpringList self, Box box) -> Matrix"""
        return _sim2d.SCSpringList_stress(self, box)


    def volume(self) -> "flt":
        """volume(SCSpringList self) -> flt"""
        return _sim2d.SCSpringList_volume(self)


    def phi(self, box: 'Box') -> "flt":
        """phi(SCSpringList self, Box box) -> flt"""
        return _sim2d.SCSpringList_phi(self, box)


    def ignore(self, *args) -> "void":
        """
        ignore(SCSpringList self, uint n1, uint n2)
        ignore(SCSpringList self, AtomID a1, AtomID a2)
        """
        return _sim2d.SCSpringList_ignore(self, *args)

    __swig_destroy__ = _sim2d.delete_SCSpringList
    __del__ = lambda self: None
SCSpringList_swigregister = _sim2d.SCSpringList_swigregister
SCSpringList_swigregister(SCSpringList)

class Constraint(_object):
    """Proxy of C++ Constraint class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Constraint, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def apply_positions(self, box: 'Box') -> "void":
        """apply_positions(Constraint self, Box box)"""
        return _sim2d.Constraint_apply_positions(self, box)


    def apply_velocities(self, box: 'Box') -> "void":
        """apply_velocities(Constraint self, Box box)"""
        return _sim2d.Constraint_apply_velocities(self, box)


    def apply_forces(self, box: 'Box') -> "void":
        """apply_forces(Constraint self, Box box)"""
        return _sim2d.Constraint_apply_forces(self, box)


    def constrained_dof(self) -> "int":
        """constrained_dof(Constraint self) -> int"""
        return _sim2d.Constraint_constrained_dof(self)

    __swig_destroy__ = _sim2d.delete_Constraint
    __del__ = lambda self: None
Constraint_swigregister = _sim2d.Constraint_swigregister
Constraint_swigregister(Constraint)

class CoordConstraint(Constraint):
    """Proxy of C++ CoordConstraint class."""

    __swig_setmethods__ = {}
    for _s in [Constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoordConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [Constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoordConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CoordConstraint self, Atom atm, bool fixx, bool fixy, bool fixz, Vec loc) -> CoordConstraint
        __init__(CoordConstraint self, Atom atm, bool fixx, bool fixy, bool fixz) -> CoordConstraint
        __init__(CoordConstraint self, Atom atm) -> CoordConstraint
        """
        this = _sim2d.new_CoordConstraint(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def constrained_dof(self) -> "int":
        """constrained_dof(CoordConstraint self) -> int"""
        return _sim2d.CoordConstraint_constrained_dof(self)


    def apply_positions(self, box: 'Box') -> "void":
        """apply_positions(CoordConstraint self, Box box)"""
        return _sim2d.CoordConstraint_apply_positions(self, box)


    def apply_velocities(self, box: 'Box') -> "void":
        """apply_velocities(CoordConstraint self, Box box)"""
        return _sim2d.CoordConstraint_apply_velocities(self, box)


    def apply_forces(self, box: 'Box') -> "void":
        """apply_forces(CoordConstraint self, Box box)"""
        return _sim2d.CoordConstraint_apply_forces(self, box)

    __swig_destroy__ = _sim2d.delete_CoordConstraint
    __del__ = lambda self: None
CoordConstraint_swigregister = _sim2d.CoordConstraint_swigregister
CoordConstraint_swigregister(CoordConstraint)

class CoordCOMConstraint(Constraint):
    """Proxy of C++ CoordCOMConstraint class."""

    __swig_setmethods__ = {}
    for _s in [Constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoordCOMConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [Constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoordCOMConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CoordCOMConstraint self, boost::shared_ptr< AtomGroup > atm, bool fixx, bool fixy, bool fixz, Vec loc) -> CoordCOMConstraint
        __init__(CoordCOMConstraint self, boost::shared_ptr< AtomGroup > atm, bool fixx, bool fixy, bool fixz) -> CoordCOMConstraint
        __init__(CoordCOMConstraint self, boost::shared_ptr< AtomGroup > atm) -> CoordCOMConstraint
        """
        this = _sim2d.new_CoordCOMConstraint(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def constrained_dof(self) -> "int":
        """constrained_dof(CoordCOMConstraint self) -> int"""
        return _sim2d.CoordCOMConstraint_constrained_dof(self)


    def apply_positions(self, box: 'Box') -> "void":
        """apply_positions(CoordCOMConstraint self, Box box)"""
        return _sim2d.CoordCOMConstraint_apply_positions(self, box)


    def apply_velocities(self, box: 'Box') -> "void":
        """apply_velocities(CoordCOMConstraint self, Box box)"""
        return _sim2d.CoordCOMConstraint_apply_velocities(self, box)


    def apply_forces(self, box: 'Box') -> "void":
        """apply_forces(CoordCOMConstraint self, Box box)"""
        return _sim2d.CoordCOMConstraint_apply_forces(self, box)

    __swig_destroy__ = _sim2d.delete_CoordCOMConstraint
    __del__ = lambda self: None
CoordCOMConstraint_swigregister = _sim2d.CoordCOMConstraint_swigregister
CoordCOMConstraint_swigregister(CoordCOMConstraint)

class RelativeConstraint(Constraint):
    """Proxy of C++ RelativeConstraint class."""

    __swig_setmethods__ = {}
    for _s in [Constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RelativeConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [Constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RelativeConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(RelativeConstraint self, Atom atm1, Atom atm2, bool fixx, bool fixy, bool fixz, Vec loc) -> RelativeConstraint
        __init__(RelativeConstraint self, Atom atm1, Atom atm2, bool fixx, bool fixy, bool fixz) -> RelativeConstraint
        __init__(RelativeConstraint self, Atom atm1, Atom atm2) -> RelativeConstraint
        """
        this = _sim2d.new_RelativeConstraint(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def constrained_dof(self) -> "int":
        """constrained_dof(RelativeConstraint self) -> int"""
        return _sim2d.RelativeConstraint_constrained_dof(self)


    def apply_positions(self, box: 'Box') -> "void":
        """apply_positions(RelativeConstraint self, Box box)"""
        return _sim2d.RelativeConstraint_apply_positions(self, box)


    def apply_velocities(self, box: 'Box') -> "void":
        """apply_velocities(RelativeConstraint self, Box box)"""
        return _sim2d.RelativeConstraint_apply_velocities(self, box)


    def apply_forces(self, box: 'Box') -> "void":
        """apply_forces(RelativeConstraint self, Box box)"""
        return _sim2d.RelativeConstraint_apply_forces(self, box)

    __swig_destroy__ = _sim2d.delete_RelativeConstraint
    __del__ = lambda self: None
RelativeConstraint_swigregister = _sim2d.RelativeConstraint_swigregister
RelativeConstraint_swigregister(RelativeConstraint)

class DistConstraint(Constraint):
    """Proxy of C++ DistConstraint class."""

    __swig_setmethods__ = {}
    for _s in [Constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [Constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DistConstraint self, AtomID atm1, AtomID atm2, flt dist) -> DistConstraint
        __init__(DistConstraint self, AtomID atm1, AtomID atm2) -> DistConstraint
        """
        this = _sim2d.new_DistConstraint(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def constrained_dof(self) -> "int":
        """constrained_dof(DistConstraint self) -> int"""
        return _sim2d.DistConstraint_constrained_dof(self)


    def apply_positions(self, box: 'Box') -> "void":
        """apply_positions(DistConstraint self, Box box)"""
        return _sim2d.DistConstraint_apply_positions(self, box)


    def apply_velocities(self, box: 'Box') -> "void":
        """apply_velocities(DistConstraint self, Box box)"""
        return _sim2d.DistConstraint_apply_velocities(self, box)


    def apply_forces(self, box: 'Box') -> "void":
        """apply_forces(DistConstraint self, Box box)"""
        return _sim2d.DistConstraint_apply_forces(self, box)

    __swig_destroy__ = _sim2d.delete_DistConstraint
    __del__ = lambda self: None
DistConstraint_swigregister = _sim2d.DistConstraint_swigregister
DistConstraint_swigregister(DistConstraint)

class LinearConstraint(Constraint):
    """Proxy of C++ LinearConstraint class."""

    __swig_setmethods__ = {}
    for _s in [Constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [Constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, atms: 'boost::shared_ptr< AtomGroup >', dist: 'flt'):
        """__init__(LinearConstraint self, boost::shared_ptr< AtomGroup > atms, flt dist) -> LinearConstraint"""
        this = _sim2d.new_LinearConstraint(atms, dist)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def constrained_dof(self) -> "int":
        """constrained_dof(LinearConstraint self) -> int"""
        return _sim2d.LinearConstraint_constrained_dof(self)


    def apply_positions(self, box: 'Box') -> "void":
        """apply_positions(LinearConstraint self, Box box)"""
        return _sim2d.LinearConstraint_apply_positions(self, box)


    def apply_velocities(self, box: 'Box') -> "void":
        """apply_velocities(LinearConstraint self, Box box)"""
        return _sim2d.LinearConstraint_apply_velocities(self, box)


    def apply_forces(self, box: 'Box') -> "void":
        """apply_forces(LinearConstraint self, Box box)"""
        return _sim2d.LinearConstraint_apply_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LinearConstraint
    __del__ = lambda self: None
LinearConstraint_swigregister = _sim2d.LinearConstraint_swigregister
LinearConstraint_swigregister(LinearConstraint)

class ContactTracker(StateTracker):
    """Proxy of C++ ContactTracker class."""

    __swig_setmethods__ = {}
    for _s in [StateTracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [StateTracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContactTracker, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', atoms: 'boost::shared_ptr< AtomGroup >', dists: 'dvector'):
        """__init__(ContactTracker self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, dvector dists) -> ContactTracker"""
        this = _sim2d.new_ContactTracker(box, atoms, dists)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update(self, box: 'Box') -> "void":
        """update(ContactTracker self, Box box)"""
        return _sim2d.ContactTracker_update(self, box)


    def reset(self) -> "void":
        """reset(ContactTracker self)"""
        return _sim2d.ContactTracker_reset(self)


    def broken(self) -> "unsigned long long":
        """broken(ContactTracker self) -> unsigned long long"""
        return _sim2d.ContactTracker_broken(self)


    def formed(self) -> "unsigned long long":
        """formed(ContactTracker self) -> unsigned long long"""
        return _sim2d.ContactTracker_formed(self)


    def number(self) -> "unsigned long long":
        """number(ContactTracker self) -> unsigned long long"""
        return _sim2d.ContactTracker_number(self)

    __swig_destroy__ = _sim2d.delete_ContactTracker
    __del__ = lambda self: None
ContactTracker_swigregister = _sim2d.ContactTracker_swigregister
ContactTracker_swigregister(ContactTracker)


def ContactTrackerD(box: 'boost::shared_ptr< Box >', atoms: 'boost::shared_ptr< AtomGroup >', dists: 'dvector') -> "ContactTracker *":
    """ContactTrackerD(boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, dvector dists) -> ContactTracker"""
    return _sim2d.ContactTrackerD(box, atoms, dists)
class EnergyTracker(StateTracker):
    """Proxy of C++ EnergyTracker class."""

    __swig_setmethods__ = {}
    for _s in [StateTracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [StateTracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyTracker, name)
    __repr__ = _swig_repr

    def __init__(self, atoms: 'boost::shared_ptr< AtomGroup >', interactions: 'ivector', n_skip: 'uint'=1):
        """
        __init__(EnergyTracker self, boost::shared_ptr< AtomGroup > atoms, ivector interactions, uint n_skip=1) -> EnergyTracker
        __init__(EnergyTracker self, boost::shared_ptr< AtomGroup > atoms, ivector interactions) -> EnergyTracker
        """
        this = _sim2d.new_EnergyTracker(atoms, interactions, n_skip)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update(self, box: 'Box') -> "void":
        """update(EnergyTracker self, Box box)"""
        return _sim2d.EnergyTracker_update(self, box)


    def reset(self) -> "void":
        """reset(EnergyTracker self)"""
        return _sim2d.EnergyTracker_reset(self)


    def set_U0(self, *args) -> "void":
        """
        set_U0(EnergyTracker self, flt newU0)
        set_U0(EnergyTracker self, Box box)
        """
        return _sim2d.EnergyTracker_set_U0(self, *args)


    def get_U0(self) -> "flt":
        """get_U0(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_get_U0(self)


    def E(self) -> "flt":
        """E(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_E(self)


    def U(self) -> "flt":
        """U(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_U(self)


    def K(self) -> "flt":
        """K(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_K(self)


    def E_std(self) -> "flt":
        """E_std(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_E_std(self)


    def K_std(self) -> "flt":
        """K_std(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_K_std(self)


    def U_std(self) -> "flt":
        """U_std(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_U_std(self)


    def E_squared_mean(self) -> "flt":
        """E_squared_mean(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_E_squared_mean(self)


    def K_squared_mean(self) -> "flt":
        """K_squared_mean(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_K_squared_mean(self)


    def U_squared_mean(self) -> "flt":
        """U_squared_mean(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_U_squared_mean(self)


    def n(self) -> "uint":
        """n(EnergyTracker self) -> uint"""
        return _sim2d.EnergyTracker_n(self)

    __swig_destroy__ = _sim2d.delete_EnergyTracker
    __del__ = lambda self: None
EnergyTracker_swigregister = _sim2d.EnergyTracker_swigregister
EnergyTracker_swigregister(EnergyTracker)

class RsqTracker1(_object):
    """Proxy of C++ RsqTracker1 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RsqTracker1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RsqTracker1, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pastlocs"] = _sim2d.RsqTracker1_pastlocs_set
    __swig_getmethods__["pastlocs"] = _sim2d.RsqTracker1_pastlocs_get
    if _newclass:
        pastlocs = _swig_property(_sim2d.RsqTracker1_pastlocs_get, _sim2d.RsqTracker1_pastlocs_set)
    __swig_setmethods__["xyz2sums"] = _sim2d.RsqTracker1_xyz2sums_set
    __swig_getmethods__["xyz2sums"] = _sim2d.RsqTracker1_xyz2sums_get
    if _newclass:
        xyz2sums = _swig_property(_sim2d.RsqTracker1_xyz2sums_get, _sim2d.RsqTracker1_xyz2sums_set)
    __swig_setmethods__["xyz4sums"] = _sim2d.RsqTracker1_xyz4sums_set
    __swig_getmethods__["xyz4sums"] = _sim2d.RsqTracker1_xyz4sums_get
    if _newclass:
        xyz4sums = _swig_property(_sim2d.RsqTracker1_xyz4sums_get, _sim2d.RsqTracker1_xyz4sums_set)
    __swig_setmethods__["r4sums"] = _sim2d.RsqTracker1_r4sums_set
    __swig_getmethods__["r4sums"] = _sim2d.RsqTracker1_r4sums_get
    if _newclass:
        r4sums = _swig_property(_sim2d.RsqTracker1_r4sums_get, _sim2d.RsqTracker1_r4sums_set)
    __swig_setmethods__["skip"] = _sim2d.RsqTracker1_skip_set
    __swig_getmethods__["skip"] = _sim2d.RsqTracker1_skip_get
    if _newclass:
        skip = _swig_property(_sim2d.RsqTracker1_skip_get, _sim2d.RsqTracker1_skip_set)
    __swig_setmethods__["count"] = _sim2d.RsqTracker1_count_set
    __swig_getmethods__["count"] = _sim2d.RsqTracker1_count_get
    if _newclass:
        count = _swig_property(_sim2d.RsqTracker1_count_get, _sim2d.RsqTracker1_count_set)

    def __init__(self, atoms: 'AtomGroup', skip: 'unsigned long', com: 'Vec'):
        """__init__(RsqTracker1 self, AtomGroup atoms, unsigned long skip, Vec com) -> RsqTracker1"""
        this = _sim2d.new_RsqTracker1(atoms, skip, com)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def reset(self, atoms: 'AtomGroup', com: 'Vec') -> "void":
        """reset(RsqTracker1 self, AtomGroup atoms, Vec com)"""
        return _sim2d.RsqTracker1_reset(self, atoms, com)


    def update(self, box: 'Box', atoms: 'AtomGroup', t: 'unsigned long', com: 'Vec') -> "bool":
        """update(RsqTracker1 self, Box box, AtomGroup atoms, unsigned long t, Vec com) -> bool"""
        return _sim2d.RsqTracker1_update(self, box, atoms, t, com)


    def xyz2(self) -> "Eigen::Matrix< flt,Eigen::Dynamic,2 >":
        """xyz2(RsqTracker1 self) -> Eigen::Matrix< flt,Eigen::Dynamic,2 >"""
        return _sim2d.RsqTracker1_xyz2(self)


    def xyz4(self) -> "Eigen::Matrix< flt,Eigen::Dynamic,2 >":
        """xyz4(RsqTracker1 self) -> Eigen::Matrix< flt,Eigen::Dynamic,2 >"""
        return _sim2d.RsqTracker1_xyz4(self)


    def r4(self) -> "std::vector< flt >":
        """r4(RsqTracker1 self) -> dvector"""
        return _sim2d.RsqTracker1_r4(self)


    def get_skip(self) -> "unsigned long":
        """get_skip(RsqTracker1 self) -> unsigned long"""
        return _sim2d.RsqTracker1_get_skip(self)


    def get_count(self) -> "unsigned long":
        """get_count(RsqTracker1 self) -> unsigned long"""
        return _sim2d.RsqTracker1_get_count(self)

    __swig_destroy__ = _sim2d.delete_RsqTracker1
    __del__ = lambda self: None
RsqTracker1_swigregister = _sim2d.RsqTracker1_swigregister
RsqTracker1_swigregister(RsqTracker1)

class RsqTracker(StateTracker):
    """Proxy of C++ RsqTracker class."""

    __swig_setmethods__ = {}
    for _s in [StateTracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RsqTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [StateTracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RsqTracker, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.RsqTracker_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.RsqTracker_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.RsqTracker_atoms_get, _sim2d.RsqTracker_atoms_set)
    __swig_setmethods__["singles"] = _sim2d.RsqTracker_singles_set
    __swig_getmethods__["singles"] = _sim2d.RsqTracker_singles_get
    if _newclass:
        singles = _swig_property(_sim2d.RsqTracker_singles_get, _sim2d.RsqTracker_singles_set)
    __swig_setmethods__["curt"] = _sim2d.RsqTracker_curt_set
    __swig_getmethods__["curt"] = _sim2d.RsqTracker_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.RsqTracker_curt_get, _sim2d.RsqTracker_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.RsqTracker_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.RsqTracker_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.RsqTracker_usecom_get, _sim2d.RsqTracker_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< AtomGroup >', ns: 'ulongvector', usecom: 'bool'=True):
        """
        __init__(RsqTracker self, boost::shared_ptr< AtomGroup > atoms, ulongvector ns, bool usecom=True) -> RsqTracker
        __init__(RsqTracker self, boost::shared_ptr< AtomGroup > atoms, ulongvector ns) -> RsqTracker
        """
        this = _sim2d.new_RsqTracker(atoms, ns, usecom)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def reset(self) -> "void":
        """reset(RsqTracker self)"""
        return _sim2d.RsqTracker_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(RsqTracker self, Box box)"""
        return _sim2d.RsqTracker_update(self, box)


    def xyz2(self) -> "std::vector< Eigen::Matrix< flt,Eigen::Dynamic,2 > >":
        """xyz2(RsqTracker self) -> std::vector< Eigen::Matrix< flt,Eigen::Dynamic,2 > >"""
        return _sim2d.RsqTracker_xyz2(self)


    def r2(self) -> "std::vector< std::vector< flt > >":
        """r2(RsqTracker self) -> _ddvector"""
        return _sim2d.RsqTracker_r2(self)


    def xyz4(self) -> "std::vector< Eigen::Matrix< flt,Eigen::Dynamic,2 > >":
        """xyz4(RsqTracker self) -> std::vector< Eigen::Matrix< flt,Eigen::Dynamic,2 > >"""
        return _sim2d.RsqTracker_xyz4(self)


    def r4(self) -> "std::vector< std::vector< flt > >":
        """r4(RsqTracker self) -> _ddvector"""
        return _sim2d.RsqTracker_r4(self)


    def counts(self) -> "std::vector< flt >":
        """counts(RsqTracker self) -> dvector"""
        return _sim2d.RsqTracker_counts(self)

    __swig_destroy__ = _sim2d.delete_RsqTracker
    __del__ = lambda self: None
RsqTracker_swigregister = _sim2d.RsqTracker_swigregister
RsqTracker_swigregister(RsqTracker)

class ISFTracker1(_object):
    """Proxy of C++ ISFTracker1 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISFTracker1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISFTracker1, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pastlocs"] = _sim2d.ISFTracker1_pastlocs_set
    __swig_getmethods__["pastlocs"] = _sim2d.ISFTracker1_pastlocs_get
    if _newclass:
        pastlocs = _swig_property(_sim2d.ISFTracker1_pastlocs_get, _sim2d.ISFTracker1_pastlocs_set)
    __swig_setmethods__["ISFsums"] = _sim2d.ISFTracker1_ISFsums_set
    __swig_getmethods__["ISFsums"] = _sim2d.ISFTracker1_ISFsums_get
    if _newclass:
        ISFsums = _swig_property(_sim2d.ISFTracker1_ISFsums_get, _sim2d.ISFTracker1_ISFsums_set)
    __swig_setmethods__["ks"] = _sim2d.ISFTracker1_ks_set
    __swig_getmethods__["ks"] = _sim2d.ISFTracker1_ks_get
    if _newclass:
        ks = _swig_property(_sim2d.ISFTracker1_ks_get, _sim2d.ISFTracker1_ks_set)
    __swig_setmethods__["skip"] = _sim2d.ISFTracker1_skip_set
    __swig_getmethods__["skip"] = _sim2d.ISFTracker1_skip_get
    if _newclass:
        skip = _swig_property(_sim2d.ISFTracker1_skip_get, _sim2d.ISFTracker1_skip_set)
    __swig_setmethods__["count"] = _sim2d.ISFTracker1_count_set
    __swig_getmethods__["count"] = _sim2d.ISFTracker1_count_get
    if _newclass:
        count = _swig_property(_sim2d.ISFTracker1_count_get, _sim2d.ISFTracker1_count_set)

    def __init__(self, atoms: 'AtomGroup', skip: 'unsigned long', ks: 'dvector', com: 'Vec'):
        """__init__(ISFTracker1 self, AtomGroup atoms, unsigned long skip, dvector ks, Vec com) -> ISFTracker1"""
        this = _sim2d.new_ISFTracker1(atoms, skip, ks, com)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def reset(self, atoms: 'AtomGroup', com: 'Vec') -> "void":
        """reset(ISFTracker1 self, AtomGroup atoms, Vec com)"""
        return _sim2d.ISFTracker1_reset(self, atoms, com)


    def update(self, box: 'Box', atoms: 'AtomGroup', t: 'unsigned long', com: 'Vec') -> "bool":
        """update(ISFTracker1 self, Box box, AtomGroup atoms, unsigned long t, Vec com) -> bool"""
        return _sim2d.ISFTracker1_update(self, box, atoms, t, com)


    def ISFs(self) -> "std::vector< std::vector< cmplx > >":
        """ISFs(ISFTracker1 self) -> _ccvector"""
        return _sim2d.ISFTracker1_ISFs(self)


    def ISFxyz(self) -> "std::vector< std::vector< boost::array< cmplx,2 > > >":
        """ISFxyz(ISFTracker1 self) -> _ccavector2"""
        return _sim2d.ISFTracker1_ISFxyz(self)


    def get_skip(self) -> "unsigned long":
        """get_skip(ISFTracker1 self) -> unsigned long"""
        return _sim2d.ISFTracker1_get_skip(self)


    def get_count(self) -> "unsigned long":
        """get_count(ISFTracker1 self) -> unsigned long"""
        return _sim2d.ISFTracker1_get_count(self)

    __swig_destroy__ = _sim2d.delete_ISFTracker1
    __del__ = lambda self: None
ISFTracker1_swigregister = _sim2d.ISFTracker1_swigregister
ISFTracker1_swigregister(ISFTracker1)

class ISFTracker(StateTracker):
    """Proxy of C++ ISFTracker class."""

    __swig_setmethods__ = {}
    for _s in [StateTracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISFTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [StateTracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ISFTracker, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.ISFTracker_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.ISFTracker_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.ISFTracker_atoms_get, _sim2d.ISFTracker_atoms_set)
    __swig_setmethods__["singles"] = _sim2d.ISFTracker_singles_set
    __swig_getmethods__["singles"] = _sim2d.ISFTracker_singles_get
    if _newclass:
        singles = _swig_property(_sim2d.ISFTracker_singles_get, _sim2d.ISFTracker_singles_set)
    __swig_setmethods__["curt"] = _sim2d.ISFTracker_curt_set
    __swig_getmethods__["curt"] = _sim2d.ISFTracker_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.ISFTracker_curt_get, _sim2d.ISFTracker_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.ISFTracker_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.ISFTracker_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.ISFTracker_usecom_get, _sim2d.ISFTracker_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< AtomGroup >', ks: 'dvector', ns: 'ulongvector', usecom: 'bool'=False):
        """
        __init__(ISFTracker self, boost::shared_ptr< AtomGroup > atoms, dvector ks, ulongvector ns, bool usecom=False) -> ISFTracker
        __init__(ISFTracker self, boost::shared_ptr< AtomGroup > atoms, dvector ks, ulongvector ns) -> ISFTracker
        """
        this = _sim2d.new_ISFTracker(atoms, ks, ns, usecom)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def reset(self) -> "void":
        """reset(ISFTracker self)"""
        return _sim2d.ISFTracker_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(ISFTracker self, Box box)"""
        return _sim2d.ISFTracker_update(self, box)


    def ISFxyz(self) -> "std::vector< std::vector< std::vector< boost::array< cmplx,2 > > > >":
        """ISFxyz(ISFTracker self) -> _cccavector2"""
        return _sim2d.ISFTracker_ISFxyz(self)


    def ISFs(self) -> "std::vector< std::vector< std::vector< cmplx > > >":
        """ISFs(ISFTracker self) -> _cccvector"""
        return _sim2d.ISFTracker_ISFs(self)


    def counts(self) -> "std::vector< flt >":
        """counts(ISFTracker self) -> dvector"""
        return _sim2d.ISFTracker_counts(self)

    __swig_destroy__ = _sim2d.delete_ISFTracker
    __del__ = lambda self: None
ISFTracker_swigregister = _sim2d.ISFTracker_swigregister
ISFTracker_swigregister(ISFTracker)

class SmoothLocs(StateTracker):
    """Proxy of C++ SmoothLocs class."""

    __swig_setmethods__ = {}
    for _s in [StateTracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmoothLocs, name, value)
    __swig_getmethods__ = {}
    for _s in [StateTracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SmoothLocs, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.SmoothLocs_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.SmoothLocs_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.SmoothLocs_atoms_get, _sim2d.SmoothLocs_atoms_set)
    __swig_setmethods__["smoothn"] = _sim2d.SmoothLocs_smoothn_set
    __swig_getmethods__["smoothn"] = _sim2d.SmoothLocs_smoothn_get
    if _newclass:
        smoothn = _swig_property(_sim2d.SmoothLocs_smoothn_get, _sim2d.SmoothLocs_smoothn_set)
    __swig_setmethods__["skipn"] = _sim2d.SmoothLocs_skipn_set
    __swig_getmethods__["skipn"] = _sim2d.SmoothLocs_skipn_get
    if _newclass:
        skipn = _swig_property(_sim2d.SmoothLocs_skipn_get, _sim2d.SmoothLocs_skipn_set)
    __swig_setmethods__["curlocs"] = _sim2d.SmoothLocs_curlocs_set
    __swig_getmethods__["curlocs"] = _sim2d.SmoothLocs_curlocs_get
    if _newclass:
        curlocs = _swig_property(_sim2d.SmoothLocs_curlocs_get, _sim2d.SmoothLocs_curlocs_set)
    __swig_setmethods__["numincur"] = _sim2d.SmoothLocs_numincur_set
    __swig_getmethods__["numincur"] = _sim2d.SmoothLocs_numincur_get
    if _newclass:
        numincur = _swig_property(_sim2d.SmoothLocs_numincur_get, _sim2d.SmoothLocs_numincur_set)
    __swig_setmethods__["locs"] = _sim2d.SmoothLocs_locs_set
    __swig_getmethods__["locs"] = _sim2d.SmoothLocs_locs_get
    if _newclass:
        locs = _swig_property(_sim2d.SmoothLocs_locs_get, _sim2d.SmoothLocs_locs_set)
    __swig_setmethods__["curt"] = _sim2d.SmoothLocs_curt_set
    __swig_getmethods__["curt"] = _sim2d.SmoothLocs_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.SmoothLocs_curt_get, _sim2d.SmoothLocs_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.SmoothLocs_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.SmoothLocs_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.SmoothLocs_usecom_get, _sim2d.SmoothLocs_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< AtomGroup >', box: 'Box', smoothn: 'uint', skipn: 'uint'=1, usecom: 'bool'=False):
        """
        __init__(SmoothLocs self, boost::shared_ptr< AtomGroup > atoms, Box box, uint smoothn, uint skipn=1, bool usecom=False) -> SmoothLocs
        __init__(SmoothLocs self, boost::shared_ptr< AtomGroup > atoms, Box box, uint smoothn, uint skipn=1) -> SmoothLocs
        __init__(SmoothLocs self, boost::shared_ptr< AtomGroup > atoms, Box box, uint smoothn) -> SmoothLocs
        """
        this = _sim2d.new_SmoothLocs(atoms, box, smoothn, skipn, usecom)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def reset(self) -> "void":
        """reset(SmoothLocs self)"""
        return _sim2d.SmoothLocs_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(SmoothLocs self, Box box)"""
        return _sim2d.SmoothLocs_update(self, box)


    def smooth_locs(self) -> "std::vector< Eigen::Matrix< flt,Eigen::Dynamic,2 > >":
        """smooth_locs(SmoothLocs self) -> std::vector< Eigen::Matrix< flt,Eigen::Dynamic,2 > >"""
        return _sim2d.SmoothLocs_smooth_locs(self)

    __swig_destroy__ = _sim2d.delete_SmoothLocs
    __del__ = lambda self: None
SmoothLocs_swigregister = _sim2d.SmoothLocs_swigregister
SmoothLocs_swigregister(SmoothLocs)

class RDiffs(StateTracker):
    """Proxy of C++ RDiffs class."""

    __swig_setmethods__ = {}
    for _s in [StateTracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RDiffs, name, value)
    __swig_getmethods__ = {}
    for _s in [StateTracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RDiffs, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.RDiffs_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.RDiffs_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.RDiffs_atoms_get, _sim2d.RDiffs_atoms_set)
    __swig_setmethods__["pastlocs"] = _sim2d.RDiffs_pastlocs_set
    __swig_getmethods__["pastlocs"] = _sim2d.RDiffs_pastlocs_get
    if _newclass:
        pastlocs = _swig_property(_sim2d.RDiffs_pastlocs_get, _sim2d.RDiffs_pastlocs_set)
    __swig_setmethods__["dists"] = _sim2d.RDiffs_dists_set
    __swig_getmethods__["dists"] = _sim2d.RDiffs_dists_get
    if _newclass:
        dists = _swig_property(_sim2d.RDiffs_dists_get, _sim2d.RDiffs_dists_set)
    __swig_setmethods__["skip"] = _sim2d.RDiffs_skip_set
    __swig_getmethods__["skip"] = _sim2d.RDiffs_skip_get
    if _newclass:
        skip = _swig_property(_sim2d.RDiffs_skip_get, _sim2d.RDiffs_skip_set)
    __swig_setmethods__["curt"] = _sim2d.RDiffs_curt_set
    __swig_getmethods__["curt"] = _sim2d.RDiffs_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.RDiffs_curt_get, _sim2d.RDiffs_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.RDiffs_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.RDiffs_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.RDiffs_usecom_get, _sim2d.RDiffs_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< AtomGroup >', skip: 'unsigned long', usecom: 'bool'=False):
        """
        __init__(RDiffs self, boost::shared_ptr< AtomGroup > atoms, unsigned long skip, bool usecom=False) -> RDiffs
        __init__(RDiffs self, boost::shared_ptr< AtomGroup > atoms, unsigned long skip) -> RDiffs
        """
        this = _sim2d.new_RDiffs(atoms, skip, usecom)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def reset(self) -> "void":
        """reset(RDiffs self)"""
        return _sim2d.RDiffs_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(RDiffs self, Box box)"""
        return _sim2d.RDiffs_update(self, box)


    def rdiffs(self) -> "std::vector< std::vector< flt > >":
        """rdiffs(RDiffs self) -> _ddvector"""
        return _sim2d.RDiffs_rdiffs(self)


    def get_skip(self) -> "unsigned long":
        """get_skip(RDiffs self) -> unsigned long"""
        return _sim2d.RDiffs_get_skip(self)

    __swig_destroy__ = _sim2d.delete_RDiffs
    __del__ = lambda self: None
RDiffs_swigregister = _sim2d.RDiffs_swigregister
RDiffs_swigregister(RDiffs)

class JammingList(_object):
    """Proxy of C++ JammingList class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JammingList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JammingList, name)
    __repr__ = _swig_repr
    __swig_setmethods__["assigned"] = _sim2d.JammingList_assigned_set
    __swig_getmethods__["assigned"] = _sim2d.JammingList_assigned_get
    if _newclass:
        assigned = _swig_property(_sim2d.JammingList_assigned_get, _sim2d.JammingList_assigned_set)
    __swig_setmethods__["distance_squared"] = _sim2d.JammingList_distance_squared_set
    __swig_getmethods__["distance_squared"] = _sim2d.JammingList_distance_squared_get
    if _newclass:
        distance_squared = _swig_property(_sim2d.JammingList_distance_squared_get, _sim2d.JammingList_distance_squared_set)

    def __init__(self, *args):
        """
        __init__(JammingList self) -> JammingList
        __init__(JammingList self, JammingList other) -> JammingList
        __init__(JammingList self, JammingList other, uint expand, flt addeddist) -> JammingList
        """
        this = _sim2d.new_JammingList(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def size(self) -> "uint":
        """size(JammingList self) -> uint"""
        return _sim2d.JammingList_size(self)


    def __lt__(self, other: 'JammingList') -> "bool":
        """__lt__(JammingList self, JammingList other) -> bool"""
        return _sim2d.JammingList___lt__(self, other)

    __swig_destroy__ = _sim2d.delete_JammingList
    __del__ = lambda self: None
JammingList_swigregister = _sim2d.JammingList_swigregister
JammingList_swigregister(JammingList)

class JammingTree(_object):
    """Proxy of C++ JammingTree class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JammingTree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JammingTree, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', A: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &', B: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &'):
        """__init__(JammingTree self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B) -> JammingTree"""
        this = _sim2d.new_JammingTree(box, A, B)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def expand(self, *args) -> "bool":
        """
        expand(JammingTree self) -> bool
        expand(JammingTree self, uint n) -> bool
        """
        return _sim2d.JammingTree_expand(self, *args)


    def my_list(self) -> "std::list< JammingList > &":
        """my_list(JammingTree self) -> _JammingList"""
        return _sim2d.JammingTree_my_list(self)


    def copy_list(self) -> "std::list< JammingList >":
        """copy_list(JammingTree self) -> _JammingList"""
        return _sim2d.JammingTree_copy_list(self)


    def current_best(self) -> "JammingList":
        """current_best(JammingTree self) -> JammingList"""
        return _sim2d.JammingTree_current_best(self)


    def size(self) -> "uint":
        """size(JammingTree self) -> uint"""
        return _sim2d.JammingTree_size(self)

    __swig_destroy__ = _sim2d.delete_JammingTree
    __del__ = lambda self: None
JammingTree_swigregister = _sim2d.JammingTree_swigregister
JammingTree_swigregister(JammingTree)

class JammingListRot(JammingList):
    """Proxy of C++ JammingListRot class."""

    __swig_setmethods__ = {}
    for _s in [JammingList]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JammingListRot, name, value)
    __swig_getmethods__ = {}
    for _s in [JammingList]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JammingListRot, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rotation"] = _sim2d.JammingListRot_rotation_set
    __swig_getmethods__["rotation"] = _sim2d.JammingListRot_rotation_get
    if _newclass:
        rotation = _swig_property(_sim2d.JammingListRot_rotation_get, _sim2d.JammingListRot_rotation_set)

    def __init__(self, *args):
        """
        __init__(JammingListRot self) -> JammingListRot
        __init__(JammingListRot self, uint rot) -> JammingListRot
        __init__(JammingListRot self, JammingListRot other) -> JammingListRot
        __init__(JammingListRot self, JammingListRot other, uint expand, flt addeddist) -> JammingListRot
        """
        this = _sim2d.new_JammingListRot(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __lt__(self, other: 'JammingListRot') -> "bool":
        """__lt__(JammingListRot self, JammingListRot other) -> bool"""
        return _sim2d.JammingListRot___lt__(self, other)

    __swig_destroy__ = _sim2d.delete_JammingListRot
    __del__ = lambda self: None
JammingListRot_swigregister = _sim2d.JammingListRot_swigregister
JammingListRot_swigregister(JammingListRot)

class JammingTreeRot(_object):
    """Proxy of C++ JammingTreeRot class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JammingTreeRot, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JammingTreeRot, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', A: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &', B: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &', use_rotations: 'bool'=True, use_inversions: 'bool'=True):
        """
        __init__(JammingTreeRot self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, bool use_rotations=True, bool use_inversions=True) -> JammingTreeRot
        __init__(JammingTreeRot self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, bool use_rotations=True) -> JammingTreeRot
        __init__(JammingTreeRot self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B) -> JammingTreeRot
        """
        this = _sim2d.new_JammingTreeRot(box, A, B, use_rotations, use_inversions)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def distance(self, jlist: 'JammingListRot') -> "flt":
        """distance(JammingTreeRot self, JammingListRot jlist) -> flt"""
        return _sim2d.JammingTreeRot_distance(self, jlist)


    def expand(self, *args) -> "bool":
        """
        expand(JammingTreeRot self, JammingListRot curjlist) -> _JammingListRot
        expand(JammingTreeRot self) -> bool
        expand(JammingTreeRot self, uint n) -> bool
        """
        return _sim2d.JammingTreeRot_expand(self, *args)


    def expand_to(self, maxdistsq: 'flt') -> "bool":
        """expand_to(JammingTreeRot self, flt maxdistsq) -> bool"""
        return _sim2d.JammingTreeRot_expand_to(self, maxdistsq)


    def straight_diff(bx: 'Box', A: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &', B: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &') -> "Vec":
        """straight_diff(Box bx, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B) -> Vec"""
        return _sim2d.JammingTreeRot_straight_diff(bx, A, B)

    if _newclass:
        straight_diff = staticmethod(straight_diff)
    __swig_getmethods__["straight_diff"] = lambda x: straight_diff

    def straight_distsq(bx: 'Box', A: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &', B: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &') -> "flt":
        """straight_distsq(Box bx, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B) -> flt"""
        return _sim2d.JammingTreeRot_straight_distsq(bx, A, B)

    if _newclass:
        straight_distsq = staticmethod(straight_distsq)
    __swig_getmethods__["straight_distsq"] = lambda x: straight_distsq

    def my_list(self) -> "std::list< JammingListRot > &":
        """my_list(JammingTreeRot self) -> _JammingListRot"""
        return _sim2d.JammingTreeRot_my_list(self)


    def copy_list(self, *args) -> "std::list< JammingListRot >":
        """
        copy_list(JammingTreeRot self) -> _JammingListRot
        copy_list(JammingTreeRot self, uint n) -> _JammingListRot
        """
        return _sim2d.JammingTreeRot_copy_list(self, *args)


    def current_best(self) -> "JammingListRot":
        """current_best(JammingTreeRot self) -> JammingListRot"""
        return _sim2d.JammingTreeRot_current_best(self)


    def size(self) -> "uint":
        """size(JammingTreeRot self) -> uint"""
        return _sim2d.JammingTreeRot_size(self)


    def locations_B(self, *args) -> "Eigen::Matrix< flt,Eigen::Dynamic,2 >":
        """
        locations_B(JammingTreeRot self, JammingListRot jlist) -> Eigen::Matrix< flt,Eigen::Dynamic,2 >
        locations_B(JammingTreeRot self) -> Eigen::Matrix< flt,Eigen::Dynamic,2 >
        """
        return _sim2d.JammingTreeRot_locations_B(self, *args)


    def locations_A(self, *args) -> "Eigen::Matrix< flt,Eigen::Dynamic,2 >":
        """
        locations_A(JammingTreeRot self, JammingListRot jlist) -> Eigen::Matrix< flt,Eigen::Dynamic,2 >
        locations_A(JammingTreeRot self) -> Eigen::Matrix< flt,Eigen::Dynamic,2 >
        """
        return _sim2d.JammingTreeRot_locations_A(self, *args)

    __swig_destroy__ = _sim2d.delete_JammingTreeRot
    __del__ = lambda self: None
JammingTreeRot_swigregister = _sim2d.JammingTreeRot_swigregister
JammingTreeRot_swigregister(JammingTreeRot)

def JammingTreeRot_straight_diff(bx: 'Box', A: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &', B: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &') -> "Vec":
    """JammingTreeRot_straight_diff(Box bx, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B) -> Vec"""
    return _sim2d.JammingTreeRot_straight_diff(bx, A, B)

def JammingTreeRot_straight_distsq(bx: 'Box', A: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &', B: 'Eigen::Matrix< flt,Eigen::Dynamic,2 > &') -> "flt":
    """JammingTreeRot_straight_distsq(Box bx, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B) -> flt"""
    return _sim2d.JammingTreeRot_straight_distsq(bx, A, B)

class JammingTreeBD(JammingTreeRot):
    """Proxy of C++ JammingTreeBD class."""

    __swig_setmethods__ = {}
    for _s in [JammingTreeRot]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JammingTreeBD, name, value)
    __swig_getmethods__ = {}
    for _s in [JammingTreeRot]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JammingTreeBD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(JammingTreeBD self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, uint cutoff, bool use_rotations=True, bool use_inversions=True) -> JammingTreeBD
        __init__(JammingTreeBD self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, uint cutoff, bool use_rotations=True) -> JammingTreeBD
        __init__(JammingTreeBD self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, uint cutoff) -> JammingTreeBD
        __init__(JammingTreeBD self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, uint cutoffA, uint cutoffB, bool use_rotations=True, bool use_inversions=True) -> JammingTreeBD
        __init__(JammingTreeBD self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, uint cutoffA, uint cutoffB, bool use_rotations=True) -> JammingTreeBD
        __init__(JammingTreeBD self, boost::shared_ptr< Box > box, Eigen::Matrix< flt,Eigen::Dynamic,2 > & A, Eigen::Matrix< flt,Eigen::Dynamic,2 > & B, uint cutoffA, uint cutoffB) -> JammingTreeBD
        """
        this = _sim2d.new_JammingTreeBD(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def expand(self, *args) -> "bool":
        """
        expand(JammingTreeBD self, JammingListRot curjlist) -> _JammingListRot
        expand(JammingTreeBD self) -> bool
        expand(JammingTreeBD self, uint n) -> bool
        """
        return _sim2d.JammingTreeBD_expand(self, *args)

    __swig_destroy__ = _sim2d.delete_JammingTreeBD
    __del__ = lambda self: None
JammingTreeBD_swigregister = _sim2d.JammingTreeBD_swigregister
JammingTreeBD_swigregister(JammingTreeBD)

class CNode(_object):
    """Proxy of C++ CNode class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNode, name)
    __repr__ = _swig_repr
    __swig_setmethods__["n"] = _sim2d.CNode_n_set
    __swig_getmethods__["n"] = _sim2d.CNode_n_get
    if _newclass:
        n = _swig_property(_sim2d.CNode_n_get, _sim2d.CNode_n_set)
    __swig_setmethods__["x"] = _sim2d.CNode_x_set
    __swig_getmethods__["x"] = _sim2d.CNode_x_get
    if _newclass:
        x = _swig_property(_sim2d.CNode_x_get, _sim2d.CNode_x_set)

    def __init__(self, *args):
        """
        __init__(CNode self) -> CNode
        __init__(CNode self, int n, Vec x) -> CNode
        """
        this = _sim2d.new_CNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __ne__(self, other: 'CNode') -> "bool":
        """__ne__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___ne__(self, other)


    def __eq__(self, other: 'CNode') -> "bool":
        """__eq__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___eq__(self, other)


    def __lt__(self, other: 'CNode') -> "bool":
        """__lt__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___lt__(self, other)


    def __gt__(self, other: 'CNode') -> "bool":
        """__gt__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___gt__(self, other)

    __swig_destroy__ = _sim2d.delete_CNode
    __del__ = lambda self: None
CNode_swigregister = _sim2d.CNode_swigregister
CNode_swigregister(CNode)

class CNodePath(_object):
    """Proxy of C++ CNodePath class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNodePath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNodePath, name)
    __repr__ = _swig_repr
    __swig_setmethods__["distance"] = _sim2d.CNodePath_distance_set
    __swig_getmethods__["distance"] = _sim2d.CNodePath_distance_get
    if _newclass:
        distance = _swig_property(_sim2d.CNodePath_distance_get, _sim2d.CNodePath_distance_set)
    __swig_setmethods__["nodes"] = _sim2d.CNodePath_nodes_set
    __swig_getmethods__["nodes"] = _sim2d.CNodePath_nodes_get
    if _newclass:
        nodes = _swig_property(_sim2d.CNodePath_nodes_get, _sim2d.CNodePath_nodes_set)

    def __init__(self, *args):
        """
        __init__(CNodePath self) -> CNodePath
        __init__(CNodePath self, CNode node) -> CNodePath
        __init__(CNodePath self, CNodePath other, CNode node, OriginBox box) -> CNodePath
        """
        this = _sim2d.new_CNodePath(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, node: 'CNode', box: 'OriginBox') -> "void":
        """add(CNodePath self, CNode node, OriginBox box)"""
        return _sim2d.CNodePath_add(self, node, box)


    def size(self) -> "uint":
        """size(CNodePath self) -> uint"""
        return _sim2d.CNodePath_size(self)

    __swig_destroy__ = _sim2d.delete_CNodePath
    __del__ = lambda self: None
CNodePath_swigregister = _sim2d.CNodePath_swigregister
CNodePath_swigregister(CNodePath)

class Connectivity(_object):
    """Proxy of C++ Connectivity class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Connectivity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Connectivity, name)
    __repr__ = _swig_repr
    __swig_setmethods__["box"] = _sim2d.Connectivity_box_set
    __swig_getmethods__["box"] = _sim2d.Connectivity_box_get
    if _newclass:
        box = _swig_property(_sim2d.Connectivity_box_get, _sim2d.Connectivity_box_set)
    __swig_setmethods__["nodes"] = _sim2d.Connectivity_nodes_set
    __swig_getmethods__["nodes"] = _sim2d.Connectivity_nodes_get
    if _newclass:
        nodes = _swig_property(_sim2d.Connectivity_nodes_get, _sim2d.Connectivity_nodes_set)
    __swig_setmethods__["neighbors"] = _sim2d.Connectivity_neighbors_set
    __swig_getmethods__["neighbors"] = _sim2d.Connectivity_neighbors_get
    if _newclass:
        neighbors = _swig_property(_sim2d.Connectivity_neighbors_get, _sim2d.Connectivity_neighbors_set)

    def nonzero(self, diff_vec: 'Vec') -> "boost::array< bool,2 >":
        """nonzero(Connectivity self, Vec diff_vec) -> boost::array< bool,2 >"""
        return _sim2d.Connectivity_nonzero(self, diff_vec)


    def make_cycle(self, forward: 'CNodePath', backward: 'CNodePath') -> "CNodePath":
        """make_cycle(Connectivity self, CNodePath forward, CNodePath backward) -> CNodePath"""
        return _sim2d.Connectivity_make_cycle(self, forward, backward)


    def circular_from(self, node: 'CNode', visited: 'std::set< uint > &', check_all: 'bool') -> "std::map< uint,CNodePath >":
        """circular_from(Connectivity self, CNode node, std::set< uint > & visited, bool check_all) -> map_uint_CNodePath"""
        return _sim2d.Connectivity_circular_from(self, node, visited, check_all)


    def __init__(self, box: 'boost::shared_ptr< OriginBox >'):
        """__init__(Connectivity self, boost::shared_ptr< OriginBox > box) -> Connectivity"""
        this = _sim2d.new_Connectivity(box)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add_edge(self, node1: 'CNode', node2: 'CNode') -> "void":
        """add_edge(Connectivity self, CNode node1, CNode node2)"""
        return _sim2d.Connectivity_add_edge(self, node1, node2)


    def add(self, locs: 'Eigen::Matrix< flt,Eigen::Dynamic,2 >', diameters: 'dvector') -> "void":
        """add(Connectivity self, Eigen::Matrix< flt,Eigen::Dynamic,2 > locs, dvector diameters)"""
        return _sim2d.Connectivity_add(self, locs, diameters)


    def find_percolation(self, check_all_dims: 'bool'=True) -> "std::map< uint,CNodePath >":
        """
        find_percolation(Connectivity self, bool check_all_dims=True) -> map_uint_CNodePath
        find_percolation(Connectivity self) -> map_uint_CNodePath
        """
        return _sim2d.Connectivity_find_percolation(self, check_all_dims)

    __swig_destroy__ = _sim2d.delete_Connectivity
    __del__ = lambda self: None
Connectivity_swigregister = _sim2d.Connectivity_swigregister
Connectivity_swigregister(Connectivity)

class LJRepulse(Interaction):
    """Proxy of C++ NListed<(EpsSigAtom,LJRepulsePair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJRepulse, name)
    __repr__ = _swig_repr

    def add(self, atm: 'EpsSigAtom') -> "void":
        """add(LJRepulse self, EpsSigAtom atm)"""
        return _sim2d.LJRepulse_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(EpsSigAtom,LJRepulsePair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LJRepulse
        __init__(NListed<(EpsSigAtom,LJRepulsePair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LJRepulse
        """
        this = _sim2d.new_LJRepulse(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJRepulse self)"""
        return _sim2d.LJRepulse_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LJRepulsePair":
        """get_pair(LJRepulse self, IDPair pair) -> LJRepulsePair"""
        return _sim2d.LJRepulse_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "EpsSigAtom &":
        """getatom(LJRepulse self, uint n) -> EpsSigAtom"""
        return _sim2d.LJRepulse_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJRepulse self, Box box, IDPair pair) -> flt
        energy(LJRepulse self, Box box) -> flt
        """
        return _sim2d.LJRepulse_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJRepulse_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJRepulse_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJRepulse self, Box box) -> flt"""
        return _sim2d.LJRepulse_pressure(self, box)


    def pair_iter(self) -> "std::vector< LJRepulsePair > &":
        """pair_iter(LJRepulse self) -> std::vector< LJRepulsePair > &"""
        return _sim2d.LJRepulse_pair_iter(self)


    def size(self) -> "uint":
        """size(LJRepulse self) -> uint"""
        return _sim2d.LJRepulse_size(self)


    def energy_pair(self, pair: 'LJRepulsePair', box: 'Box') -> "flt":
        """energy_pair(LJRepulse self, LJRepulsePair pair, Box box) -> flt"""
        return _sim2d.LJRepulse_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LJRepulse self, Box box)"""
        return _sim2d.LJRepulse_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LJRepulse self, Box box) -> flt"""
        return _sim2d.LJRepulse_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LJRepulse self, Box box) -> Matrix"""
        return _sim2d.LJRepulse_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LJRepulse self, Box box) -> Matrix"""
        return _sim2d.LJRepulse_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LJRepulsePair', box: 'Box') -> "Vec":
        """forces_pair(LJRepulse self, LJRepulsePair pair, Box box) -> Vec"""
        return _sim2d.LJRepulse_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< EpsSigAtom > &":
        """atom_list(LJRepulse self) -> std::vector< EpsSigAtom > &"""
        return _sim2d.LJRepulse_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LJRepulse self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LJRepulse_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LJRepulse
    __del__ = lambda self: None
LJRepulse_swigregister = _sim2d.LJRepulse_swigregister
LJRepulse_swigregister(LJRepulse)

class LJAttractICut(Interaction):
    """Proxy of C++ NListed<(IEpsSigCutAtom,LJAttractCutPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractICut, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractICut, name)
    __repr__ = _swig_repr

    def add(self, atm: 'IEpsSigCutAtom') -> "void":
        """add(LJAttractICut self, IEpsSigCutAtom atm)"""
        return _sim2d.LJAttractICut_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(IEpsSigCutAtom,LJAttractCutPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LJAttractICut
        __init__(NListed<(IEpsSigCutAtom,LJAttractCutPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LJAttractICut
        """
        this = _sim2d.new_LJAttractICut(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJAttractICut self)"""
        return _sim2d.LJAttractICut_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LJAttractCutPair":
        """get_pair(LJAttractICut self, IDPair pair) -> LJAttractCutPair"""
        return _sim2d.LJAttractICut_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "IEpsSigCutAtom &":
        """getatom(LJAttractICut self, uint n) -> IEpsSigCutAtom"""
        return _sim2d.LJAttractICut_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJAttractICut self, Box box, IDPair pair) -> flt
        energy(LJAttractICut self, Box box) -> flt
        """
        return _sim2d.LJAttractICut_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJAttractICut self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractICut_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJAttractICut self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractICut_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJAttractICut self, Box box) -> flt"""
        return _sim2d.LJAttractICut_pressure(self, box)


    def pair_iter(self) -> "std::vector< LJAttractCutPair > &":
        """pair_iter(LJAttractICut self) -> std::vector< LJAttractCutPair > &"""
        return _sim2d.LJAttractICut_pair_iter(self)


    def size(self) -> "uint":
        """size(LJAttractICut self) -> uint"""
        return _sim2d.LJAttractICut_size(self)


    def energy_pair(self, pair: 'LJAttractCutPair', box: 'Box') -> "flt":
        """energy_pair(LJAttractICut self, LJAttractCutPair pair, Box box) -> flt"""
        return _sim2d.LJAttractICut_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LJAttractICut self, Box box)"""
        return _sim2d.LJAttractICut_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LJAttractICut self, Box box) -> flt"""
        return _sim2d.LJAttractICut_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LJAttractICut self, Box box) -> Matrix"""
        return _sim2d.LJAttractICut_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LJAttractICut self, Box box) -> Matrix"""
        return _sim2d.LJAttractICut_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LJAttractCutPair', box: 'Box') -> "Vec":
        """forces_pair(LJAttractICut self, LJAttractCutPair pair, Box box) -> Vec"""
        return _sim2d.LJAttractICut_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< IEpsSigCutAtom > &":
        """atom_list(LJAttractICut self) -> std::vector< IEpsSigCutAtom > &"""
        return _sim2d.LJAttractICut_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LJAttractICut self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LJAttractICut_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LJAttractICut
    __del__ = lambda self: None
LJAttractICut_swigregister = _sim2d.LJAttractICut_swigregister
LJAttractICut_swigregister(LJAttractICut)

class LJAttractIICut(Interaction):
    """Proxy of C++ NListed<(IEpsISigCutAtom,LJAttractCutPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractIICut, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractIICut, name)
    __repr__ = _swig_repr

    def add(self, atm: 'IEpsISigCutAtom') -> "void":
        """add(LJAttractIICut self, IEpsISigCutAtom atm)"""
        return _sim2d.LJAttractIICut_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(IEpsISigCutAtom,LJAttractCutPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LJAttractIICut
        __init__(NListed<(IEpsISigCutAtom,LJAttractCutPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LJAttractIICut
        """
        this = _sim2d.new_LJAttractIICut(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJAttractIICut self)"""
        return _sim2d.LJAttractIICut_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LJAttractCutPair":
        """get_pair(LJAttractIICut self, IDPair pair) -> LJAttractCutPair"""
        return _sim2d.LJAttractIICut_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "IEpsISigCutAtom &":
        """getatom(LJAttractIICut self, uint n) -> IEpsISigCutAtom"""
        return _sim2d.LJAttractIICut_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJAttractIICut self, Box box, IDPair pair) -> flt
        energy(LJAttractIICut self, Box box) -> flt
        """
        return _sim2d.LJAttractIICut_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJAttractIICut self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractIICut_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJAttractIICut self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractIICut_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJAttractIICut self, Box box) -> flt"""
        return _sim2d.LJAttractIICut_pressure(self, box)


    def pair_iter(self) -> "std::vector< LJAttractCutPair > &":
        """pair_iter(LJAttractIICut self) -> std::vector< LJAttractCutPair > &"""
        return _sim2d.LJAttractIICut_pair_iter(self)


    def size(self) -> "uint":
        """size(LJAttractIICut self) -> uint"""
        return _sim2d.LJAttractIICut_size(self)


    def energy_pair(self, pair: 'LJAttractCutPair', box: 'Box') -> "flt":
        """energy_pair(LJAttractIICut self, LJAttractCutPair pair, Box box) -> flt"""
        return _sim2d.LJAttractIICut_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LJAttractIICut self, Box box)"""
        return _sim2d.LJAttractIICut_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LJAttractIICut self, Box box) -> flt"""
        return _sim2d.LJAttractIICut_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LJAttractIICut self, Box box) -> Matrix"""
        return _sim2d.LJAttractIICut_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LJAttractIICut self, Box box) -> Matrix"""
        return _sim2d.LJAttractIICut_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LJAttractCutPair', box: 'Box') -> "Vec":
        """forces_pair(LJAttractIICut self, LJAttractCutPair pair, Box box) -> Vec"""
        return _sim2d.LJAttractIICut_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< IEpsISigCutAtom > &":
        """atom_list(LJAttractIICut self) -> std::vector< IEpsISigCutAtom > &"""
        return _sim2d.LJAttractIICut_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LJAttractIICut self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LJAttractIICut_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LJAttractIICut
    __del__ = lambda self: None
LJAttractIICut_swigregister = _sim2d.LJAttractIICut_swigregister
LJAttractIICut_swigregister(LJAttractIICut)

class LJIICut(Interaction):
    """Proxy of C++ NListed<(IEpsISigCutAtom,LennardJonesCutPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJIICut, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJIICut, name)
    __repr__ = _swig_repr

    def add(self, atm: 'IEpsISigCutAtom') -> "void":
        """add(LJIICut self, IEpsISigCutAtom atm)"""
        return _sim2d.LJIICut_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(IEpsISigCutAtom,LennardJonesCutPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LJIICut
        __init__(NListed<(IEpsISigCutAtom,LennardJonesCutPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LJIICut
        """
        this = _sim2d.new_LJIICut(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJIICut self)"""
        return _sim2d.LJIICut_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LennardJonesCutPair":
        """get_pair(LJIICut self, IDPair pair) -> LennardJonesCutPair"""
        return _sim2d.LJIICut_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "IEpsISigCutAtom &":
        """getatom(LJIICut self, uint n) -> IEpsISigCutAtom"""
        return _sim2d.LJIICut_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJIICut self, Box box, IDPair pair) -> flt
        energy(LJIICut self, Box box) -> flt
        """
        return _sim2d.LJIICut_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJIICut self, Box box) -> unsigned long long"""
        return _sim2d.LJIICut_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJIICut self, Box box) -> unsigned long long"""
        return _sim2d.LJIICut_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJIICut self, Box box) -> flt"""
        return _sim2d.LJIICut_pressure(self, box)


    def pair_iter(self) -> "std::vector< LennardJonesCutPair > &":
        """pair_iter(LJIICut self) -> std::vector< LennardJonesCutPair > &"""
        return _sim2d.LJIICut_pair_iter(self)


    def size(self) -> "uint":
        """size(LJIICut self) -> uint"""
        return _sim2d.LJIICut_size(self)


    def energy_pair(self, pair: 'LennardJonesCutPair', box: 'Box') -> "flt":
        """energy_pair(LJIICut self, LennardJonesCutPair pair, Box box) -> flt"""
        return _sim2d.LJIICut_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LJIICut self, Box box)"""
        return _sim2d.LJIICut_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LJIICut self, Box box) -> flt"""
        return _sim2d.LJIICut_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LJIICut self, Box box) -> Matrix"""
        return _sim2d.LJIICut_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LJIICut self, Box box) -> Matrix"""
        return _sim2d.LJIICut_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LennardJonesCutPair', box: 'Box') -> "Vec":
        """forces_pair(LJIICut self, LennardJonesCutPair pair, Box box) -> Vec"""
        return _sim2d.LJIICut_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< IEpsISigCutAtom > &":
        """atom_list(LJIICut self) -> std::vector< IEpsISigCutAtom > &"""
        return _sim2d.LJIICut_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LJIICut self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LJIICut_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LJIICut
    __del__ = lambda self: None
LJIICut_swigregister = _sim2d.LJIICut_swigregister
LJIICut_swigregister(LJIICut)

class LJAttractRepulse(Interaction):
    """Proxy of C++ NListed<(IEpsSigCutAtom,LJAttractRepulsePair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulse, name)
    __repr__ = _swig_repr

    def add(self, atm: 'IEpsSigCutAtom') -> "void":
        """add(LJAttractRepulse self, IEpsSigCutAtom atm)"""
        return _sim2d.LJAttractRepulse_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(IEpsSigCutAtom,LJAttractRepulsePair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LJAttractRepulse
        __init__(NListed<(IEpsSigCutAtom,LJAttractRepulsePair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LJAttractRepulse
        """
        this = _sim2d.new_LJAttractRepulse(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJAttractRepulse self)"""
        return _sim2d.LJAttractRepulse_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LJAttractRepulsePair":
        """get_pair(LJAttractRepulse self, IDPair pair) -> LJAttractRepulsePair"""
        return _sim2d.LJAttractRepulse_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "IEpsSigCutAtom &":
        """getatom(LJAttractRepulse self, uint n) -> IEpsSigCutAtom"""
        return _sim2d.LJAttractRepulse_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJAttractRepulse self, Box box, IDPair pair) -> flt
        energy(LJAttractRepulse self, Box box) -> flt
        """
        return _sim2d.LJAttractRepulse_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJAttractRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractRepulse_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJAttractRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractRepulse_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_pressure(self, box)


    def pair_iter(self) -> "std::vector< LJAttractRepulsePair > &":
        """pair_iter(LJAttractRepulse self) -> std::vector< LJAttractRepulsePair > &"""
        return _sim2d.LJAttractRepulse_pair_iter(self)


    def size(self) -> "uint":
        """size(LJAttractRepulse self) -> uint"""
        return _sim2d.LJAttractRepulse_size(self)


    def energy_pair(self, pair: 'LJAttractRepulsePair', box: 'Box') -> "flt":
        """energy_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LJAttractRepulse self, Box box)"""
        return _sim2d.LJAttractRepulse_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LJAttractRepulse self, Box box) -> Matrix"""
        return _sim2d.LJAttractRepulse_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LJAttractRepulse self, Box box) -> Matrix"""
        return _sim2d.LJAttractRepulse_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LJAttractRepulsePair', box: 'Box') -> "Vec":
        """forces_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> Vec"""
        return _sim2d.LJAttractRepulse_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< IEpsSigCutAtom > &":
        """atom_list(LJAttractRepulse self) -> std::vector< IEpsSigCutAtom > &"""
        return _sim2d.LJAttractRepulse_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LJAttractRepulse self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LJAttractRepulse_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulse
    __del__ = lambda self: None
LJAttractRepulse_swigregister = _sim2d.LJAttractRepulse_swigregister
LJAttractRepulse_swigregister(LJAttractRepulse)

class LJAttractFixedRepulse(Interaction):
    """Proxy of C++ NListed<(IEpsRepsSigCutAtom,LJAttractFixedRepulsePair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulse, name)
    __repr__ = _swig_repr

    def add(self, atm: 'IEpsRepsSigCutAtom') -> "void":
        """add(LJAttractFixedRepulse self, IEpsRepsSigCutAtom atm)"""
        return _sim2d.LJAttractFixedRepulse_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(IEpsRepsSigCutAtom,LJAttractFixedRepulsePair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LJAttractFixedRepulse
        __init__(NListed<(IEpsRepsSigCutAtom,LJAttractFixedRepulsePair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LJAttractFixedRepulse
        """
        this = _sim2d.new_LJAttractFixedRepulse(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJAttractFixedRepulse self)"""
        return _sim2d.LJAttractFixedRepulse_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LJAttractFixedRepulsePair":
        """get_pair(LJAttractFixedRepulse self, IDPair pair) -> LJAttractFixedRepulsePair"""
        return _sim2d.LJAttractFixedRepulse_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "IEpsRepsSigCutAtom &":
        """getatom(LJAttractFixedRepulse self, uint n) -> IEpsRepsSigCutAtom"""
        return _sim2d.LJAttractFixedRepulse_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJAttractFixedRepulse self, Box box, IDPair pair) -> flt
        energy(LJAttractFixedRepulse self, Box box) -> flt
        """
        return _sim2d.LJAttractFixedRepulse_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJAttractFixedRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractFixedRepulse_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJAttractFixedRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractFixedRepulse_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_pressure(self, box)


    def pair_iter(self) -> "std::vector< LJAttractFixedRepulsePair > &":
        """pair_iter(LJAttractFixedRepulse self) -> std::vector< LJAttractFixedRepulsePair > &"""
        return _sim2d.LJAttractFixedRepulse_pair_iter(self)


    def size(self) -> "uint":
        """size(LJAttractFixedRepulse self) -> uint"""
        return _sim2d.LJAttractFixedRepulse_size(self)


    def energy_pair(self, pair: 'LJAttractFixedRepulsePair', box: 'Box') -> "flt":
        """energy_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LJAttractFixedRepulse self, Box box)"""
        return _sim2d.LJAttractFixedRepulse_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LJAttractFixedRepulse self, Box box) -> Matrix"""
        return _sim2d.LJAttractFixedRepulse_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LJAttractFixedRepulse self, Box box) -> Matrix"""
        return _sim2d.LJAttractFixedRepulse_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LJAttractFixedRepulsePair', box: 'Box') -> "Vec":
        """forces_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> Vec"""
        return _sim2d.LJAttractFixedRepulse_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< IEpsRepsSigCutAtom > &":
        """atom_list(LJAttractFixedRepulse self) -> std::vector< IEpsRepsSigCutAtom > &"""
        return _sim2d.LJAttractFixedRepulse_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LJAttractFixedRepulse self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LJAttractFixedRepulse_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulse
    __del__ = lambda self: None
LJAttractFixedRepulse_swigregister = _sim2d.LJAttractFixedRepulse_swigregister
LJAttractFixedRepulse_swigregister(LJAttractFixedRepulse)

class EisMclachlan(Interaction):
    """Proxy of C++ NListed<(EisMclachlanAtom,EisMclachlanPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlan, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlan, name)
    __repr__ = _swig_repr

    def add(self, atm: 'EisMclachlanAtom') -> "void":
        """add(EisMclachlan self, EisMclachlanAtom atm)"""
        return _sim2d.EisMclachlan_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(EisMclachlanAtom,EisMclachlanPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> EisMclachlan
        __init__(NListed<(EisMclachlanAtom,EisMclachlanPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> EisMclachlan
        """
        this = _sim2d.new_EisMclachlan(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(EisMclachlan self)"""
        return _sim2d.EisMclachlan_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "EisMclachlanPair":
        """get_pair(EisMclachlan self, IDPair pair) -> EisMclachlanPair"""
        return _sim2d.EisMclachlan_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "EisMclachlanAtom &":
        """getatom(EisMclachlan self, uint n) -> EisMclachlanAtom"""
        return _sim2d.EisMclachlan_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(EisMclachlan self, Box box, IDPair pair) -> flt
        energy(EisMclachlan self, Box box) -> flt
        """
        return _sim2d.EisMclachlan_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(EisMclachlan self, Box box) -> unsigned long long"""
        return _sim2d.EisMclachlan_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(EisMclachlan self, Box box) -> unsigned long long"""
        return _sim2d.EisMclachlan_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(EisMclachlan self, Box box) -> flt"""
        return _sim2d.EisMclachlan_pressure(self, box)


    def pair_iter(self) -> "std::vector< EisMclachlanPair > &":
        """pair_iter(EisMclachlan self) -> std::vector< EisMclachlanPair > &"""
        return _sim2d.EisMclachlan_pair_iter(self)


    def size(self) -> "uint":
        """size(EisMclachlan self) -> uint"""
        return _sim2d.EisMclachlan_size(self)


    def energy_pair(self, pair: 'EisMclachlanPair', box: 'Box') -> "flt":
        """energy_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> flt"""
        return _sim2d.EisMclachlan_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(EisMclachlan self, Box box)"""
        return _sim2d.EisMclachlan_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(EisMclachlan self, Box box) -> flt"""
        return _sim2d.EisMclachlan_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(EisMclachlan self, Box box) -> Matrix"""
        return _sim2d.EisMclachlan_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(EisMclachlan self, Box box) -> Matrix"""
        return _sim2d.EisMclachlan_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'EisMclachlanPair', box: 'Box') -> "Vec":
        """forces_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> Vec"""
        return _sim2d.EisMclachlan_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< EisMclachlanAtom > &":
        """atom_list(EisMclachlan self) -> std::vector< EisMclachlanAtom > &"""
        return _sim2d.EisMclachlan_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(EisMclachlan self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.EisMclachlan_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_EisMclachlan
    __del__ = lambda self: None
EisMclachlan_swigregister = _sim2d.EisMclachlan_swigregister
EisMclachlan_swigregister(EisMclachlan)

class LJish(Interaction):
    """Proxy of C++ NListed<(IEpsRepsSigExpCutAtom,LJishPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJish, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJish, name)
    __repr__ = _swig_repr

    def add(self, atm: 'IEpsRepsSigExpCutAtom') -> "void":
        """add(LJish self, IEpsRepsSigExpCutAtom atm)"""
        return _sim2d.LJish_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(IEpsRepsSigExpCutAtom,LJishPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LJish
        __init__(NListed<(IEpsRepsSigExpCutAtom,LJishPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LJish
        """
        this = _sim2d.new_LJish(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJish self)"""
        return _sim2d.LJish_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LJishPair":
        """get_pair(LJish self, IDPair pair) -> LJishPair"""
        return _sim2d.LJish_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "IEpsRepsSigExpCutAtom &":
        """getatom(LJish self, uint n) -> IEpsRepsSigExpCutAtom"""
        return _sim2d.LJish_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJish self, Box box, IDPair pair) -> flt
        energy(LJish self, Box box) -> flt
        """
        return _sim2d.LJish_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJish self, Box box) -> unsigned long long"""
        return _sim2d.LJish_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJish self, Box box) -> unsigned long long"""
        return _sim2d.LJish_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJish self, Box box) -> flt"""
        return _sim2d.LJish_pressure(self, box)


    def pair_iter(self) -> "std::vector< LJishPair > &":
        """pair_iter(LJish self) -> std::vector< LJishPair > &"""
        return _sim2d.LJish_pair_iter(self)


    def size(self) -> "uint":
        """size(LJish self) -> uint"""
        return _sim2d.LJish_size(self)


    def energy_pair(self, pair: 'LJishPair', box: 'Box') -> "flt":
        """energy_pair(LJish self, LJishPair pair, Box box) -> flt"""
        return _sim2d.LJish_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LJish self, Box box)"""
        return _sim2d.LJish_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LJish self, Box box) -> flt"""
        return _sim2d.LJish_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LJish self, Box box) -> Matrix"""
        return _sim2d.LJish_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LJish self, Box box) -> Matrix"""
        return _sim2d.LJish_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LJishPair', box: 'Box') -> "Vec":
        """forces_pair(LJish self, LJishPair pair, Box box) -> Vec"""
        return _sim2d.LJish_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< IEpsRepsSigExpCutAtom > &":
        """atom_list(LJish self) -> std::vector< IEpsRepsSigExpCutAtom > &"""
        return _sim2d.LJish_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LJish self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LJish_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LJish
    __del__ = lambda self: None
LJish_swigregister = _sim2d.LJish_swigregister
LJish_swigregister(LJish)

class RepulsionSimple(Interaction):
    """Proxy of C++ SimpleListed<(EpsSigExpAtom,RepulsionPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RepulsionSimple, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RepulsionSimple, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(SimpleListed<(EpsSigExpAtom,RepulsionPair)> self) -> RepulsionSimple"""
        this = _sim2d.new_RepulsionSimple()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, atm: 'EpsSigExpAtom') -> "void":
        """add(RepulsionSimple self, EpsSigExpAtom atm)"""
        return _sim2d.RepulsionSimple_add(self, atm)


    def energy(self, box: 'Box') -> "flt":
        """energy(RepulsionSimple self, Box box) -> flt"""
        return _sim2d.RepulsionSimple_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(RepulsionSimple self, Box box) -> flt"""
        return _sim2d.RepulsionSimple_pressure(self, box)


    def size(self) -> "uint":
        """size(RepulsionSimple self) -> uint"""
        return _sim2d.RepulsionSimple_size(self)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(RepulsionSimple self, Box box)"""
        return _sim2d.RepulsionSimple_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(RepulsionSimple self, Box box) -> flt"""
        return _sim2d.RepulsionSimple_set_forces_get_pressure(self, box)


    def atom_list(self) -> "std::vector< EpsSigExpAtom > &":
        """atom_list(RepulsionSimple self) -> std::vector< EpsSigExpAtom > &"""
        return _sim2d.RepulsionSimple_atom_list(self)

    __swig_destroy__ = _sim2d.delete_RepulsionSimple
    __del__ = lambda self: None
RepulsionSimple_swigregister = _sim2d.RepulsionSimple_swigregister
RepulsionSimple_swigregister(RepulsionSimple)

class Repulsion(Interaction):
    """Proxy of C++ NListed<(EpsSigExpAtom,RepulsionPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Repulsion, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Repulsion, name)
    __repr__ = _swig_repr

    def add(self, atm: 'EpsSigExpAtom') -> "void":
        """add(Repulsion self, EpsSigExpAtom atm)"""
        return _sim2d.Repulsion_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(EpsSigExpAtom,RepulsionPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> Repulsion
        __init__(NListed<(EpsSigExpAtom,RepulsionPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> Repulsion
        """
        this = _sim2d.new_Repulsion(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(Repulsion self)"""
        return _sim2d.Repulsion_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "RepulsionPair":
        """get_pair(Repulsion self, IDPair pair) -> RepulsionPair"""
        return _sim2d.Repulsion_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "EpsSigExpAtom &":
        """getatom(Repulsion self, uint n) -> EpsSigExpAtom"""
        return _sim2d.Repulsion_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(Repulsion self, Box box, IDPair pair) -> flt
        energy(Repulsion self, Box box) -> flt
        """
        return _sim2d.Repulsion_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(Repulsion self, Box box) -> unsigned long long"""
        return _sim2d.Repulsion_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(Repulsion self, Box box) -> unsigned long long"""
        return _sim2d.Repulsion_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(Repulsion self, Box box) -> flt"""
        return _sim2d.Repulsion_pressure(self, box)


    def pair_iter(self) -> "std::vector< RepulsionPair > &":
        """pair_iter(Repulsion self) -> std::vector< RepulsionPair > &"""
        return _sim2d.Repulsion_pair_iter(self)


    def size(self) -> "uint":
        """size(Repulsion self) -> uint"""
        return _sim2d.Repulsion_size(self)


    def energy_pair(self, pair: 'RepulsionPair', box: 'Box') -> "flt":
        """energy_pair(Repulsion self, RepulsionPair pair, Box box) -> flt"""
        return _sim2d.Repulsion_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(Repulsion self, Box box)"""
        return _sim2d.Repulsion_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(Repulsion self, Box box) -> flt"""
        return _sim2d.Repulsion_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(Repulsion self, Box box) -> Matrix"""
        return _sim2d.Repulsion_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(Repulsion self, Box box) -> Matrix"""
        return _sim2d.Repulsion_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'RepulsionPair', box: 'Box') -> "Vec":
        """forces_pair(Repulsion self, RepulsionPair pair, Box box) -> Vec"""
        return _sim2d.Repulsion_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< EpsSigExpAtom > &":
        """atom_list(Repulsion self) -> std::vector< EpsSigExpAtom > &"""
        return _sim2d.Repulsion_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(Repulsion self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.Repulsion_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_Repulsion
    __del__ = lambda self: None
Repulsion_swigregister = _sim2d.Repulsion_swigregister
Repulsion_swigregister(Repulsion)

class RepulsionII(Interaction):
    """Proxy of C++ NListed<(IEpsISigExpAtom,RepulsionPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RepulsionII, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RepulsionII, name)
    __repr__ = _swig_repr

    def add(self, atm: 'IEpsISigExpAtom') -> "void":
        """add(RepulsionII self, IEpsISigExpAtom atm)"""
        return _sim2d.RepulsionII_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(IEpsISigExpAtom,RepulsionPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> RepulsionII
        __init__(NListed<(IEpsISigExpAtom,RepulsionPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> RepulsionII
        """
        this = _sim2d.new_RepulsionII(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(RepulsionII self)"""
        return _sim2d.RepulsionII_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "RepulsionPair":
        """get_pair(RepulsionII self, IDPair pair) -> RepulsionPair"""
        return _sim2d.RepulsionII_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "IEpsISigExpAtom &":
        """getatom(RepulsionII self, uint n) -> IEpsISigExpAtom"""
        return _sim2d.RepulsionII_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(RepulsionII self, Box box, IDPair pair) -> flt
        energy(RepulsionII self, Box box) -> flt
        """
        return _sim2d.RepulsionII_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(RepulsionII self, Box box) -> unsigned long long"""
        return _sim2d.RepulsionII_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(RepulsionII self, Box box) -> unsigned long long"""
        return _sim2d.RepulsionII_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(RepulsionII self, Box box) -> flt"""
        return _sim2d.RepulsionII_pressure(self, box)


    def pair_iter(self) -> "std::vector< RepulsionPair > &":
        """pair_iter(RepulsionII self) -> std::vector< RepulsionPair > &"""
        return _sim2d.RepulsionII_pair_iter(self)


    def size(self) -> "uint":
        """size(RepulsionII self) -> uint"""
        return _sim2d.RepulsionII_size(self)


    def energy_pair(self, pair: 'RepulsionPair', box: 'Box') -> "flt":
        """energy_pair(RepulsionII self, RepulsionPair pair, Box box) -> flt"""
        return _sim2d.RepulsionII_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(RepulsionII self, Box box)"""
        return _sim2d.RepulsionII_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(RepulsionII self, Box box) -> flt"""
        return _sim2d.RepulsionII_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(RepulsionII self, Box box) -> Matrix"""
        return _sim2d.RepulsionII_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(RepulsionII self, Box box) -> Matrix"""
        return _sim2d.RepulsionII_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'RepulsionPair', box: 'Box') -> "Vec":
        """forces_pair(RepulsionII self, RepulsionPair pair, Box box) -> Vec"""
        return _sim2d.RepulsionII_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< IEpsISigExpAtom > &":
        """atom_list(RepulsionII self) -> std::vector< IEpsISigExpAtom > &"""
        return _sim2d.RepulsionII_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(RepulsionII self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.RepulsionII_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_RepulsionII
    __del__ = lambda self: None
RepulsionII_swigregister = _sim2d.RepulsionII_swigregister
RepulsionII_swigregister(RepulsionII)

class HertzianDrag(Interaction):
    """Proxy of C++ NListed<(EpsSigExpDragAtom,RepulsionDragPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianDrag, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianDrag, name)
    __repr__ = _swig_repr

    def add(self, atm: 'EpsSigExpDragAtom') -> "void":
        """add(HertzianDrag self, EpsSigExpDragAtom atm)"""
        return _sim2d.HertzianDrag_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(EpsSigExpDragAtom,RepulsionDragPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> HertzianDrag
        __init__(NListed<(EpsSigExpDragAtom,RepulsionDragPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> HertzianDrag
        """
        this = _sim2d.new_HertzianDrag(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(HertzianDrag self)"""
        return _sim2d.HertzianDrag_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "RepulsionDragPair":
        """get_pair(HertzianDrag self, IDPair pair) -> RepulsionDragPair"""
        return _sim2d.HertzianDrag_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "EpsSigExpDragAtom &":
        """getatom(HertzianDrag self, uint n) -> EpsSigExpDragAtom"""
        return _sim2d.HertzianDrag_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(HertzianDrag self, Box box, IDPair pair) -> flt
        energy(HertzianDrag self, Box box) -> flt
        """
        return _sim2d.HertzianDrag_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(HertzianDrag self, Box box) -> unsigned long long"""
        return _sim2d.HertzianDrag_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(HertzianDrag self, Box box) -> unsigned long long"""
        return _sim2d.HertzianDrag_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianDrag self, Box box) -> flt"""
        return _sim2d.HertzianDrag_pressure(self, box)


    def pair_iter(self) -> "std::vector< RepulsionDragPair > &":
        """pair_iter(HertzianDrag self) -> std::vector< RepulsionDragPair > &"""
        return _sim2d.HertzianDrag_pair_iter(self)


    def size(self) -> "uint":
        """size(HertzianDrag self) -> uint"""
        return _sim2d.HertzianDrag_size(self)


    def energy_pair(self, pair: 'RepulsionDragPair', box: 'Box') -> "flt":
        """energy_pair(HertzianDrag self, RepulsionDragPair pair, Box box) -> flt"""
        return _sim2d.HertzianDrag_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(HertzianDrag self, Box box)"""
        return _sim2d.HertzianDrag_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(HertzianDrag self, Box box) -> flt"""
        return _sim2d.HertzianDrag_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(HertzianDrag self, Box box) -> Matrix"""
        return _sim2d.HertzianDrag_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(HertzianDrag self, Box box) -> Matrix"""
        return _sim2d.HertzianDrag_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'RepulsionDragPair', box: 'Box') -> "Vec":
        """forces_pair(HertzianDrag self, RepulsionDragPair pair, Box box) -> Vec"""
        return _sim2d.HertzianDrag_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< EpsSigExpDragAtom > &":
        """atom_list(HertzianDrag self) -> std::vector< EpsSigExpDragAtom > &"""
        return _sim2d.HertzianDrag_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(HertzianDrag self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.HertzianDrag_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_HertzianDrag
    __del__ = lambda self: None
HertzianDrag_swigregister = _sim2d.HertzianDrag_swigregister
HertzianDrag_swigregister(HertzianDrag)

class HertzianSC(Interaction):
    """Proxy of C++ SCBoxed<(EpsSigExpAtom,RepulsionPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianSC, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianSC, name)
    __repr__ = _swig_repr

    def __init__(self, atomv: 'boost::shared_ptr< AtomVec >', box: 'boost::shared_ptr< SCBox >'):
        """__init__(SCBoxed<(EpsSigExpAtom,RepulsionPair)> self, boost::shared_ptr< AtomVec > atomv, boost::shared_ptr< SCBox > box) -> HertzianSC"""
        this = _sim2d.new_HertzianSC(atomv, box)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, atm: 'EpsSigExpAtom') -> "void":
        """add(HertzianSC self, EpsSigExpAtom atm)"""
        return _sim2d.HertzianSC_add(self, atm)


    def energy(self, box: 'Box') -> "flt":
        """energy(HertzianSC self, Box box) -> flt"""
        return _sim2d.HertzianSC_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianSC self, Box box) -> flt"""
        return _sim2d.HertzianSC_pressure(self, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(HertzianSC self, Box box)"""
        return _sim2d.HertzianSC_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(HertzianSC self, Box box) -> flt"""
        return _sim2d.HertzianSC_set_forces_get_pressure(self, box)


    def atom_list(self) -> "std::vector< EpsSigExpAtom > &":
        """atom_list(HertzianSC self) -> std::vector< EpsSigExpAtom > &"""
        return _sim2d.HertzianSC_atom_list(self)

    __swig_destroy__ = _sim2d.delete_HertzianSC
    __del__ = lambda self: None
HertzianSC_swigregister = _sim2d.HertzianSC_swigregister
HertzianSC_swigregister(HertzianSC)

class HertzianVirial(InteractionPairsX):
    """Proxy of C++ NListedVirial<(EpsSigExpAtom,RepulsionPair)> class."""

    __swig_setmethods__ = {}
    for _s in [InteractionPairsX]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianVirial, name, value)
    __swig_getmethods__ = {}
    for _s in [InteractionPairsX]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianVirial, name)
    __repr__ = _swig_repr

    def __init__(self, vec: 'boost::shared_ptr< AtomVec >', neighbors: 'boost::shared_ptr< NeighborList >'):
        """__init__(NListedVirial<(EpsSigExpAtom,RepulsionPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> HertzianVirial"""
        this = _sim2d.new_HertzianVirial(vec, neighbors)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_forces(self, *args) -> "void":
        """
        set_forces(HertzianVirial self, Box box)
        set_forces(HertzianVirial self, Box box, FPairXFunct arg3)
        """
        return _sim2d.HertzianVirial_set_forces(self, *args)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_set_forces_get_pressure(self, box)


    def setForcesGetEnergy(self, box: 'Box') -> "flt":
        """setForcesGetEnergy(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_setForcesGetEnergy(self, box)


    def energy(self, box: 'Box') -> "flt":
        """energy(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_pressure(self, box)


    def add(self, atm: 'EpsSigExpAtom') -> "void":
        """add(HertzianVirial self, EpsSigExpAtom atm)"""
        return _sim2d.HertzianVirial_add(self, atm)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(HertzianVirial self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.HertzianVirial_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_HertzianVirial
    __del__ = lambda self: None
HertzianVirial_swigregister = _sim2d.HertzianVirial_swigregister
HertzianVirial_swigregister(HertzianVirial)

class LoisOhern(Interaction):
    """Proxy of C++ NListed<(LoisOhernAtom,LoisOhernPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhern, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhern, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisOhernAtom') -> "void":
        """add(LoisOhern self, LoisOhernAtom atm)"""
        return _sim2d.LoisOhern_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisOhernAtom,LoisOhernPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LoisOhern
        __init__(NListed<(LoisOhernAtom,LoisOhernPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LoisOhern
        """
        this = _sim2d.new_LoisOhern(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisOhern self)"""
        return _sim2d.LoisOhern_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LoisOhernPair":
        """get_pair(LoisOhern self, IDPair pair) -> LoisOhernPair"""
        return _sim2d.LoisOhern_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "LoisOhernAtom &":
        """getatom(LoisOhern self, uint n) -> LoisOhernAtom"""
        return _sim2d.LoisOhern_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisOhern self, Box box, IDPair pair) -> flt
        energy(LoisOhern self, Box box) -> flt
        """
        return _sim2d.LoisOhern_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisOhern self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhern_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisOhern self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhern_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisOhern self, Box box) -> flt"""
        return _sim2d.LoisOhern_pressure(self, box)


    def pair_iter(self) -> "std::vector< LoisOhernPair > &":
        """pair_iter(LoisOhern self) -> std::vector< LoisOhernPair > &"""
        return _sim2d.LoisOhern_pair_iter(self)


    def size(self) -> "uint":
        """size(LoisOhern self) -> uint"""
        return _sim2d.LoisOhern_size(self)


    def energy_pair(self, pair: 'LoisOhernPair', box: 'Box') -> "flt":
        """energy_pair(LoisOhern self, LoisOhernPair pair, Box box) -> flt"""
        return _sim2d.LoisOhern_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LoisOhern self, Box box)"""
        return _sim2d.LoisOhern_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LoisOhern self, Box box) -> flt"""
        return _sim2d.LoisOhern_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LoisOhern self, Box box) -> Matrix"""
        return _sim2d.LoisOhern_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LoisOhern self, Box box) -> Matrix"""
        return _sim2d.LoisOhern_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LoisOhernPair', box: 'Box') -> "Vec":
        """forces_pair(LoisOhern self, LoisOhernPair pair, Box box) -> Vec"""
        return _sim2d.LoisOhern_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisOhernAtom > &":
        """atom_list(LoisOhern self) -> std::vector< LoisOhernAtom > &"""
        return _sim2d.LoisOhern_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LoisOhern self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LoisOhern_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LoisOhern
    __del__ = lambda self: None
LoisOhern_swigregister = _sim2d.LoisOhern_swigregister
LoisOhern_swigregister(LoisOhern)

class LoisLin(Interaction):
    """Proxy of C++ NListed<(LoisLinAtom,LoisLinPair)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLin, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLin, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisLinAtom') -> "void":
        """add(LoisLin self, LoisLinAtom atm)"""
        return _sim2d.LoisLin_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisLinAtom,LoisLinPair)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LoisLin
        __init__(NListed<(LoisLinAtom,LoisLinPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LoisLin
        """
        this = _sim2d.new_LoisLin(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisLin self)"""
        return _sim2d.LoisLin_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LoisLinPair":
        """get_pair(LoisLin self, IDPair pair) -> LoisLinPair"""
        return _sim2d.LoisLin_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "LoisLinAtom &":
        """getatom(LoisLin self, uint n) -> LoisLinAtom"""
        return _sim2d.LoisLin_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisLin self, Box box, IDPair pair) -> flt
        energy(LoisLin self, Box box) -> flt
        """
        return _sim2d.LoisLin_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisLin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLin_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisLin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLin_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisLin self, Box box) -> flt"""
        return _sim2d.LoisLin_pressure(self, box)


    def pair_iter(self) -> "std::vector< LoisLinPair > &":
        """pair_iter(LoisLin self) -> std::vector< LoisLinPair > &"""
        return _sim2d.LoisLin_pair_iter(self)


    def size(self) -> "uint":
        """size(LoisLin self) -> uint"""
        return _sim2d.LoisLin_size(self)


    def energy_pair(self, pair: 'LoisLinPair', box: 'Box') -> "flt":
        """energy_pair(LoisLin self, LoisLinPair pair, Box box) -> flt"""
        return _sim2d.LoisLin_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LoisLin self, Box box)"""
        return _sim2d.LoisLin_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LoisLin self, Box box) -> flt"""
        return _sim2d.LoisLin_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LoisLin self, Box box) -> Matrix"""
        return _sim2d.LoisLin_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LoisLin self, Box box) -> Matrix"""
        return _sim2d.LoisLin_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LoisLinPair', box: 'Box') -> "Vec":
        """forces_pair(LoisLin self, LoisLinPair pair, Box box) -> Vec"""
        return _sim2d.LoisLin_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisLinAtom > &":
        """atom_list(LoisLin self) -> std::vector< LoisLinAtom > &"""
        return _sim2d.LoisLin_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LoisLin self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LoisLin_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LoisLin
    __del__ = lambda self: None
LoisLin_swigregister = _sim2d.LoisLin_swigregister
LoisLin_swigregister(LoisLin)

class LoisLinMin(Interaction):
    """Proxy of C++ NListed<(LoisLinAtom,LoisLinPairMin)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinMin, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinMin, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisLinAtom') -> "void":
        """add(LoisLinMin self, LoisLinAtom atm)"""
        return _sim2d.LoisLinMin_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisLinAtom,LoisLinPairMin)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LoisLinMin
        __init__(NListed<(LoisLinAtom,LoisLinPairMin)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LoisLinMin
        """
        this = _sim2d.new_LoisLinMin(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisLinMin self)"""
        return _sim2d.LoisLinMin_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LoisLinPairMin":
        """get_pair(LoisLinMin self, IDPair pair) -> LoisLinPairMin"""
        return _sim2d.LoisLinMin_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "LoisLinAtom &":
        """getatom(LoisLinMin self, uint n) -> LoisLinAtom"""
        return _sim2d.LoisLinMin_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisLinMin self, Box box, IDPair pair) -> flt
        energy(LoisLinMin self, Box box) -> flt
        """
        return _sim2d.LoisLinMin_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisLinMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLinMin_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisLinMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLinMin_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisLinMin self, Box box) -> flt"""
        return _sim2d.LoisLinMin_pressure(self, box)


    def pair_iter(self) -> "std::vector< LoisLinPairMin > &":
        """pair_iter(LoisLinMin self) -> std::vector< LoisLinPairMin > &"""
        return _sim2d.LoisLinMin_pair_iter(self)


    def size(self) -> "uint":
        """size(LoisLinMin self) -> uint"""
        return _sim2d.LoisLinMin_size(self)


    def energy_pair(self, pair: 'LoisLinPairMin', box: 'Box') -> "flt":
        """energy_pair(LoisLinMin self, LoisLinPairMin pair, Box box) -> flt"""
        return _sim2d.LoisLinMin_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LoisLinMin self, Box box)"""
        return _sim2d.LoisLinMin_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LoisLinMin self, Box box) -> flt"""
        return _sim2d.LoisLinMin_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LoisLinMin self, Box box) -> Matrix"""
        return _sim2d.LoisLinMin_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LoisLinMin self, Box box) -> Matrix"""
        return _sim2d.LoisLinMin_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LoisLinPairMin', box: 'Box') -> "Vec":
        """forces_pair(LoisLinMin self, LoisLinPairMin pair, Box box) -> Vec"""
        return _sim2d.LoisLinMin_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisLinAtom > &":
        """atom_list(LoisLinMin self) -> std::vector< LoisLinAtom > &"""
        return _sim2d.LoisLinMin_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LoisLinMin self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LoisLinMin_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LoisLinMin
    __del__ = lambda self: None
LoisLinMin_swigregister = _sim2d.LoisLinMin_swigregister
LoisLinMin_swigregister(LoisLinMin)

class LoisOhernMin(Interaction):
    """Proxy of C++ NListed<(LoisOhernAtom,LoisOhernPairMinCLs)> class."""

    __swig_setmethods__ = {}
    for _s in [Interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernMin, name, value)
    __swig_getmethods__ = {}
    for _s in [Interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernMin, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisOhernAtom') -> "void":
        """add(LoisOhernMin self, LoisOhernAtom atm)"""
        return _sim2d.LoisOhernMin_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisOhernAtom,LoisOhernPairMinCLs)> self, boost::shared_ptr< AtomVec > vec, boost::shared_ptr< NeighborList > neighbors) -> LoisOhernMin
        __init__(NListed<(LoisOhernAtom,LoisOhernPairMinCLs)> self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomVec > atomv, flt const skin) -> LoisOhernMin
        """
        this = _sim2d.new_LoisOhernMin(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisOhernMin self)"""
        return _sim2d.LoisOhernMin_update_pairs(self)


    def get_pair(self, pair: 'IDPair') -> "LoisOhernPairMinCLs":
        """get_pair(LoisOhernMin self, IDPair pair) -> LoisOhernPairMinCLs"""
        return _sim2d.LoisOhernMin_get_pair(self, pair)


    def getatom(self, n: 'uint') -> "LoisOhernAtom &":
        """getatom(LoisOhernMin self, uint n) -> LoisOhernAtom"""
        return _sim2d.LoisOhernMin_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisOhernMin self, Box box, IDPair pair) -> flt
        energy(LoisOhernMin self, Box box) -> flt
        """
        return _sim2d.LoisOhernMin_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisOhernMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhernMin_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisOhernMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhernMin_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisOhernMin self, Box box) -> flt"""
        return _sim2d.LoisOhernMin_pressure(self, box)


    def pair_iter(self) -> "std::vector< LoisOhernPairMinCLs > &":
        """pair_iter(LoisOhernMin self) -> std::vector< LoisOhernPairMinCLs > &"""
        return _sim2d.LoisOhernMin_pair_iter(self)


    def size(self) -> "uint":
        """size(LoisOhernMin self) -> uint"""
        return _sim2d.LoisOhernMin_size(self)


    def energy_pair(self, pair: 'LoisOhernPairMinCLs', box: 'Box') -> "flt":
        """energy_pair(LoisOhernMin self, LoisOhernPairMinCLs pair, Box box) -> flt"""
        return _sim2d.LoisOhernMin_energy_pair(self, pair, box)


    def set_forces(self, box: 'Box') -> "void":
        """set_forces(LoisOhernMin self, Box box)"""
        return _sim2d.LoisOhernMin_set_forces(self, box)


    def set_forces_get_pressure(self, box: 'Box') -> "flt":
        """set_forces_get_pressure(LoisOhernMin self, Box box) -> flt"""
        return _sim2d.LoisOhernMin_set_forces_get_pressure(self, box)


    def stress(self, box: 'Box') -> "Matrix":
        """stress(LoisOhernMin self, Box box) -> Matrix"""
        return _sim2d.LoisOhernMin_stress(self, box)


    def set_forces_get_stress(self, box: 'Box') -> "Matrix":
        """set_forces_get_stress(LoisOhernMin self, Box box) -> Matrix"""
        return _sim2d.LoisOhernMin_set_forces_get_stress(self, box)


    def forces_pair(self, pair: 'LoisOhernPairMinCLs', box: 'Box') -> "Vec":
        """forces_pair(LoisOhernMin self, LoisOhernPairMinCLs pair, Box box) -> Vec"""
        return _sim2d.LoisOhernMin_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisOhernAtom > &":
        """atom_list(LoisOhernMin self) -> std::vector< LoisOhernAtom > &"""
        return _sim2d.LoisOhernMin_atom_list(self)


    def neighbor_list(self) -> "boost::shared_ptr< NeighborList >":
        """neighbor_list(LoisOhernMin self) -> boost::shared_ptr< NeighborList >"""
        return _sim2d.LoisOhernMin_neighbor_list(self)

    __swig_destroy__ = _sim2d.delete_LoisOhernMin
    __del__ = lambda self: None
LoisOhernMin_swigregister = _sim2d.LoisOhernMin_swigregister
LoisOhernMin_swigregister(LoisOhernMin)

class Collection(_object):
    """Proxy of C++ Collection class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Collection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Collection, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def initialize(self) -> "void":
        """initialize(Collection self)"""
        return _sim2d.Collection_initialize(self)


    def set_forces(self, constraints_and_a: 'bool'=True) -> "void":
        """
        set_forces(Collection self, bool constraints_and_a=True)
        set_forces(Collection self)
        """
        return _sim2d.Collection_set_forces(self, constraints_and_a)


    def timestep(self) -> "void":
        """timestep(Collection self)"""
        return _sim2d.Collection_timestep(self)


    def degrees_of_freedom(self) -> "flt":
        """degrees_of_freedom(Collection self) -> flt"""
        return _sim2d.Collection_degrees_of_freedom(self)


    def potential_energy(self) -> "flt":
        """potential_energy(Collection self) -> flt"""
        return _sim2d.Collection_potential_energy(self)


    def energy(self) -> "flt":
        """energy(Collection self) -> flt"""
        return _sim2d.Collection_energy(self)


    def temp(self, minuscomv: 'bool'=True) -> "flt":
        """
        temp(Collection self, bool minuscomv=True) -> flt
        temp(Collection self) -> flt
        """
        return _sim2d.Collection_temp(self, minuscomv)


    def kinetic_energy(self) -> "flt":
        """kinetic_energy(Collection self) -> flt"""
        return _sim2d.Collection_kinetic_energy(self)


    def virial(self) -> "flt":
        """virial(Collection self) -> flt"""
        return _sim2d.Collection_virial(self)


    def pressure(self) -> "flt":
        """pressure(Collection self) -> flt"""
        return _sim2d.Collection_pressure(self)


    def get_box(self) -> "boost::shared_ptr< Box >":
        """get_box(Collection self) -> boost::shared_ptr< Box >"""
        return _sim2d.Collection_get_box(self)


    def com(self) -> "Vec":
        """com(Collection self) -> Vec"""
        return _sim2d.Collection_com(self)


    def com_velocity(self) -> "Vec":
        """com_velocity(Collection self) -> Vec"""
        return _sim2d.Collection_com_velocity(self)


    def angular_momentum(self, *args) -> "flt":
        """
        angular_momentum(Collection self, Vec const & loc) -> flt
        angular_momentum(Collection self) -> flt
        """
        return _sim2d.Collection_angular_momentum(self, *args)


    def gyradius(self) -> "flt":
        """gyradius(Collection self) -> flt"""
        return _sim2d.Collection_gyradius(self)

    __swig_destroy__ = _sim2d.delete_Collection
    __del__ = lambda self: None

    def reset_com_velocity(self) -> "void":
        """reset_com_velocity(Collection self)"""
        return _sim2d.Collection_reset_com_velocity(self)


    def reset_L(self) -> "void":
        """reset_L(Collection self)"""
        return _sim2d.Collection_reset_L(self)


    def scale_velocities(self, scaleby: 'flt') -> "void":
        """scale_velocities(Collection self, flt scaleby)"""
        return _sim2d.Collection_scale_velocities(self, scaleby)


    def scale_velocities_to_temp(self, T: 'flt', minuscomv: 'bool'=True) -> "void":
        """
        scale_velocities_to_temp(Collection self, flt T, bool minuscomv=True)
        scale_velocities_to_temp(Collection self, flt T)
        """
        return _sim2d.Collection_scale_velocities_to_temp(self, T, minuscomv)


    def scale_velocities_to_energy(self, E: 'flt') -> "void":
        """scale_velocities_to_energy(Collection self, flt E)"""
        return _sim2d.Collection_scale_velocities_to_energy(self, E)


    def add_interaction(self, inter: 'boost::shared_ptr< Interaction >') -> "void":
        """add_interaction(Collection self, boost::shared_ptr< Interaction > inter)"""
        return _sim2d.Collection_add_interaction(self, inter)


    def add_tracker(self, track: 'boost::shared_ptr< StateTracker >') -> "void":
        """add_tracker(Collection self, boost::shared_ptr< StateTracker > track)"""
        return _sim2d.Collection_add_tracker(self, track)


    def add_constraint(self, c: 'boost::shared_ptr< Constraint >') -> "void":
        """add_constraint(Collection self, boost::shared_ptr< Constraint > c)"""
        return _sim2d.Collection_add_constraint(self, c)


    def add(self, *args) -> "void":
        """
        add(Collection self, boost::shared_ptr< Interaction > a)
        add(Collection self, boost::shared_ptr< StateTracker > a)
        add(Collection self, boost::shared_ptr< Constraint > a)
        """
        return _sim2d.Collection_add(self, *args)


    def get_interactions(self) -> "std::vector< boost::shared_ptr< Interaction > >":
        """get_interactions(Collection self) -> ivector"""
        return _sim2d.Collection_get_interactions(self)

Collection_swigregister = _sim2d.Collection_swigregister
Collection_swigregister(Collection)

class StaticCollec(Collection):
    """Proxy of C++ StaticCollec class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StaticCollec, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StaticCollec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, ivector interactions, tvector trackers, constraintvector constraints) -> StaticCollec
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, ivector interactions, tvector trackers) -> StaticCollec
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, ivector interactions) -> StaticCollec
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms) -> StaticCollec
        """
        this = _sim2d.new_StaticCollec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(StaticCollec self)"""
        return _sim2d.StaticCollec_timestep(self)


    def update(self) -> "void":
        """update(StaticCollec self)"""
        return _sim2d.StaticCollec_update(self)

    __swig_destroy__ = _sim2d.delete_StaticCollec
    __del__ = lambda self: None
StaticCollec_swigregister = _sim2d.StaticCollec_swigregister
StaticCollec_swigregister(StaticCollec)

class CollectionSol(Collection):
    """Proxy of C++ CollectionSol class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionSol, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionSol, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionSol
        __init__(CollectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature, ivector interactions, tvector trackers) -> CollectionSol
        __init__(CollectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature, ivector interactions) -> CollectionSol
        __init__(CollectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature) -> CollectionSol
        """
        this = _sim2d.new_CollectionSol(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def change_temperature(self, damp: 'flt const', desired_temperature: 'flt const') -> "void":
        """change_temperature(CollectionSol self, flt const damp, flt const desired_temperature)"""
        return _sim2d.CollectionSol_change_temperature(self, damp, desired_temperature)


    def change_force(self, damp: 'flt const', fmag: 'flt const', desired_temperature: 'flt const') -> "void":
        """change_force(CollectionSol self, flt const damp, flt const fmag, flt const desired_temperature)"""
        return _sim2d.CollectionSol_change_force(self, damp, fmag, desired_temperature)


    def set_dt(self, newdt: 'flt const') -> "void":
        """set_dt(CollectionSol self, flt const newdt)"""
        return _sim2d.CollectionSol_set_dt(self, newdt)


    def timestep(self) -> "void":
        """timestep(CollectionSol self)"""
        return _sim2d.CollectionSol_timestep(self)

    __swig_destroy__ = _sim2d.delete_CollectionSol
    __del__ = lambda self: None
CollectionSol_swigregister = _sim2d.CollectionSol_swigregister
CollectionSol_swigregister(CollectionSol)

class CollectionDamped(Collection):
    """Proxy of C++ CollectionDamped class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionDamped, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionDamped, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionDamped
        __init__(CollectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, ivector interactions, tvector trackers) -> CollectionDamped
        __init__(CollectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, ivector interactions) -> CollectionDamped
        __init__(CollectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping) -> CollectionDamped
        """
        this = _sim2d.new_CollectionDamped(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def change_damping(self, damp: 'flt const') -> "void":
        """change_damping(CollectionDamped self, flt const damp)"""
        return _sim2d.CollectionDamped_change_damping(self, damp)


    def set_dt(self, newdt: 'flt const') -> "void":
        """set_dt(CollectionDamped self, flt const newdt)"""
        return _sim2d.CollectionDamped_set_dt(self, newdt)


    def timestep(self) -> "void":
        """timestep(CollectionDamped self)"""
        return _sim2d.CollectionDamped_timestep(self)

    __swig_destroy__ = _sim2d.delete_CollectionDamped
    __del__ = lambda self: None
CollectionDamped_swigregister = _sim2d.CollectionDamped_swigregister
CollectionDamped_swigregister(CollectionDamped)

class CollectionSolHT(Collection):
    """Proxy of C++ CollectionSolHT class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionSolHT, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionSolHT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionSolHT
        __init__(CollectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature, ivector interactions, tvector trackers) -> CollectionSolHT
        __init__(CollectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature, ivector interactions) -> CollectionSolHT
        __init__(CollectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const damping, flt const desired_temperature) -> CollectionSolHT
        """
        this = _sim2d.new_CollectionSolHT(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def change_temperature(self, newdt: 'flt const', damp: 'flt const', desired_temperature: 'flt const') -> "void":
        """change_temperature(CollectionSolHT self, flt const newdt, flt const damp, flt const desired_temperature)"""
        return _sim2d.CollectionSolHT_change_temperature(self, newdt, damp, desired_temperature)


    def timestep(self) -> "void":
        """timestep(CollectionSolHT self)"""
        return _sim2d.CollectionSolHT_timestep(self)

    __swig_destroy__ = _sim2d.delete_CollectionSolHT
    __del__ = lambda self: None
CollectionSolHT_swigregister = _sim2d.CollectionSolHT_swigregister
CollectionSolHT_swigregister(CollectionSolHT)

class CollectionVerlet(Collection):
    """Proxy of C++ CollectionVerlet class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionVerlet, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionVerlet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionVerlet
        __init__(CollectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers) -> CollectionVerlet
        __init__(CollectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions) -> CollectionVerlet
        __init__(CollectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionVerlet
        """
        this = _sim2d.new_CollectionVerlet(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionVerlet self)"""
        return _sim2d.CollectionVerlet_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionVerlet self, flt newdt)"""
        return _sim2d.CollectionVerlet_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionVerlet
    __del__ = lambda self: None
CollectionVerlet_swigregister = _sim2d.CollectionVerlet_swigregister
CollectionVerlet_swigregister(CollectionVerlet)

class CollectionOverdamped(Collection):
    """Proxy of C++ CollectionOverdamped class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionOverdamped, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionOverdamped, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const gamma=1.0, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionOverdamped
        __init__(CollectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const gamma=1.0, ivector interactions, tvector trackers) -> CollectionOverdamped
        __init__(CollectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const gamma=1.0, ivector interactions) -> CollectionOverdamped
        __init__(CollectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const gamma=1.0) -> CollectionOverdamped
        __init__(CollectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionOverdamped
        """
        this = _sim2d.new_CollectionOverdamped(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionOverdamped self)"""
        return _sim2d.CollectionOverdamped_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionOverdamped self, flt newdt)"""
        return _sim2d.CollectionOverdamped_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionOverdamped
    __del__ = lambda self: None
CollectionOverdamped_swigregister = _sim2d.CollectionOverdamped_swigregister
CollectionOverdamped_swigregister(CollectionOverdamped)

class CollectionNLCG(Collection):
    """Proxy of C++ CollectionNLCG class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionNLCG, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionNLCG, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.CollectionNLCG_dt_set
    __swig_getmethods__["dt"] = _sim2d.CollectionNLCG_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.CollectionNLCG_dt_get, _sim2d.CollectionNLCG_dt_set)
    __swig_setmethods__["seceps"] = _sim2d.CollectionNLCG_seceps_set
    __swig_getmethods__["seceps"] = _sim2d.CollectionNLCG_seceps_get
    if _newclass:
        seceps = _swig_property(_sim2d.CollectionNLCG_seceps_get, _sim2d.CollectionNLCG_seceps_set)
    __swig_setmethods__["secmax"] = _sim2d.CollectionNLCG_secmax_set
    __swig_getmethods__["secmax"] = _sim2d.CollectionNLCG_secmax_get
    if _newclass:
        secmax = _swig_property(_sim2d.CollectionNLCG_secmax_get, _sim2d.CollectionNLCG_secmax_set)
    __swig_setmethods__["kappa"] = _sim2d.CollectionNLCG_kappa_set
    __swig_getmethods__["kappa"] = _sim2d.CollectionNLCG_kappa_get
    if _newclass:
        kappa = _swig_property(_sim2d.CollectionNLCG_kappa_get, _sim2d.CollectionNLCG_kappa_set)
    __swig_setmethods__["alphamax"] = _sim2d.CollectionNLCG_alphamax_set
    __swig_getmethods__["alphamax"] = _sim2d.CollectionNLCG_alphamax_get
    if _newclass:
        alphamax = _swig_property(_sim2d.CollectionNLCG_alphamax_get, _sim2d.CollectionNLCG_alphamax_set)
    __swig_setmethods__["afrac"] = _sim2d.CollectionNLCG_afrac_set
    __swig_getmethods__["afrac"] = _sim2d.CollectionNLCG_afrac_get
    if _newclass:
        afrac = _swig_property(_sim2d.CollectionNLCG_afrac_get, _sim2d.CollectionNLCG_afrac_set)
    __swig_setmethods__["dxmax"] = _sim2d.CollectionNLCG_dxmax_set
    __swig_getmethods__["dxmax"] = _sim2d.CollectionNLCG_dxmax_get
    if _newclass:
        dxmax = _swig_property(_sim2d.CollectionNLCG_dxmax_get, _sim2d.CollectionNLCG_dxmax_set)
    __swig_setmethods__["stepmax"] = _sim2d.CollectionNLCG_stepmax_set
    __swig_getmethods__["stepmax"] = _sim2d.CollectionNLCG_stepmax_get
    if _newclass:
        stepmax = _swig_property(_sim2d.CollectionNLCG_stepmax_get, _sim2d.CollectionNLCG_stepmax_set)
    __swig_setmethods__["kmax"] = _sim2d.CollectionNLCG_kmax_set
    __swig_getmethods__["kmax"] = _sim2d.CollectionNLCG_kmax_get
    if _newclass:
        kmax = _swig_property(_sim2d.CollectionNLCG_kmax_get, _sim2d.CollectionNLCG_kmax_set)
    __swig_setmethods__["P0"] = _sim2d.CollectionNLCG_P0_set
    __swig_getmethods__["P0"] = _sim2d.CollectionNLCG_P0_get
    if _newclass:
        P0 = _swig_property(_sim2d.CollectionNLCG_P0_get, _sim2d.CollectionNLCG_P0_set)
    __swig_setmethods__["Knew"] = _sim2d.CollectionNLCG_Knew_set
    __swig_getmethods__["Knew"] = _sim2d.CollectionNLCG_Knew_get
    if _newclass:
        Knew = _swig_property(_sim2d.CollectionNLCG_Knew_get, _sim2d.CollectionNLCG_Knew_set)
    __swig_setmethods__["k"] = _sim2d.CollectionNLCG_k_set
    __swig_getmethods__["k"] = _sim2d.CollectionNLCG_k_get
    if _newclass:
        k = _swig_property(_sim2d.CollectionNLCG_k_get, _sim2d.CollectionNLCG_k_set)
    __swig_setmethods__["vl"] = _sim2d.CollectionNLCG_vl_set
    __swig_getmethods__["vl"] = _sim2d.CollectionNLCG_vl_get
    if _newclass:
        vl = _swig_property(_sim2d.CollectionNLCG_vl_get, _sim2d.CollectionNLCG_vl_set)
    __swig_setmethods__["fl"] = _sim2d.CollectionNLCG_fl_set
    __swig_getmethods__["fl"] = _sim2d.CollectionNLCG_fl_get
    if _newclass:
        fl = _swig_property(_sim2d.CollectionNLCG_fl_get, _sim2d.CollectionNLCG_fl_set)
    __swig_setmethods__["al"] = _sim2d.CollectionNLCG_al_set
    __swig_getmethods__["al"] = _sim2d.CollectionNLCG_al_get
    if _newclass:
        al = _swig_property(_sim2d.CollectionNLCG_al_get, _sim2d.CollectionNLCG_al_set)
    __swig_setmethods__["alpha"] = _sim2d.CollectionNLCG_alpha_set
    __swig_getmethods__["alpha"] = _sim2d.CollectionNLCG_alpha_get
    if _newclass:
        alpha = _swig_property(_sim2d.CollectionNLCG_alpha_get, _sim2d.CollectionNLCG_alpha_set)
    __swig_setmethods__["beta"] = _sim2d.CollectionNLCG_beta_set
    __swig_getmethods__["beta"] = _sim2d.CollectionNLCG_beta_get
    if _newclass:
        beta = _swig_property(_sim2d.CollectionNLCG_beta_get, _sim2d.CollectionNLCG_beta_set)
    __swig_setmethods__["betaused"] = _sim2d.CollectionNLCG_betaused_set
    __swig_getmethods__["betaused"] = _sim2d.CollectionNLCG_betaused_get
    if _newclass:
        betaused = _swig_property(_sim2d.CollectionNLCG_betaused_get, _sim2d.CollectionNLCG_betaused_set)
    __swig_setmethods__["dxsum"] = _sim2d.CollectionNLCG_dxsum_set
    __swig_getmethods__["dxsum"] = _sim2d.CollectionNLCG_dxsum_get
    if _newclass:
        dxsum = _swig_property(_sim2d.CollectionNLCG_dxsum_get, _sim2d.CollectionNLCG_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim2d.CollectionNLCG_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim2d.CollectionNLCG_alphavmax_get
    if _newclass:
        alphavmax = _swig_property(_sim2d.CollectionNLCG_alphavmax_get, _sim2d.CollectionNLCG_alphavmax_set)
    __swig_setmethods__["maxdV"] = _sim2d.CollectionNLCG_maxdV_set
    __swig_getmethods__["maxdV"] = _sim2d.CollectionNLCG_maxdV_get
    if _newclass:
        maxdV = _swig_property(_sim2d.CollectionNLCG_maxdV_get, _sim2d.CollectionNLCG_maxdV_set)
    __swig_setmethods__["sec"] = _sim2d.CollectionNLCG_sec_set
    __swig_getmethods__["sec"] = _sim2d.CollectionNLCG_sec_get
    if _newclass:
        sec = _swig_property(_sim2d.CollectionNLCG_sec_get, _sim2d.CollectionNLCG_sec_set)

    def stepx(self, dx: 'flt') -> "void":
        """stepx(CollectionNLCG self, flt dx)"""
        return _sim2d.CollectionNLCG_stepx(self, dx)


    def get_length_squared(self) -> "flt":
        """get_length_squared(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_get_length_squared(self)


    def fdota(self) -> "flt":
        """fdota(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_fdota(self)


    def fdotf(self) -> "flt":
        """fdotf(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_fdotf(self)


    def fdotv(self) -> "flt":
        """fdotv(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_fdotv(self)


    def vdotv(self) -> "flt":
        """vdotv(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_vdotv(self)


    def __init__(self, *args):
        """
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0, flt const kmax=1000, uint const secmax=40, flt const seceps=1e-20) -> CollectionNLCG
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0, flt const kmax=1000, uint const secmax=40) -> CollectionNLCG
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0, flt const kmax=1000) -> CollectionNLCG
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0) -> CollectionNLCG
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionNLCG
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers) -> CollectionNLCG
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions) -> CollectionNLCG
        __init__(CollectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0) -> CollectionNLCG
        """
        this = _sim2d.new_CollectionNLCG(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def kinetic_energy(self) -> "flt":
        """kinetic_energy(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_kinetic_energy(self)


    def pressure(self) -> "flt":
        """pressure(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_pressure(self)


    def hamiltonian(self) -> "flt":
        """hamiltonian(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_hamiltonian(self)


    def set_forces(self, *args) -> "void":
        """
        set_forces(CollectionNLCG self, bool constraints_and_a=True)
        set_forces(CollectionNLCG self)
        set_forces(CollectionNLCG self, bool constraints_and_a, bool setV)
        """
        return _sim2d.CollectionNLCG_set_forces(self, *args)


    def timestep(self) -> "void":
        """timestep(CollectionNLCG self)"""
        return _sim2d.CollectionNLCG_timestep(self)


    def descend(self) -> "void":
        """descend(CollectionNLCG self)"""
        return _sim2d.CollectionNLCG_descend(self)


    def reset(self) -> "void":
        """reset(CollectionNLCG self)"""
        return _sim2d.CollectionNLCG_reset(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionNLCG self, flt newdt)"""
        return _sim2d.CollectionNLCG_set_dt(self, newdt)


    def set_pressure_goal(self, P: 'flt') -> "void":
        """set_pressure_goal(CollectionNLCG self, flt P)"""
        return _sim2d.CollectionNLCG_set_pressure_goal(self, P)


    def get_pressure_goal(self) -> "flt":
        """get_pressure_goal(CollectionNLCG self) -> flt"""
        return _sim2d.CollectionNLCG_get_pressure_goal(self)


    def set_kappa(self, k: 'flt') -> "void":
        """set_kappa(CollectionNLCG self, flt k)"""
        return _sim2d.CollectionNLCG_set_kappa(self, k)


    def set_max_alpha(self, a: 'flt') -> "void":
        """set_max_alpha(CollectionNLCG self, flt a)"""
        return _sim2d.CollectionNLCG_set_max_alpha(self, a)


    def set_max_alpha_fraction(self, a: 'flt') -> "void":
        """set_max_alpha_fraction(CollectionNLCG self, flt a)"""
        return _sim2d.CollectionNLCG_set_max_alpha_fraction(self, a)


    def set_max_dx(self, d: 'flt') -> "void":
        """set_max_dx(CollectionNLCG self, flt d)"""
        return _sim2d.CollectionNLCG_set_max_dx(self, d)


    def set_max_step(self, m: 'flt') -> "void":
        """set_max_step(CollectionNLCG self, flt m)"""
        return _sim2d.CollectionNLCG_set_max_step(self, m)

    __swig_destroy__ = _sim2d.delete_CollectionNLCG
    __del__ = lambda self: None
CollectionNLCG_swigregister = _sim2d.CollectionNLCG_swigregister
CollectionNLCG_swigregister(CollectionNLCG)

class CollectionNLCGFixedL(CollectionNLCG):
    """Proxy of C++ CollectionNLCGFixedL class."""

    __swig_setmethods__ = {}
    for _s in [CollectionNLCG]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionNLCGFixedL, name, value)
    __swig_getmethods__ = {}
    for _s in [CollectionNLCG]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionNLCGFixedL, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0, flt const kmax=1000, uint const secmax=40, flt const seceps=1e-20) -> CollectionNLCGFixedL
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0, flt const kmax=1000, uint const secmax=40) -> CollectionNLCGFixedL
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0, flt const kmax=1000) -> CollectionNLCGFixedL
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints, flt const kappa=10.0) -> CollectionNLCGFixedL
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionNLCGFixedL
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions, tvector trackers) -> CollectionNLCGFixedL
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0, ivector interactions) -> CollectionNLCGFixedL
        __init__(CollectionNLCGFixedL self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P0) -> CollectionNLCGFixedL
        """
        this = _sim2d.new_CollectionNLCGFixedL(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def stepx(self, dx: 'flt') -> "void":
        """stepx(CollectionNLCGFixedL self, flt dx)"""
        return _sim2d.CollectionNLCGFixedL_stepx(self, dx)

    __swig_destroy__ = _sim2d.delete_CollectionNLCGFixedL
    __del__ = lambda self: None
CollectionNLCGFixedL_swigregister = _sim2d.CollectionNLCGFixedL_swigregister
CollectionNLCGFixedL_swigregister(CollectionNLCGFixedL)

class CollectionNLCGV(Collection):
    """Proxy of C++ CollectionNLCGV class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionNLCGV, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionNLCGV, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.CollectionNLCGV_dt_set
    __swig_getmethods__["dt"] = _sim2d.CollectionNLCGV_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.CollectionNLCGV_dt_get, _sim2d.CollectionNLCGV_dt_set)
    __swig_setmethods__["seceps"] = _sim2d.CollectionNLCGV_seceps_set
    __swig_getmethods__["seceps"] = _sim2d.CollectionNLCGV_seceps_get
    if _newclass:
        seceps = _swig_property(_sim2d.CollectionNLCGV_seceps_get, _sim2d.CollectionNLCGV_seceps_set)
    __swig_setmethods__["secmax"] = _sim2d.CollectionNLCGV_secmax_set
    __swig_getmethods__["secmax"] = _sim2d.CollectionNLCGV_secmax_get
    if _newclass:
        secmax = _swig_property(_sim2d.CollectionNLCGV_secmax_get, _sim2d.CollectionNLCGV_secmax_set)
    __swig_setmethods__["alphamax"] = _sim2d.CollectionNLCGV_alphamax_set
    __swig_getmethods__["alphamax"] = _sim2d.CollectionNLCGV_alphamax_get
    if _newclass:
        alphamax = _swig_property(_sim2d.CollectionNLCGV_alphamax_get, _sim2d.CollectionNLCGV_alphamax_set)
    __swig_setmethods__["afrac"] = _sim2d.CollectionNLCGV_afrac_set
    __swig_getmethods__["afrac"] = _sim2d.CollectionNLCGV_afrac_get
    if _newclass:
        afrac = _swig_property(_sim2d.CollectionNLCGV_afrac_get, _sim2d.CollectionNLCGV_afrac_set)
    __swig_setmethods__["dxmax"] = _sim2d.CollectionNLCGV_dxmax_set
    __swig_getmethods__["dxmax"] = _sim2d.CollectionNLCGV_dxmax_get
    if _newclass:
        dxmax = _swig_property(_sim2d.CollectionNLCGV_dxmax_get, _sim2d.CollectionNLCGV_dxmax_set)
    __swig_setmethods__["stepmax"] = _sim2d.CollectionNLCGV_stepmax_set
    __swig_getmethods__["stepmax"] = _sim2d.CollectionNLCGV_stepmax_get
    if _newclass:
        stepmax = _swig_property(_sim2d.CollectionNLCGV_stepmax_get, _sim2d.CollectionNLCGV_stepmax_set)
    __swig_setmethods__["kmax"] = _sim2d.CollectionNLCGV_kmax_set
    __swig_getmethods__["kmax"] = _sim2d.CollectionNLCGV_kmax_get
    if _newclass:
        kmax = _swig_property(_sim2d.CollectionNLCGV_kmax_get, _sim2d.CollectionNLCGV_kmax_set)
    __swig_setmethods__["Knew"] = _sim2d.CollectionNLCGV_Knew_set
    __swig_getmethods__["Knew"] = _sim2d.CollectionNLCGV_Knew_get
    if _newclass:
        Knew = _swig_property(_sim2d.CollectionNLCGV_Knew_get, _sim2d.CollectionNLCGV_Knew_set)
    __swig_setmethods__["k"] = _sim2d.CollectionNLCGV_k_set
    __swig_getmethods__["k"] = _sim2d.CollectionNLCGV_k_get
    if _newclass:
        k = _swig_property(_sim2d.CollectionNLCGV_k_get, _sim2d.CollectionNLCGV_k_set)
    __swig_setmethods__["vl"] = _sim2d.CollectionNLCGV_vl_set
    __swig_getmethods__["vl"] = _sim2d.CollectionNLCGV_vl_get
    if _newclass:
        vl = _swig_property(_sim2d.CollectionNLCGV_vl_get, _sim2d.CollectionNLCGV_vl_set)
    __swig_setmethods__["fl"] = _sim2d.CollectionNLCGV_fl_set
    __swig_getmethods__["fl"] = _sim2d.CollectionNLCGV_fl_get
    if _newclass:
        fl = _swig_property(_sim2d.CollectionNLCGV_fl_get, _sim2d.CollectionNLCGV_fl_set)
    __swig_setmethods__["al"] = _sim2d.CollectionNLCGV_al_set
    __swig_getmethods__["al"] = _sim2d.CollectionNLCGV_al_get
    if _newclass:
        al = _swig_property(_sim2d.CollectionNLCGV_al_get, _sim2d.CollectionNLCGV_al_set)
    __swig_setmethods__["alpha"] = _sim2d.CollectionNLCGV_alpha_set
    __swig_getmethods__["alpha"] = _sim2d.CollectionNLCGV_alpha_get
    if _newclass:
        alpha = _swig_property(_sim2d.CollectionNLCGV_alpha_get, _sim2d.CollectionNLCGV_alpha_set)
    __swig_setmethods__["beta"] = _sim2d.CollectionNLCGV_beta_set
    __swig_getmethods__["beta"] = _sim2d.CollectionNLCGV_beta_get
    if _newclass:
        beta = _swig_property(_sim2d.CollectionNLCGV_beta_get, _sim2d.CollectionNLCGV_beta_set)
    __swig_setmethods__["betaused"] = _sim2d.CollectionNLCGV_betaused_set
    __swig_getmethods__["betaused"] = _sim2d.CollectionNLCGV_betaused_get
    if _newclass:
        betaused = _swig_property(_sim2d.CollectionNLCGV_betaused_get, _sim2d.CollectionNLCGV_betaused_set)
    __swig_setmethods__["dxsum"] = _sim2d.CollectionNLCGV_dxsum_set
    __swig_getmethods__["dxsum"] = _sim2d.CollectionNLCGV_dxsum_get
    if _newclass:
        dxsum = _swig_property(_sim2d.CollectionNLCGV_dxsum_get, _sim2d.CollectionNLCGV_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim2d.CollectionNLCGV_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim2d.CollectionNLCGV_alphavmax_get
    if _newclass:
        alphavmax = _swig_property(_sim2d.CollectionNLCGV_alphavmax_get, _sim2d.CollectionNLCGV_alphavmax_set)
    __swig_setmethods__["sec"] = _sim2d.CollectionNLCGV_sec_set
    __swig_getmethods__["sec"] = _sim2d.CollectionNLCGV_sec_get
    if _newclass:
        sec = _swig_property(_sim2d.CollectionNLCGV_sec_get, _sim2d.CollectionNLCGV_sec_set)

    def stepx(self, dx: 'flt') -> "void":
        """stepx(CollectionNLCGV self, flt dx)"""
        return _sim2d.CollectionNLCGV_stepx(self, dx)


    def fdota(self) -> "flt":
        """fdota(CollectionNLCGV self) -> flt"""
        return _sim2d.CollectionNLCGV_fdota(self)


    def fdotf(self) -> "flt":
        """fdotf(CollectionNLCGV self) -> flt"""
        return _sim2d.CollectionNLCGV_fdotf(self)


    def fdotv(self) -> "flt":
        """fdotv(CollectionNLCGV self) -> flt"""
        return _sim2d.CollectionNLCGV_fdotv(self)


    def vdotv(self) -> "flt":
        """vdotv(CollectionNLCGV self) -> flt"""
        return _sim2d.CollectionNLCGV_vdotv(self)


    def __init__(self, *args):
        """
        __init__(CollectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints, flt const kmax=1000, uint const secmax=10, flt const seceps=1e-4) -> CollectionNLCGV
        __init__(CollectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints, flt const kmax=1000, uint const secmax=10) -> CollectionNLCGV
        __init__(CollectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints, flt const kmax=1000) -> CollectionNLCGV
        __init__(CollectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionNLCGV
        __init__(CollectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers) -> CollectionNLCGV
        __init__(CollectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions) -> CollectionNLCGV
        __init__(CollectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionNLCGV
        """
        this = _sim2d.new_CollectionNLCGV(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def pressure(self) -> "flt":
        """pressure(CollectionNLCGV self) -> flt"""
        return _sim2d.CollectionNLCGV_pressure(self)


    def reset(self) -> "void":
        """reset(CollectionNLCGV self)"""
        return _sim2d.CollectionNLCGV_reset(self)


    def descend(self) -> "void":
        """descend(CollectionNLCGV self)"""
        return _sim2d.CollectionNLCGV_descend(self)


    def timestep(self) -> "void":
        """timestep(CollectionNLCGV self)"""
        return _sim2d.CollectionNLCGV_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionNLCGV self, flt newdt)"""
        return _sim2d.CollectionNLCGV_set_dt(self, newdt)


    def set_max_alpha(self, a: 'flt') -> "void":
        """set_max_alpha(CollectionNLCGV self, flt a)"""
        return _sim2d.CollectionNLCGV_set_max_alpha(self, a)


    def set_max_alpha_fraction(self, a: 'flt') -> "void":
        """set_max_alpha_fraction(CollectionNLCGV self, flt a)"""
        return _sim2d.CollectionNLCGV_set_max_alpha_fraction(self, a)


    def set_max_dx(self, d: 'flt') -> "void":
        """set_max_dx(CollectionNLCGV self, flt d)"""
        return _sim2d.CollectionNLCGV_set_max_dx(self, d)


    def set_max_step(self, m: 'flt') -> "void":
        """set_max_step(CollectionNLCGV self, flt m)"""
        return _sim2d.CollectionNLCGV_set_max_step(self, m)

    __swig_destroy__ = _sim2d.delete_CollectionNLCGV
    __del__ = lambda self: None
CollectionNLCGV_swigregister = _sim2d.CollectionNLCGV_swigregister
CollectionNLCGV_swigregister(CollectionNLCGV)


def solve_cubic_fast(b: 'flt', c: 'flt', d: 'flt') -> "flt":
    """solve_cubic_fast(flt b, flt c, flt d) -> flt"""
    return _sim2d.solve_cubic_fast(b, c, d)

def solve_cubic(a1: 'flt', a2: 'flt', a3: 'flt', closeto: 'flt'=0) -> "flt":
    """
    solve_cubic(flt a1, flt a2, flt a3, flt closeto=0) -> flt
    solve_cubic(flt a1, flt a2, flt a3) -> flt
    """
    return _sim2d.solve_cubic(a1, a2, a3, closeto)
class CollectionNoseHoover(Collection):
    """Proxy of C++ CollectionNoseHoover class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionNoseHoover, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionNoseHoover, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const Q, flt const T, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionNoseHoover
        __init__(CollectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const Q, flt const T, ivector interactions, tvector trackers) -> CollectionNoseHoover
        __init__(CollectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const Q, flt const T, ivector interactions) -> CollectionNoseHoover
        __init__(CollectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const Q, flt const T) -> CollectionNoseHoover
        """
        this = _sim2d.new_CollectionNoseHoover(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionNoseHoover self, flt newdt)"""
        return _sim2d.CollectionNoseHoover_set_dt(self, newdt)


    def set_Q(self, newQ: 'flt') -> "void":
        """set_Q(CollectionNoseHoover self, flt newQ)"""
        return _sim2d.CollectionNoseHoover_set_Q(self, newQ)


    def reset_bath(self) -> "void":
        """reset_bath(CollectionNoseHoover self)"""
        return _sim2d.CollectionNoseHoover_reset_bath(self)


    def timestep(self) -> "void":
        """timestep(CollectionNoseHoover self)"""
        return _sim2d.CollectionNoseHoover_timestep(self)


    def hamiltonian(self) -> "flt":
        """hamiltonian(CollectionNoseHoover self) -> flt"""
        return _sim2d.CollectionNoseHoover_hamiltonian(self)


    def get_xi(self) -> "flt":
        """get_xi(CollectionNoseHoover self) -> flt"""
        return _sim2d.CollectionNoseHoover_get_xi(self)


    def get_lns(self) -> "flt":
        """get_lns(CollectionNoseHoover self) -> flt"""
        return _sim2d.CollectionNoseHoover_get_lns(self)

    __swig_destroy__ = _sim2d.delete_CollectionNoseHoover
    __del__ = lambda self: None
CollectionNoseHoover_swigregister = _sim2d.CollectionNoseHoover_swigregister
CollectionNoseHoover_swigregister(CollectionNoseHoover)

class CollectionGaussianT(Collection):
    """Proxy of C++ CollectionGaussianT class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionGaussianT, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionGaussianT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGaussianT
        __init__(CollectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers) -> CollectionGaussianT
        __init__(CollectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions) -> CollectionGaussianT
        __init__(CollectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionGaussianT
        """
        this = _sim2d.new_CollectionGaussianT(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionGaussianT self, flt newdt)"""
        return _sim2d.CollectionGaussianT_set_dt(self, newdt)


    def set_forces(self, *args) -> "void":
        """
        set_forces(CollectionGaussianT self, bool constraints_and_a=True)
        set_forces(CollectionGaussianT self)
        set_forces(CollectionGaussianT self, bool constraints_and_a, bool set_xi)
        """
        return _sim2d.CollectionGaussianT_set_forces(self, *args)


    def timestep(self) -> "void":
        """timestep(CollectionGaussianT self)"""
        return _sim2d.CollectionGaussianT_timestep(self)

    __swig_destroy__ = _sim2d.delete_CollectionGaussianT
    __del__ = lambda self: None
CollectionGaussianT_swigregister = _sim2d.CollectionGaussianT_swigregister
CollectionGaussianT_swigregister(CollectionGaussianT)

class CollectionGear3A(Collection):
    """Proxy of C++ CollectionGear3A class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionGear3A, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionGear3A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear3A
        __init__(CollectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers) -> CollectionGear3A
        __init__(CollectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions) -> CollectionGear3A
        __init__(CollectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionGear3A
        """
        this = _sim2d.new_CollectionGear3A(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionGear3A self)"""
        return _sim2d.CollectionGear3A_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionGear3A self, flt newdt)"""
        return _sim2d.CollectionGear3A_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionGear3A
    __del__ = lambda self: None
CollectionGear3A_swigregister = _sim2d.CollectionGear3A_swigregister
CollectionGear3A_swigregister(CollectionGear3A)

class CollectionGear4A(Collection):
    """Proxy of C++ CollectionGear4A class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionGear4A, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionGear4A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear4A
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions, tvector trackers) -> CollectionGear4A
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions) -> CollectionGear4A
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps) -> CollectionGear4A
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear4A
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers) -> CollectionGear4A
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions) -> CollectionGear4A
        __init__(CollectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionGear4A
        """
        this = _sim2d.new_CollectionGear4A(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionGear4A self)"""
        return _sim2d.CollectionGear4A_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionGear4A self, flt newdt)"""
        return _sim2d.CollectionGear4A_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionGear4A
    __del__ = lambda self: None
CollectionGear4A_swigregister = _sim2d.CollectionGear4A_swigregister
CollectionGear4A_swigregister(CollectionGear4A)

class CollectionGear5A(Collection):
    """Proxy of C++ CollectionGear5A class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionGear5A, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionGear5A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear5A
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions, tvector trackers) -> CollectionGear5A
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions) -> CollectionGear5A
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps) -> CollectionGear5A
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< AtomGroup > atoms, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear5A
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< AtomGroup > atoms, ivector interactions, tvector trackers) -> CollectionGear5A
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< AtomGroup > atoms, ivector interactions) -> CollectionGear5A
        __init__(CollectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< AtomGroup > atoms) -> CollectionGear5A
        """
        this = _sim2d.new_CollectionGear5A(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionGear5A self)"""
        return _sim2d.CollectionGear5A_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionGear5A self, flt newdt)"""
        return _sim2d.CollectionGear5A_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionGear5A
    __del__ = lambda self: None
CollectionGear5A_swigregister = _sim2d.CollectionGear5A_swigregister
CollectionGear5A_swigregister(CollectionGear5A)

class CollectionGear6A(Collection):
    """Proxy of C++ CollectionGear6A class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionGear6A, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionGear6A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear6A
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions, tvector trackers) -> CollectionGear6A
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ivector interactions) -> CollectionGear6A
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps) -> CollectionGear6A
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear6A
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions, tvector trackers) -> CollectionGear6A
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, ivector interactions) -> CollectionGear6A
        __init__(CollectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionGear6A
        """
        this = _sim2d.new_CollectionGear6A(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionGear6A self)"""
        return _sim2d.CollectionGear6A_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionGear6A self, flt newdt)"""
        return _sim2d.CollectionGear6A_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionGear6A
    __del__ = lambda self: None
CollectionGear6A_swigregister = _sim2d.CollectionGear6A_swigregister
CollectionGear6A_swigregister(CollectionGear6A)

class RK4data(_object):
    """Proxy of C++ RK4data class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RK4data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RK4data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Kxa"] = _sim2d.RK4data_Kxa_set
    __swig_getmethods__["Kxa"] = _sim2d.RK4data_Kxa_get
    if _newclass:
        Kxa = _swig_property(_sim2d.RK4data_Kxa_get, _sim2d.RK4data_Kxa_set)
    __swig_setmethods__["Kxb"] = _sim2d.RK4data_Kxb_set
    __swig_getmethods__["Kxb"] = _sim2d.RK4data_Kxb_get
    if _newclass:
        Kxb = _swig_property(_sim2d.RK4data_Kxb_get, _sim2d.RK4data_Kxb_set)
    __swig_setmethods__["Kxc"] = _sim2d.RK4data_Kxc_set
    __swig_getmethods__["Kxc"] = _sim2d.RK4data_Kxc_get
    if _newclass:
        Kxc = _swig_property(_sim2d.RK4data_Kxc_get, _sim2d.RK4data_Kxc_set)
    __swig_setmethods__["Kxd"] = _sim2d.RK4data_Kxd_set
    __swig_getmethods__["Kxd"] = _sim2d.RK4data_Kxd_get
    if _newclass:
        Kxd = _swig_property(_sim2d.RK4data_Kxd_get, _sim2d.RK4data_Kxd_set)
    __swig_setmethods__["Kva"] = _sim2d.RK4data_Kva_set
    __swig_getmethods__["Kva"] = _sim2d.RK4data_Kva_get
    if _newclass:
        Kva = _swig_property(_sim2d.RK4data_Kva_get, _sim2d.RK4data_Kva_set)
    __swig_setmethods__["Kvb"] = _sim2d.RK4data_Kvb_set
    __swig_getmethods__["Kvb"] = _sim2d.RK4data_Kvb_get
    if _newclass:
        Kvb = _swig_property(_sim2d.RK4data_Kvb_get, _sim2d.RK4data_Kvb_set)
    __swig_setmethods__["Kvc"] = _sim2d.RK4data_Kvc_set
    __swig_getmethods__["Kvc"] = _sim2d.RK4data_Kvc_get
    if _newclass:
        Kvc = _swig_property(_sim2d.RK4data_Kvc_get, _sim2d.RK4data_Kvc_set)
    __swig_setmethods__["Kvd"] = _sim2d.RK4data_Kvd_set
    __swig_getmethods__["Kvd"] = _sim2d.RK4data_Kvd_get
    if _newclass:
        Kvd = _swig_property(_sim2d.RK4data_Kvd_get, _sim2d.RK4data_Kvd_set)

    def __init__(self):
        """__init__(RK4data self) -> RK4data"""
        this = _sim2d.new_RK4data()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_RK4data
    __del__ = lambda self: None
RK4data_swigregister = _sim2d.RK4data_swigregister
RK4data_swigregister(RK4data)

class CollectionRK4(Collection):
    """Proxy of C++ CollectionRK4 class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionRK4, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > ratoms, flt const dt, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionRK4
        __init__(CollectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > ratoms, flt const dt, ivector interactions, tvector trackers) -> CollectionRK4
        __init__(CollectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > ratoms, flt const dt, ivector interactions) -> CollectionRK4
        __init__(CollectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< AtomGroup > ratoms, flt const dt) -> CollectionRK4
        """
        this = _sim2d.new_CollectionRK4(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionRK4 self)"""
        return _sim2d.CollectionRK4_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionRK4 self, flt newdt)"""
        return _sim2d.CollectionRK4_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionRK4
    __del__ = lambda self: None
CollectionRK4_swigregister = _sim2d.CollectionRK4_swigregister
CollectionRK4_swigregister(CollectionRK4)

class CollectionGear4NPH(Collection):
    """Proxy of C++ CollectionGear4NPH class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionGear4NPH, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionGear4NPH, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear4NPH
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, ivector interactions, tvector trackers) -> CollectionGear4NPH
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, ivector interactions) -> CollectionGear4NPH
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps) -> CollectionGear4NPH
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionGear4NPH
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q, ivector interactions, tvector trackers) -> CollectionGear4NPH
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q, ivector interactions) -> CollectionGear4NPH
        __init__(CollectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const Q) -> CollectionGear4NPH
        """
        this = _sim2d.new_CollectionGear4NPH(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionGear4NPH self)"""
        return _sim2d.CollectionGear4NPH_timestep(self)


    def kinetic_energy(self) -> "flt":
        """kinetic_energy(CollectionGear4NPH self) -> flt"""
        return _sim2d.CollectionGear4NPH_kinetic_energy(self)


    def temp(self, minuscomv: 'bool'=True) -> "flt":
        """
        temp(CollectionGear4NPH self, bool minuscomv=True) -> flt
        temp(CollectionGear4NPH self) -> flt
        """
        return _sim2d.CollectionGear4NPH_temp(self, minuscomv)


    def hamiltonian(self) -> "flt":
        """hamiltonian(CollectionGear4NPH self) -> flt"""
        return _sim2d.CollectionGear4NPH_hamiltonian(self)


    def get_dV(self) -> "flt":
        """get_dV(CollectionGear4NPH self) -> flt"""
        return _sim2d.CollectionGear4NPH_get_dV(self)


    def getddV(self) -> "flt":
        """getddV(CollectionGear4NPH self) -> flt"""
        return _sim2d.CollectionGear4NPH_getddV(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionGear4NPH self, flt newdt)"""
        return _sim2d.CollectionGear4NPH_set_dt(self, newdt)

    __swig_destroy__ = _sim2d.delete_CollectionGear4NPH
    __del__ = lambda self: None
CollectionGear4NPH_swigregister = _sim2d.CollectionGear4NPH_swigregister
CollectionGear4NPH_swigregister(CollectionGear4NPH)

class XRPSummer(FPairXFunct):
    """Proxy of C++ XRPSummer class."""

    __swig_setmethods__ = {}
    for _s in [FPairXFunct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XRPSummer, name, value)
    __swig_getmethods__ = {}
    for _s in [FPairXFunct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, XRPSummer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["xsum"] = _sim2d.XRPSummer_xsum_set
    __swig_getmethods__["xsum"] = _sim2d.XRPSummer_xsum_get
    if _newclass:
        xsum = _swig_property(_sim2d.XRPSummer_xsum_get, _sim2d.XRPSummer_xsum_set)
    __swig_setmethods__["rpxsum"] = _sim2d.XRPSummer_rpxsum_set
    __swig_getmethods__["rpxsum"] = _sim2d.XRPSummer_rpxsum_get
    if _newclass:
        rpxsum = _swig_property(_sim2d.XRPSummer_rpxsum_get, _sim2d.XRPSummer_rpxsum_set)
    __swig_setmethods__["vfsum"] = _sim2d.XRPSummer_vfsum_set
    __swig_getmethods__["vfsum"] = _sim2d.XRPSummer_vfsum_get
    if _newclass:
        vfsum = _swig_property(_sim2d.XRPSummer_vfsum_get, _sim2d.XRPSummer_vfsum_set)
    __swig_setmethods__["rfsum"] = _sim2d.XRPSummer_rfsum_set
    __swig_getmethods__["rfsum"] = _sim2d.XRPSummer_rfsum_get
    if _newclass:
        rfsum = _swig_property(_sim2d.XRPSummer_rfsum_get, _sim2d.XRPSummer_rfsum_set)

    def __init__(self, box: 'boost::shared_ptr< Box >'):
        """__init__(XRPSummer self, boost::shared_ptr< Box > box) -> XRPSummer"""
        this = _sim2d.new_XRPSummer(box)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def run(self, arg2: 'ForcePairX') -> "void":
        """run(XRPSummer self, ForcePairX arg2)"""
        return _sim2d.XRPSummer_run(self, arg2)


    def reset(self) -> "void":
        """reset(XRPSummer self)"""
        return _sim2d.XRPSummer_reset(self)

    __swig_destroy__ = _sim2d.delete_XRPSummer
    __del__ = lambda self: None
XRPSummer_swigregister = _sim2d.XRPSummer_swigregister
XRPSummer_swigregister(XRPSummer)

class CollectionGear4NPT(Collection):
    """Proxy of C++ CollectionGear4NPT class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionGear4NPT, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionGear4NPT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.CollectionGear4NPT_dt_set
    __swig_getmethods__["dt"] = _sim2d.CollectionGear4NPT_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.CollectionGear4NPT_dt_get, _sim2d.CollectionGear4NPT_dt_set)
    __swig_setmethods__["xrpsums"] = _sim2d.CollectionGear4NPT_xrpsums_set
    __swig_getmethods__["xrpsums"] = _sim2d.CollectionGear4NPT_xrpsums_get
    if _newclass:
        xrpsums = _swig_property(_sim2d.CollectionGear4NPT_xrpsums_get, _sim2d.CollectionGear4NPT_xrpsums_set)
    __swig_setmethods__["ncorrec"] = _sim2d.CollectionGear4NPT_ncorrec_set
    __swig_getmethods__["ncorrec"] = _sim2d.CollectionGear4NPT_ncorrec_get
    if _newclass:
        ncorrec = _swig_property(_sim2d.CollectionGear4NPT_ncorrec_get, _sim2d.CollectionGear4NPT_ncorrec_set)
    __swig_setmethods__["V1"] = _sim2d.CollectionGear4NPT_V1_set
    __swig_getmethods__["V1"] = _sim2d.CollectionGear4NPT_V1_get
    if _newclass:
        V1 = _swig_property(_sim2d.CollectionGear4NPT_V1_get, _sim2d.CollectionGear4NPT_V1_set)
    __swig_setmethods__["V2"] = _sim2d.CollectionGear4NPT_V2_set
    __swig_getmethods__["V2"] = _sim2d.CollectionGear4NPT_V2_get
    if _newclass:
        V2 = _swig_property(_sim2d.CollectionGear4NPT_V2_get, _sim2d.CollectionGear4NPT_V2_set)
    __swig_setmethods__["V3"] = _sim2d.CollectionGear4NPT_V3_set
    __swig_getmethods__["V3"] = _sim2d.CollectionGear4NPT_V3_get
    if _newclass:
        V3 = _swig_property(_sim2d.CollectionGear4NPT_V3_get, _sim2d.CollectionGear4NPT_V3_set)
    __swig_setmethods__["chi"] = _sim2d.CollectionGear4NPT_chi_set
    __swig_getmethods__["chi"] = _sim2d.CollectionGear4NPT_chi_get
    if _newclass:
        chi = _swig_property(_sim2d.CollectionGear4NPT_chi_get, _sim2d.CollectionGear4NPT_chi_set)
    __swig_setmethods__["chixi"] = _sim2d.CollectionGear4NPT_chixi_set
    __swig_getmethods__["chixi"] = _sim2d.CollectionGear4NPT_chixi_get
    if _newclass:
        chixi = _swig_property(_sim2d.CollectionGear4NPT_chixi_get, _sim2d.CollectionGear4NPT_chixi_set)
    __swig_setmethods__["xs1"] = _sim2d.CollectionGear4NPT_xs1_set
    __swig_getmethods__["xs1"] = _sim2d.CollectionGear4NPT_xs1_get
    if _newclass:
        xs1 = _swig_property(_sim2d.CollectionGear4NPT_xs1_get, _sim2d.CollectionGear4NPT_xs1_set)
    __swig_setmethods__["xs2"] = _sim2d.CollectionGear4NPT_xs2_set
    __swig_getmethods__["xs2"] = _sim2d.CollectionGear4NPT_xs2_get
    if _newclass:
        xs2 = _swig_property(_sim2d.CollectionGear4NPT_xs2_get, _sim2d.CollectionGear4NPT_xs2_set)
    __swig_setmethods__["xs3"] = _sim2d.CollectionGear4NPT_xs3_set
    __swig_getmethods__["xs3"] = _sim2d.CollectionGear4NPT_xs3_get
    if _newclass:
        xs3 = _swig_property(_sim2d.CollectionGear4NPT_xs3_get, _sim2d.CollectionGear4NPT_xs3_set)
    __swig_setmethods__["vs2"] = _sim2d.CollectionGear4NPT_vs2_set
    __swig_getmethods__["vs2"] = _sim2d.CollectionGear4NPT_vs2_get
    if _newclass:
        vs2 = _swig_property(_sim2d.CollectionGear4NPT_vs2_get, _sim2d.CollectionGear4NPT_vs2_set)
    __swig_setmethods__["vs3"] = _sim2d.CollectionGear4NPT_vs3_set
    __swig_getmethods__["vs3"] = _sim2d.CollectionGear4NPT_vs3_get
    if _newclass:
        vs3 = _swig_property(_sim2d.CollectionGear4NPT_vs3_get, _sim2d.CollectionGear4NPT_vs3_set)

    def resetbs(self) -> "void":
        """resetbs(CollectionGear4NPT self)"""
        return _sim2d.CollectionGear4NPT_resetbs(self)


    def tointerpair(arg1: 'ifxvector') -> "std::vector< boost::shared_ptr< Interaction > >":
        """tointerpair(ifxvector arg1) -> ivector"""
        return _sim2d.CollectionGear4NPT_tointerpair(arg1)

    if _newclass:
        tointerpair = staticmethod(tointerpair)
    __swig_getmethods__["tointerpair"] = lambda x: tointerpair

    def __init__(self, *args):
        """
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ifxvector interactions, tvector trackers, constraintvector constraints) -> CollectionGear4NPT
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ifxvector interactions, tvector trackers) -> CollectionGear4NPT
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps, ifxvector interactions) -> CollectionGear4NPT
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, uint ncorrectionsteps) -> CollectionGear4NPT
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< AtomGroup > atoms, ifxvector interactions, tvector trackers, constraintvector constraints) -> CollectionGear4NPT
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< AtomGroup > atoms, ifxvector interactions, tvector trackers) -> CollectionGear4NPT
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< AtomGroup > atoms, ifxvector interactions) -> CollectionGear4NPT
        __init__(CollectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< AtomGroup > atoms) -> CollectionGear4NPT
        """
        this = _sim2d.new_CollectionGear4NPT(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_forces(self, constraints_and_a: 'bool'=True) -> "void":
        """
        set_forces(CollectionGear4NPT self, bool constraints_and_a=True)
        set_forces(CollectionGear4NPT self)
        """
        return _sim2d.CollectionGear4NPT_set_forces(self, constraints_and_a)


    def timestep(self) -> "void":
        """timestep(CollectionGear4NPT self)"""
        return _sim2d.CollectionGear4NPT_timestep(self)

    __swig_destroy__ = _sim2d.delete_CollectionGear4NPT
    __del__ = lambda self: None
CollectionGear4NPT_swigregister = _sim2d.CollectionGear4NPT_swigregister
CollectionGear4NPT_swigregister(CollectionGear4NPT)

def CollectionGear4NPT_tointerpair(arg2: 'ifxvector') -> "std::vector< boost::shared_ptr< Interaction > >":
    """CollectionGear4NPT_tointerpair(ifxvector arg2) -> ivector"""
    return _sim2d.CollectionGear4NPT_tointerpair(arg2)

class CollectionVerletNPT(Collection):
    """Proxy of C++ CollectionVerletNPT class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionVerletNPT, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionVerletNPT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.CollectionVerletNPT_dt_set
    __swig_getmethods__["dt"] = _sim2d.CollectionVerletNPT_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.CollectionVerletNPT_dt_get, _sim2d.CollectionVerletNPT_dt_set)
    __swig_setmethods__["eta"] = _sim2d.CollectionVerletNPT_eta_set
    __swig_getmethods__["eta"] = _sim2d.CollectionVerletNPT_eta_get
    if _newclass:
        eta = _swig_property(_sim2d.CollectionVerletNPT_eta_get, _sim2d.CollectionVerletNPT_eta_set)
    __swig_setmethods__["xidot"] = _sim2d.CollectionVerletNPT_xidot_set
    __swig_getmethods__["xidot"] = _sim2d.CollectionVerletNPT_xidot_get
    if _newclass:
        xidot = _swig_property(_sim2d.CollectionVerletNPT_xidot_get, _sim2d.CollectionVerletNPT_xidot_set)
    __swig_setmethods__["lastxidot"] = _sim2d.CollectionVerletNPT_lastxidot_set
    __swig_getmethods__["lastxidot"] = _sim2d.CollectionVerletNPT_lastxidot_get
    if _newclass:
        lastxidot = _swig_property(_sim2d.CollectionVerletNPT_lastxidot_get, _sim2d.CollectionVerletNPT_lastxidot_set)
    __swig_setmethods__["lastV"] = _sim2d.CollectionVerletNPT_lastV_set
    __swig_getmethods__["lastV"] = _sim2d.CollectionVerletNPT_lastV_get
    if _newclass:
        lastV = _swig_property(_sim2d.CollectionVerletNPT_lastV_get, _sim2d.CollectionVerletNPT_lastV_set)
    __swig_setmethods__["etasum"] = _sim2d.CollectionVerletNPT_etasum_set
    __swig_getmethods__["etasum"] = _sim2d.CollectionVerletNPT_etasum_get
    if _newclass:
        etasum = _swig_property(_sim2d.CollectionVerletNPT_etasum_get, _sim2d.CollectionVerletNPT_etasum_set)
    __swig_setmethods__["vhalf"] = _sim2d.CollectionVerletNPT_vhalf_set
    __swig_getmethods__["vhalf"] = _sim2d.CollectionVerletNPT_vhalf_get
    if _newclass:
        vhalf = _swig_property(_sim2d.CollectionVerletNPT_vhalf_get, _sim2d.CollectionVerletNPT_vhalf_set)
    __swig_setmethods__["P"] = _sim2d.CollectionVerletNPT_P_set
    __swig_getmethods__["P"] = _sim2d.CollectionVerletNPT_P_get
    if _newclass:
        P = _swig_property(_sim2d.CollectionVerletNPT_P_get, _sim2d.CollectionVerletNPT_P_set)
    __swig_setmethods__["QP"] = _sim2d.CollectionVerletNPT_QP_set
    __swig_getmethods__["QP"] = _sim2d.CollectionVerletNPT_QP_get
    if _newclass:
        QP = _swig_property(_sim2d.CollectionVerletNPT_QP_get, _sim2d.CollectionVerletNPT_QP_set)
    __swig_setmethods__["T"] = _sim2d.CollectionVerletNPT_T_set
    __swig_getmethods__["T"] = _sim2d.CollectionVerletNPT_T_get
    if _newclass:
        T = _swig_property(_sim2d.CollectionVerletNPT_T_get, _sim2d.CollectionVerletNPT_T_set)
    __swig_setmethods__["QT"] = _sim2d.CollectionVerletNPT_QT_set
    __swig_getmethods__["QT"] = _sim2d.CollectionVerletNPT_QT_get
    if _newclass:
        QT = _swig_property(_sim2d.CollectionVerletNPT_QT_get, _sim2d.CollectionVerletNPT_QT_set)
    __swig_setmethods__["curP"] = _sim2d.CollectionVerletNPT_curP_set
    __swig_getmethods__["curP"] = _sim2d.CollectionVerletNPT_curP_get
    if _newclass:
        curP = _swig_property(_sim2d.CollectionVerletNPT_curP_get, _sim2d.CollectionVerletNPT_curP_set)

    def resetvhalf(self) -> "void":
        """resetvhalf(CollectionVerletNPT self)"""
        return _sim2d.CollectionVerletNPT_resetvhalf(self)


    def __init__(self, *args):
        """
        __init__(CollectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionVerletNPT
        __init__(CollectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT, ivector interactions, tvector trackers) -> CollectionVerletNPT
        __init__(CollectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT, ivector interactions) -> CollectionVerletNPT
        __init__(CollectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT) -> CollectionVerletNPT
        """
        this = _sim2d.new_CollectionVerletNPT(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionVerletNPT self)"""
        return _sim2d.CollectionVerletNPT_timestep(self)


    def set_dt(self, newdt: 'flt') -> "void":
        """set_dt(CollectionVerletNPT self, flt newdt)"""
        return _sim2d.CollectionVerletNPT_set_dt(self, newdt)


    def reset_com_velocity(self) -> "void":
        """reset_com_velocity(CollectionVerletNPT self)"""
        return _sim2d.CollectionVerletNPT_reset_com_velocity(self)


    def reset_L(self) -> "void":
        """reset_L(CollectionVerletNPT self)"""
        return _sim2d.CollectionVerletNPT_reset_L(self)


    def scale_velocities(self, scaleby: 'flt') -> "void":
        """scale_velocities(CollectionVerletNPT self, flt scaleby)"""
        return _sim2d.CollectionVerletNPT_scale_velocities(self, scaleby)


    def scale_velocities_to_temp(self, T: 'flt') -> "void":
        """scale_velocities_to_temp(CollectionVerletNPT self, flt T)"""
        return _sim2d.CollectionVerletNPT_scale_velocities_to_temp(self, T)


    def scale_velocities_to_energy(self, E: 'flt') -> "void":
        """scale_velocities_to_energy(CollectionVerletNPT self, flt E)"""
        return _sim2d.CollectionVerletNPT_scale_velocities_to_energy(self, E)


    def get_eta(self) -> "flt":
        """get_eta(CollectionVerletNPT self) -> flt"""
        return _sim2d.CollectionVerletNPT_get_eta(self)


    def det_xi_dot(self) -> "flt":
        """det_xi_dot(CollectionVerletNPT self) -> flt"""
        return _sim2d.CollectionVerletNPT_det_xi_dot(self)


    def get_pressure(self) -> "flt":
        """get_pressure(CollectionVerletNPT self) -> flt"""
        return _sim2d.CollectionVerletNPT_get_pressure(self)


    def get_vhalf(self, n: 'uint') -> "Vec":
        """get_vhalf(CollectionVerletNPT self, uint n) -> Vec"""
        return _sim2d.CollectionVerletNPT_get_vhalf(self, n)


    def hamiltonian(self) -> "flt":
        """hamiltonian(CollectionVerletNPT self) -> flt"""
        return _sim2d.CollectionVerletNPT_hamiltonian(self)

    __swig_destroy__ = _sim2d.delete_CollectionVerletNPT
    __del__ = lambda self: None
CollectionVerletNPT_swigregister = _sim2d.CollectionVerletNPT_swigregister
CollectionVerletNPT_swigregister(CollectionVerletNPT)

class Event(_object):
    """Proxy of C++ Event class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Event, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Event, name)
    __repr__ = _swig_repr
    __swig_setmethods__["t"] = _sim2d.Event_t_set
    __swig_getmethods__["t"] = _sim2d.Event_t_get
    if _newclass:
        t = _swig_property(_sim2d.Event_t_get, _sim2d.Event_t_set)
    __swig_setmethods__["a"] = _sim2d.Event_a_set
    __swig_getmethods__["a"] = _sim2d.Event_a_get
    if _newclass:
        a = _swig_property(_sim2d.Event_a_get, _sim2d.Event_a_set)
    __swig_setmethods__["b"] = _sim2d.Event_b_set
    __swig_getmethods__["b"] = _sim2d.Event_b_get
    if _newclass:
        b = _swig_property(_sim2d.Event_b_get, _sim2d.Event_b_set)

    def __lt__(self, other: 'Event') -> "bool":
        """__lt__(Event self, Event other) -> bool"""
        return _sim2d.Event___lt__(self, other)


    def __init__(self):
        """__init__(Event self) -> Event"""
        this = _sim2d.new_Event()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _sim2d.delete_Event
    __del__ = lambda self: None
Event_swigregister = _sim2d.Event_swigregister
Event_swigregister(Event)


def get_max(v: 'dvector') -> "flt":
    """get_max(dvector v) -> flt"""
    return _sim2d.get_max(v)
class CollectionCD(Collection):
    """Proxy of C++ CollectionCD class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionCD, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionCD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionCD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionCD
        __init__(CollectionCD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes, ivector interactions, tvector trackers) -> CollectionCD
        __init__(CollectionCD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes, ivector interactions) -> CollectionCD
        __init__(CollectionCD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes) -> CollectionCD
        __init__(CollectionCD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionCD
        """
        this = _sim2d.new_CollectionCD(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def reset_velocities(self, T: 'flt') -> "void":
        """reset_velocities(CollectionCD self, flt T)"""
        return _sim2d.CollectionCD_reset_velocities(self, T)


    def take_step(self, tlim: 'flt'=-1) -> "bool":
        """
        take_step(CollectionCD self, flt tlim=-1) -> bool
        take_step(CollectionCD self) -> bool
        """
        return _sim2d.CollectionCD_take_step(self, tlim)


    def timestep(self) -> "void":
        """timestep(CollectionCD self)"""
        return _sim2d.CollectionCD_timestep(self)


    def events_processed(self) -> "long long":
        """events_processed(CollectionCD self) -> long long"""
        return _sim2d.CollectionCD_events_processed(self)

    __swig_destroy__ = _sim2d.delete_CollectionCD
    __del__ = lambda self: None
CollectionCD_swigregister = _sim2d.CollectionCD_swigregister
CollectionCD_swigregister(CollectionCD)

class CollectionCDgrid(Collection):
    """Proxy of C++ CollectionCDgrid class."""

    __swig_setmethods__ = {}
    for _s in [Collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionCDgrid, name, value)
    __swig_getmethods__ = {}
    for _s in [Collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionCDgrid, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.CollectionCDgrid_dt_set
    __swig_getmethods__["dt"] = _sim2d.CollectionCDgrid_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.CollectionCDgrid_dt_get, _sim2d.CollectionCDgrid_dt_set)
    __swig_setmethods__["curt"] = _sim2d.CollectionCDgrid_curt_set
    __swig_getmethods__["curt"] = _sim2d.CollectionCDgrid_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.CollectionCDgrid_curt_get, _sim2d.CollectionCDgrid_curt_set)
    __swig_setmethods__["numevents"] = _sim2d.CollectionCDgrid_numevents_set
    __swig_getmethods__["numevents"] = _sim2d.CollectionCDgrid_numevents_get
    if _newclass:
        numevents = _swig_property(_sim2d.CollectionCDgrid_numevents_get, _sim2d.CollectionCDgrid_numevents_set)
    __swig_setmethods__["events"] = _sim2d.CollectionCDgrid_events_set
    __swig_getmethods__["events"] = _sim2d.CollectionCDgrid_events_get
    if _newclass:
        events = _swig_property(_sim2d.CollectionCDgrid_events_get, _sim2d.CollectionCDgrid_events_set)
    __swig_setmethods__["atomsizes"] = _sim2d.CollectionCDgrid_atomsizes_set
    __swig_getmethods__["atomsizes"] = _sim2d.CollectionCDgrid_atomsizes_get
    if _newclass:
        atomsizes = _swig_property(_sim2d.CollectionCDgrid_atomsizes_get, _sim2d.CollectionCDgrid_atomsizes_set)
    __swig_setmethods__["edge_epsilon"] = _sim2d.CollectionCDgrid_edge_epsilon_set
    __swig_getmethods__["edge_epsilon"] = _sim2d.CollectionCDgrid_edge_epsilon_get
    if _newclass:
        edge_epsilon = _swig_property(_sim2d.CollectionCDgrid_edge_epsilon_get, _sim2d.CollectionCDgrid_edge_epsilon_set)

    def reset_events(self, force: 'bool'=True) -> "void":
        """
        reset_events(CollectionCDgrid self, bool force=True)
        reset_events(CollectionCDgrid self)
        """
        return _sim2d.CollectionCDgrid_reset_events(self, force)


    def line_advance(self, deltat: 'flt') -> "void":
        """line_advance(CollectionCDgrid self, flt deltat)"""
        return _sim2d.CollectionCDgrid_line_advance(self, deltat)

    __swig_setmethods__["grid"] = _sim2d.CollectionCDgrid_grid_set
    __swig_getmethods__["grid"] = _sim2d.CollectionCDgrid_grid_get
    if _newclass:
        grid = _swig_property(_sim2d.CollectionCDgrid_grid_get, _sim2d.CollectionCDgrid_grid_set)
    __swig_setmethods__["gridt"] = _sim2d.CollectionCDgrid_gridt_set
    __swig_getmethods__["gridt"] = _sim2d.CollectionCDgrid_gridt_get
    if _newclass:
        gridt = _swig_property(_sim2d.CollectionCDgrid_gridt_get, _sim2d.CollectionCDgrid_gridt_set)

    def next_event(self, a: 'AtomID') -> "Event":
        """next_event(CollectionCDgrid self, AtomID a) -> Event"""
        return _sim2d.CollectionCDgrid_next_event(self, a)


    def __init__(self, *args):
        """
        __init__(CollectionCDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionCDgrid
        __init__(CollectionCDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes, ivector interactions, tvector trackers) -> CollectionCDgrid
        __init__(CollectionCDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes, ivector interactions) -> CollectionCDgrid
        __init__(CollectionCDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, dvector sizes) -> CollectionCDgrid
        __init__(CollectionCDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt) -> CollectionCDgrid
        """
        this = _sim2d.new_CollectionCDgrid(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def update_grid(self, force: 'bool'=True) -> "void":
        """
        update_grid(CollectionCDgrid self, bool force=True)
        update_grid(CollectionCDgrid self)
        """
        return _sim2d.CollectionCDgrid_update_grid(self, force)


    def get_grid(self) -> "Grid &":
        """get_grid(CollectionCDgrid self) -> Grid"""
        return _sim2d.CollectionCDgrid_get_grid(self)


    def get_epsilon(self) -> "flt":
        """get_epsilon(CollectionCDgrid self) -> flt"""
        return _sim2d.CollectionCDgrid_get_epsilon(self)


    def set_epsilon(self, eps: 'flt') -> "void":
        """set_epsilon(CollectionCDgrid self, flt eps)"""
        return _sim2d.CollectionCDgrid_set_epsilon(self, eps)


    def reset_velocities(self, T: 'flt') -> "void":
        """reset_velocities(CollectionCDgrid self, flt T)"""
        return _sim2d.CollectionCDgrid_reset_velocities(self, T)


    def take_step(self, tlim: 'flt'=-1) -> "bool":
        """
        take_step(CollectionCDgrid self, flt tlim=-1) -> bool
        take_step(CollectionCDgrid self) -> bool
        """
        return _sim2d.CollectionCDgrid_take_step(self, tlim)


    def timestep(self) -> "void":
        """timestep(CollectionCDgrid self)"""
        return _sim2d.CollectionCDgrid_timestep(self)


    def events_processed(self) -> "long long":
        """events_processed(CollectionCDgrid self) -> long long"""
        return _sim2d.CollectionCDgrid_events_processed(self)

    __swig_destroy__ = _sim2d.delete_CollectionCDgrid
    __del__ = lambda self: None
CollectionCDgrid_swigregister = _sim2d.CollectionCDgrid_swigregister
CollectionCDgrid_swigregister(CollectionCDgrid)

class CollectionCDBD(CollectionCD):
    """Proxy of C++ CollectionCDBD class."""

    __swig_setmethods__ = {}
    for _s in [CollectionCD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionCDBD, name, value)
    __swig_getmethods__ = {}
    for _s in [CollectionCD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionCDBD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionCDBD
        __init__(CollectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes, ivector interactions, tvector trackers) -> CollectionCDBD
        __init__(CollectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes, ivector interactions) -> CollectionCDBD
        __init__(CollectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes) -> CollectionCDBD
        __init__(CollectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T) -> CollectionCDBD
        """
        this = _sim2d.new_CollectionCDBD(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionCDBD self)"""
        return _sim2d.CollectionCDBD_timestep(self)

    __swig_destroy__ = _sim2d.delete_CollectionCDBD
    __del__ = lambda self: None
CollectionCDBD_swigregister = _sim2d.CollectionCDBD_swigregister
CollectionCDBD_swigregister(CollectionCDBD)

class CollectionCDBDgrid(CollectionCDgrid):
    """Proxy of C++ CollectionCDBDgrid class."""

    __swig_setmethods__ = {}
    for _s in [CollectionCDgrid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollectionCDBDgrid, name, value)
    __swig_getmethods__ = {}
    for _s in [CollectionCDgrid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollectionCDBDgrid, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CollectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes, ivector interactions, tvector trackers, constraintvector constraints) -> CollectionCDBDgrid
        __init__(CollectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes, ivector interactions, tvector trackers) -> CollectionCDBDgrid
        __init__(CollectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes, ivector interactions) -> CollectionCDBDgrid
        __init__(CollectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T, dvector sizes) -> CollectionCDBDgrid
        __init__(CollectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< AtomGroup > atoms, flt const dt, flt const T) -> CollectionCDBDgrid
        """
        this = _sim2d.new_CollectionCDBDgrid(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def timestep(self) -> "void":
        """timestep(CollectionCDBDgrid self)"""
        return _sim2d.CollectionCDBDgrid_timestep(self)

    __swig_destroy__ = _sim2d.delete_CollectionCDBDgrid
    __del__ = lambda self: None
CollectionCDBDgrid_swigregister = _sim2d.CollectionCDBDgrid_swigregister
CollectionCDBDgrid_swigregister(CollectionCDBDgrid)


def make_event(box: 'Box', e: 'Event', a: 'AtomID', b: 'AtomID', sigma: 'flt', curt: 'flt') -> "bool":
    """make_event(Box box, Event e, AtomID a, AtomID b, flt sigma, flt curt) -> bool"""
    return _sim2d.make_event(box, e, a, b, sigma, curt)

def collide(box: 'Box', a: 'Atom', b: 'Atom') -> "void":
    """collide(Box box, Atom a, Atom b)"""
    return _sim2d.collide(box, a, b)
# This file is compatible with both classic and new-style classes.


