# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sim2d', [dirname(__file__)])
        except ImportError:
            import _sim2d
            return _sim2d
        if fp is not None:
            try:
                _mod = imp.load_module('_sim2d', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _sim2d = swig_import_helper()
    del swig_import_helper
else:
    import _sim2d
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


import collections
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sim2d.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        """value(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_value(self)


    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2d.SwigPyIterator_incr(self, n)


    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2d.SwigPyIterator_decr(self, n)


    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _sim2d.SwigPyIterator_distance(self, x)


    def equal(self, x: 'SwigPyIterator') -> "bool":
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator_equal(self, x)


    def copy(self) -> "swig::SwigPyIterator *":
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator_copy(self)


    def next(self) -> "PyObject *":
        """next(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_next(self)


    def __next__(self) -> "PyObject *":
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator___next__(self)


    def previous(self) -> "PyObject *":
        """previous(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_previous(self)


    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator_advance(self, n)


    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator___eq__(self, x)


    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___isub__(self, n)


    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___add__(self, n)


    def __sub__(self, *args) -> "ptrdiff_t":
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _sim2d.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _sim2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_sim2d.SHARED_PTR_DISOWN_swigconstant(_sim2d)
SHARED_PTR_DISOWN = _sim2d.SHARED_PTR_DISOWN
class _jamminglist(collections.MutableSequence):
    """Proxy of C++ std::list<(jamminglist)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _jamminglist, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _jamminglist, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_jamminglist self) -> SwigPyIterator"""
        return _sim2d._jamminglist_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_jamminglist self) -> bool"""
        return _sim2d._jamminglist___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_jamminglist self) -> bool"""
        return _sim2d._jamminglist___bool__(self)


    def __len__(self) -> "std::list< jamminglist >::size_type":
        """__len__(_jamminglist self) -> std::list< jamminglist >::size_type"""
        return _sim2d._jamminglist___len__(self)


    def pop(self) -> "std::list< jamminglist >::value_type":
        """pop(_jamminglist self) -> jamminglist"""
        return _sim2d._jamminglist_pop(self)


    def __getslice__(self, i: 'std::list< jamminglist >::difference_type', j: 'std::list< jamminglist >::difference_type') -> "std::list< jamminglist,std::allocator< jamminglist > > *":
        """__getslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j) -> _jamminglist"""
        return _sim2d._jamminglist___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j, _jamminglist v)
        __setslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j)
        """
        return _sim2d._jamminglist___setslice__(self, *args)


    def __delslice__(self, i: 'std::list< jamminglist >::difference_type', j: 'std::list< jamminglist >::difference_type') -> "void":
        """__delslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j)"""
        return _sim2d._jamminglist___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_jamminglist self, std::list< jamminglist >::difference_type i)
        __delitem__(_jamminglist self, PySliceObject * slice)
        """
        return _sim2d._jamminglist___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::list< jamminglist >::value_type const &":
        """
        __getitem__(_jamminglist self, PySliceObject * slice) -> _jamminglist
        __getitem__(_jamminglist self, std::list< jamminglist >::difference_type i) -> jamminglist
        """
        return _sim2d._jamminglist___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_jamminglist self, PySliceObject * slice, _jamminglist v)
        __setitem__(_jamminglist self, PySliceObject * slice)
        __setitem__(_jamminglist self, std::list< jamminglist >::difference_type i, jamminglist x)
        """
        return _sim2d._jamminglist___setitem__(self, *args)


    def append(self, x: 'jamminglist') -> "void":
        """append(_jamminglist self, jamminglist x)"""
        return _sim2d._jamminglist_append(self, x)


    def empty(self) -> "bool":
        """empty(_jamminglist self) -> bool"""
        return _sim2d._jamminglist_empty(self)


    def size(self) -> "std::list< jamminglist >::size_type":
        """size(_jamminglist self) -> std::list< jamminglist >::size_type"""
        return _sim2d._jamminglist_size(self)


    def clear(self) -> "void":
        """clear(_jamminglist self)"""
        return _sim2d._jamminglist_clear(self)


    def swap(self, v: '_jamminglist') -> "void":
        """swap(_jamminglist self, _jamminglist v)"""
        return _sim2d._jamminglist_swap(self, v)


    def get_allocator(self) -> "std::list< jamminglist >::allocator_type":
        """get_allocator(_jamminglist self) -> std::list< jamminglist >::allocator_type"""
        return _sim2d._jamminglist_get_allocator(self)


    def begin(self) -> "std::list< jamminglist >::iterator":
        """begin(_jamminglist self) -> std::list< jamminglist >::iterator"""
        return _sim2d._jamminglist_begin(self)


    def end(self) -> "std::list< jamminglist >::iterator":
        """end(_jamminglist self) -> std::list< jamminglist >::iterator"""
        return _sim2d._jamminglist_end(self)


    def rbegin(self) -> "std::list< jamminglist >::reverse_iterator":
        """rbegin(_jamminglist self) -> std::list< jamminglist >::reverse_iterator"""
        return _sim2d._jamminglist_rbegin(self)


    def rend(self) -> "std::list< jamminglist >::reverse_iterator":
        """rend(_jamminglist self) -> std::list< jamminglist >::reverse_iterator"""
        return _sim2d._jamminglist_rend(self)


    def pop_back(self) -> "void":
        """pop_back(_jamminglist self)"""
        return _sim2d._jamminglist_pop_back(self)


    def erase(self, *args) -> "std::list< jamminglist >::iterator":
        """
        erase(_jamminglist self, std::list< jamminglist >::iterator pos) -> std::list< jamminglist >::iterator
        erase(_jamminglist self, std::list< jamminglist >::iterator first, std::list< jamminglist >::iterator last) -> std::list< jamminglist >::iterator
        """
        return _sim2d._jamminglist_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::list<(jamminglist)> self) -> _jamminglist
        __init__(std::list<(jamminglist)> self, _jamminglist arg2) -> _jamminglist
        __init__(std::list<(jamminglist)> self, std::list< jamminglist >::size_type size) -> _jamminglist
        __init__(std::list<(jamminglist)> self, std::list< jamminglist >::size_type size, jamminglist value) -> _jamminglist
        """
        this = _sim2d.new__jamminglist(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'jamminglist') -> "void":
        """push_back(_jamminglist self, jamminglist x)"""
        return _sim2d._jamminglist_push_back(self, x)


    def front(self) -> "std::list< jamminglist >::value_type const &":
        """front(_jamminglist self) -> jamminglist"""
        return _sim2d._jamminglist_front(self)


    def back(self) -> "std::list< jamminglist >::value_type const &":
        """back(_jamminglist self) -> jamminglist"""
        return _sim2d._jamminglist_back(self)


    def assign(self, n: 'std::list< jamminglist >::size_type', x: 'jamminglist') -> "void":
        """assign(_jamminglist self, std::list< jamminglist >::size_type n, jamminglist x)"""
        return _sim2d._jamminglist_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_jamminglist self, std::list< jamminglist >::size_type new_size)
        resize(_jamminglist self, std::list< jamminglist >::size_type new_size, jamminglist x)
        """
        return _sim2d._jamminglist_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_jamminglist self, std::list< jamminglist >::iterator pos, jamminglist x) -> std::list< jamminglist >::iterator
        insert(_jamminglist self, std::list< jamminglist >::iterator pos, std::list< jamminglist >::size_type n, jamminglist x)
        """
        return _sim2d._jamminglist_insert(self, *args)


    def pop_front(self) -> "void":
        """pop_front(_jamminglist self)"""
        return _sim2d._jamminglist_pop_front(self)


    def push_front(self, x: 'jamminglist') -> "void":
        """push_front(_jamminglist self, jamminglist x)"""
        return _sim2d._jamminglist_push_front(self, x)


    def reverse(self) -> "void":
        """reverse(_jamminglist self)"""
        return _sim2d._jamminglist_reverse(self)

    __swig_destroy__ = _sim2d.delete__jamminglist
    __del__ = lambda self: None
_jamminglist_swigregister = _sim2d._jamminglist_swigregister
_jamminglist_swigregister(_jamminglist)

class _jamminglistrot(collections.MutableSequence):
    """Proxy of C++ std::list<(jamminglistrot)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _jamminglistrot, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _jamminglistrot, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_jamminglistrot self) -> SwigPyIterator"""
        return _sim2d._jamminglistrot_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_jamminglistrot self) -> bool"""
        return _sim2d._jamminglistrot___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_jamminglistrot self) -> bool"""
        return _sim2d._jamminglistrot___bool__(self)


    def __len__(self) -> "std::list< jamminglistrot >::size_type":
        """__len__(_jamminglistrot self) -> std::list< jamminglistrot >::size_type"""
        return _sim2d._jamminglistrot___len__(self)


    def pop(self) -> "std::list< jamminglistrot >::value_type":
        """pop(_jamminglistrot self) -> jamminglistrot"""
        return _sim2d._jamminglistrot_pop(self)


    def __getslice__(self, i: 'std::list< jamminglistrot >::difference_type', j: 'std::list< jamminglistrot >::difference_type') -> "std::list< jamminglistrot,std::allocator< jamminglistrot > > *":
        """__getslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j) -> _jamminglistrot"""
        return _sim2d._jamminglistrot___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j, _jamminglistrot v)
        __setslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j)
        """
        return _sim2d._jamminglistrot___setslice__(self, *args)


    def __delslice__(self, i: 'std::list< jamminglistrot >::difference_type', j: 'std::list< jamminglistrot >::difference_type') -> "void":
        """__delslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j)"""
        return _sim2d._jamminglistrot___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i)
        __delitem__(_jamminglistrot self, PySliceObject * slice)
        """
        return _sim2d._jamminglistrot___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::list< jamminglistrot >::value_type const &":
        """
        __getitem__(_jamminglistrot self, PySliceObject * slice) -> _jamminglistrot
        __getitem__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i) -> jamminglistrot
        """
        return _sim2d._jamminglistrot___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_jamminglistrot self, PySliceObject * slice, _jamminglistrot v)
        __setitem__(_jamminglistrot self, PySliceObject * slice)
        __setitem__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, jamminglistrot x)
        """
        return _sim2d._jamminglistrot___setitem__(self, *args)


    def append(self, x: 'jamminglistrot') -> "void":
        """append(_jamminglistrot self, jamminglistrot x)"""
        return _sim2d._jamminglistrot_append(self, x)


    def empty(self) -> "bool":
        """empty(_jamminglistrot self) -> bool"""
        return _sim2d._jamminglistrot_empty(self)


    def size(self) -> "std::list< jamminglistrot >::size_type":
        """size(_jamminglistrot self) -> std::list< jamminglistrot >::size_type"""
        return _sim2d._jamminglistrot_size(self)


    def clear(self) -> "void":
        """clear(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_clear(self)


    def swap(self, v: '_jamminglistrot') -> "void":
        """swap(_jamminglistrot self, _jamminglistrot v)"""
        return _sim2d._jamminglistrot_swap(self, v)


    def get_allocator(self) -> "std::list< jamminglistrot >::allocator_type":
        """get_allocator(_jamminglistrot self) -> std::list< jamminglistrot >::allocator_type"""
        return _sim2d._jamminglistrot_get_allocator(self)


    def begin(self) -> "std::list< jamminglistrot >::iterator":
        """begin(_jamminglistrot self) -> std::list< jamminglistrot >::iterator"""
        return _sim2d._jamminglistrot_begin(self)


    def end(self) -> "std::list< jamminglistrot >::iterator":
        """end(_jamminglistrot self) -> std::list< jamminglistrot >::iterator"""
        return _sim2d._jamminglistrot_end(self)


    def rbegin(self) -> "std::list< jamminglistrot >::reverse_iterator":
        """rbegin(_jamminglistrot self) -> std::list< jamminglistrot >::reverse_iterator"""
        return _sim2d._jamminglistrot_rbegin(self)


    def rend(self) -> "std::list< jamminglistrot >::reverse_iterator":
        """rend(_jamminglistrot self) -> std::list< jamminglistrot >::reverse_iterator"""
        return _sim2d._jamminglistrot_rend(self)


    def pop_back(self) -> "void":
        """pop_back(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_pop_back(self)


    def erase(self, *args) -> "std::list< jamminglistrot >::iterator":
        """
        erase(_jamminglistrot self, std::list< jamminglistrot >::iterator pos) -> std::list< jamminglistrot >::iterator
        erase(_jamminglistrot self, std::list< jamminglistrot >::iterator first, std::list< jamminglistrot >::iterator last) -> std::list< jamminglistrot >::iterator
        """
        return _sim2d._jamminglistrot_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::list<(jamminglistrot)> self) -> _jamminglistrot
        __init__(std::list<(jamminglistrot)> self, _jamminglistrot arg2) -> _jamminglistrot
        __init__(std::list<(jamminglistrot)> self, std::list< jamminglistrot >::size_type size) -> _jamminglistrot
        __init__(std::list<(jamminglistrot)> self, std::list< jamminglistrot >::size_type size, jamminglistrot value) -> _jamminglistrot
        """
        this = _sim2d.new__jamminglistrot(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'jamminglistrot') -> "void":
        """push_back(_jamminglistrot self, jamminglistrot x)"""
        return _sim2d._jamminglistrot_push_back(self, x)


    def front(self) -> "std::list< jamminglistrot >::value_type const &":
        """front(_jamminglistrot self) -> jamminglistrot"""
        return _sim2d._jamminglistrot_front(self)


    def back(self) -> "std::list< jamminglistrot >::value_type const &":
        """back(_jamminglistrot self) -> jamminglistrot"""
        return _sim2d._jamminglistrot_back(self)


    def assign(self, n: 'std::list< jamminglistrot >::size_type', x: 'jamminglistrot') -> "void":
        """assign(_jamminglistrot self, std::list< jamminglistrot >::size_type n, jamminglistrot x)"""
        return _sim2d._jamminglistrot_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_jamminglistrot self, std::list< jamminglistrot >::size_type new_size)
        resize(_jamminglistrot self, std::list< jamminglistrot >::size_type new_size, jamminglistrot x)
        """
        return _sim2d._jamminglistrot_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_jamminglistrot self, std::list< jamminglistrot >::iterator pos, jamminglistrot x) -> std::list< jamminglistrot >::iterator
        insert(_jamminglistrot self, std::list< jamminglistrot >::iterator pos, std::list< jamminglistrot >::size_type n, jamminglistrot x)
        """
        return _sim2d._jamminglistrot_insert(self, *args)


    def pop_front(self) -> "void":
        """pop_front(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_pop_front(self)


    def push_front(self, x: 'jamminglistrot') -> "void":
        """push_front(_jamminglistrot self, jamminglistrot x)"""
        return _sim2d._jamminglistrot_push_front(self, x)


    def reverse(self) -> "void":
        """reverse(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_reverse(self)

    __swig_destroy__ = _sim2d.delete__jamminglistrot
    __del__ = lambda self: None
_jamminglistrot_swigregister = _sim2d._jamminglistrot_swigregister
_jamminglistrot_swigregister(_jamminglistrot)

class fvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(fvector self) -> SwigPyIterator"""
        return _sim2d.fvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(fvector self) -> bool"""
        return _sim2d.fvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(fvector self) -> bool"""
        return _sim2d.fvector___bool__(self)


    def __len__(self) -> "std::vector< float >::size_type":
        """__len__(fvector self) -> std::vector< float >::size_type"""
        return _sim2d.fvector___len__(self)


    def pop(self) -> "std::vector< float >::value_type":
        """pop(fvector self) -> std::vector< float >::value_type"""
        return _sim2d.fvector_pop(self)


    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        """__getslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> fvector"""
        return _sim2d.fvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, fvector v)
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        """
        return _sim2d.fvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        """__delslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _sim2d.fvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(fvector self, std::vector< float >::difference_type i)
        __delitem__(fvector self, PySliceObject * slice)
        """
        return _sim2d.fvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        """
        __getitem__(fvector self, PySliceObject * slice) -> fvector
        __getitem__(fvector self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _sim2d.fvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(fvector self, PySliceObject * slice, fvector v)
        __setitem__(fvector self, PySliceObject * slice)
        __setitem__(fvector self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _sim2d.fvector___setitem__(self, *args)


    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        """append(fvector self, std::vector< float >::value_type const & x)"""
        return _sim2d.fvector_append(self, x)


    def empty(self) -> "bool":
        """empty(fvector self) -> bool"""
        return _sim2d.fvector_empty(self)


    def size(self) -> "std::vector< float >::size_type":
        """size(fvector self) -> std::vector< float >::size_type"""
        return _sim2d.fvector_size(self)


    def clear(self) -> "void":
        """clear(fvector self)"""
        return _sim2d.fvector_clear(self)


    def swap(self, v: 'fvector') -> "void":
        """swap(fvector self, fvector v)"""
        return _sim2d.fvector_swap(self, v)


    def get_allocator(self) -> "std::vector< float >::allocator_type":
        """get_allocator(fvector self) -> std::vector< float >::allocator_type"""
        return _sim2d.fvector_get_allocator(self)


    def begin(self) -> "std::vector< float >::iterator":
        """begin(fvector self) -> std::vector< float >::iterator"""
        return _sim2d.fvector_begin(self)


    def end(self) -> "std::vector< float >::iterator":
        """end(fvector self) -> std::vector< float >::iterator"""
        return _sim2d.fvector_end(self)


    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        """rbegin(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim2d.fvector_rbegin(self)


    def rend(self) -> "std::vector< float >::reverse_iterator":
        """rend(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim2d.fvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(fvector self)"""
        return _sim2d.fvector_pop_back(self)


    def erase(self, *args) -> "std::vector< float >::iterator":
        """
        erase(fvector self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(fvector self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _sim2d.fvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(float)> self) -> fvector
        __init__(std::vector<(float)> self, fvector arg2) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> fvector
        """
        this = _sim2d.new_fvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        """push_back(fvector self, std::vector< float >::value_type const & x)"""
        return _sim2d.fvector_push_back(self, x)


    def front(self) -> "std::vector< float >::value_type const &":
        """front(fvector self) -> std::vector< float >::value_type const &"""
        return _sim2d.fvector_front(self)


    def back(self) -> "std::vector< float >::value_type const &":
        """back(fvector self) -> std::vector< float >::value_type const &"""
        return _sim2d.fvector_back(self)


    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        """assign(fvector self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _sim2d.fvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(fvector self, std::vector< float >::size_type new_size)
        resize(fvector self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _sim2d.fvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _sim2d.fvector_insert(self, *args)


    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        """reserve(fvector self, std::vector< float >::size_type n)"""
        return _sim2d.fvector_reserve(self, n)


    def capacity(self) -> "std::vector< float >::size_type":
        """capacity(fvector self) -> std::vector< float >::size_type"""
        return _sim2d.fvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_fvector
    __del__ = lambda self: None
fvector_swigregister = _sim2d.fvector_swigregister
fvector_swigregister(fvector)

class _ffvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(float)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ffvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ffvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ffvector self) -> SwigPyIterator"""
        return _sim2d._ffvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ffvector self) -> bool"""
        return _sim2d._ffvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ffvector self) -> bool"""
        return _sim2d._ffvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< float > >::size_type":
        """__len__(_ffvector self) -> std::vector< std::vector< float > >::size_type"""
        return _sim2d._ffvector___len__(self)


    def pop(self) -> "std::vector< std::vector< float > >::value_type":
        """pop(_ffvector self) -> fvector"""
        return _sim2d._ffvector_pop(self)


    def __getslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > *":
        """__getslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j) -> _ffvector"""
        return _sim2d._ffvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j, _ffvector v)
        __setslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)
        """
        return _sim2d._ffvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "void":
        """__delslice__(_ffvector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)"""
        return _sim2d._ffvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ffvector self, std::vector< std::vector< float > >::difference_type i)
        __delitem__(_ffvector self, PySliceObject * slice)
        """
        return _sim2d._ffvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< float > >::value_type const &":
        """
        __getitem__(_ffvector self, PySliceObject * slice) -> _ffvector
        __getitem__(_ffvector self, std::vector< std::vector< float > >::difference_type i) -> fvector
        """
        return _sim2d._ffvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ffvector self, PySliceObject * slice, _ffvector v)
        __setitem__(_ffvector self, PySliceObject * slice)
        __setitem__(_ffvector self, std::vector< std::vector< float > >::difference_type i, fvector x)
        """
        return _sim2d._ffvector___setitem__(self, *args)


    def append(self, x: 'fvector') -> "void":
        """append(_ffvector self, fvector x)"""
        return _sim2d._ffvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_ffvector self) -> bool"""
        return _sim2d._ffvector_empty(self)


    def size(self) -> "std::vector< std::vector< float > >::size_type":
        """size(_ffvector self) -> std::vector< std::vector< float > >::size_type"""
        return _sim2d._ffvector_size(self)


    def clear(self) -> "void":
        """clear(_ffvector self)"""
        return _sim2d._ffvector_clear(self)


    def swap(self, v: '_ffvector') -> "void":
        """swap(_ffvector self, _ffvector v)"""
        return _sim2d._ffvector_swap(self, v)


    def get_allocator(self) -> "std::vector< std::vector< float > >::allocator_type":
        """get_allocator(_ffvector self) -> std::vector< std::vector< float > >::allocator_type"""
        return _sim2d._ffvector_get_allocator(self)


    def begin(self) -> "std::vector< std::vector< float > >::iterator":
        """begin(_ffvector self) -> std::vector< std::vector< float > >::iterator"""
        return _sim2d._ffvector_begin(self)


    def end(self) -> "std::vector< std::vector< float > >::iterator":
        """end(_ffvector self) -> std::vector< std::vector< float > >::iterator"""
        return _sim2d._ffvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        """rbegin(_ffvector self) -> std::vector< std::vector< float > >::reverse_iterator"""
        return _sim2d._ffvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        """rend(_ffvector self) -> std::vector< std::vector< float > >::reverse_iterator"""
        return _sim2d._ffvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(_ffvector self)"""
        return _sim2d._ffvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< float > >::iterator":
        """
        erase(_ffvector self, std::vector< std::vector< float > >::iterator pos) -> std::vector< std::vector< float > >::iterator
        erase(_ffvector self, std::vector< std::vector< float > >::iterator first, std::vector< std::vector< float > >::iterator last) -> std::vector< std::vector< float > >::iterator
        """
        return _sim2d._ffvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(float)>)> self) -> _ffvector
        __init__(std::vector<(std::vector<(float)>)> self, _ffvector arg2) -> _ffvector
        __init__(std::vector<(std::vector<(float)>)> self, std::vector< std::vector< float > >::size_type size) -> _ffvector
        __init__(std::vector<(std::vector<(float)>)> self, std::vector< std::vector< float > >::size_type size, fvector value) -> _ffvector
        """
        this = _sim2d.new__ffvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'fvector') -> "void":
        """push_back(_ffvector self, fvector x)"""
        return _sim2d._ffvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< float > >::value_type const &":
        """front(_ffvector self) -> fvector"""
        return _sim2d._ffvector_front(self)


    def back(self) -> "std::vector< std::vector< float > >::value_type const &":
        """back(_ffvector self) -> fvector"""
        return _sim2d._ffvector_back(self)


    def assign(self, n: 'std::vector< std::vector< float > >::size_type', x: 'fvector') -> "void":
        """assign(_ffvector self, std::vector< std::vector< float > >::size_type n, fvector x)"""
        return _sim2d._ffvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ffvector self, std::vector< std::vector< float > >::size_type new_size)
        resize(_ffvector self, std::vector< std::vector< float > >::size_type new_size, fvector x)
        """
        return _sim2d._ffvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ffvector self, std::vector< std::vector< float > >::iterator pos, fvector x) -> std::vector< std::vector< float > >::iterator
        insert(_ffvector self, std::vector< std::vector< float > >::iterator pos, std::vector< std::vector< float > >::size_type n, fvector x)
        """
        return _sim2d._ffvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< float > >::size_type') -> "void":
        """reserve(_ffvector self, std::vector< std::vector< float > >::size_type n)"""
        return _sim2d._ffvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< float > >::size_type":
        """capacity(_ffvector self) -> std::vector< std::vector< float > >::size_type"""
        return _sim2d._ffvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__ffvector
    __del__ = lambda self: None
_ffvector_swigregister = _sim2d._ffvector_swigregister
_ffvector_swigregister(_ffvector)

class dvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, dvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(dvector self) -> SwigPyIterator"""
        return _sim2d.dvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(dvector self) -> bool"""
        return _sim2d.dvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(dvector self) -> bool"""
        return _sim2d.dvector___bool__(self)


    def __len__(self) -> "std::vector< double >::size_type":
        """__len__(dvector self) -> std::vector< double >::size_type"""
        return _sim2d.dvector___len__(self)


    def pop(self) -> "std::vector< double >::value_type":
        """pop(dvector self) -> std::vector< double >::value_type"""
        return _sim2d.dvector_pop(self)


    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        """__getslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> dvector"""
        return _sim2d.dvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, dvector v)
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _sim2d.dvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        """__delslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _sim2d.dvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(dvector self, std::vector< double >::difference_type i)
        __delitem__(dvector self, PySliceObject * slice)
        """
        return _sim2d.dvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        """
        __getitem__(dvector self, PySliceObject * slice) -> dvector
        __getitem__(dvector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _sim2d.dvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(dvector self, PySliceObject * slice, dvector v)
        __setitem__(dvector self, PySliceObject * slice)
        __setitem__(dvector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _sim2d.dvector___setitem__(self, *args)


    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        """append(dvector self, std::vector< double >::value_type const & x)"""
        return _sim2d.dvector_append(self, x)


    def empty(self) -> "bool":
        """empty(dvector self) -> bool"""
        return _sim2d.dvector_empty(self)


    def size(self) -> "std::vector< double >::size_type":
        """size(dvector self) -> std::vector< double >::size_type"""
        return _sim2d.dvector_size(self)


    def clear(self) -> "void":
        """clear(dvector self)"""
        return _sim2d.dvector_clear(self)


    def swap(self, v: 'dvector') -> "void":
        """swap(dvector self, dvector v)"""
        return _sim2d.dvector_swap(self, v)


    def get_allocator(self) -> "std::vector< double >::allocator_type":
        """get_allocator(dvector self) -> std::vector< double >::allocator_type"""
        return _sim2d.dvector_get_allocator(self)


    def begin(self) -> "std::vector< double >::iterator":
        """begin(dvector self) -> std::vector< double >::iterator"""
        return _sim2d.dvector_begin(self)


    def end(self) -> "std::vector< double >::iterator":
        """end(dvector self) -> std::vector< double >::iterator"""
        return _sim2d.dvector_end(self)


    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        """rbegin(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim2d.dvector_rbegin(self)


    def rend(self) -> "std::vector< double >::reverse_iterator":
        """rend(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim2d.dvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(dvector self)"""
        return _sim2d.dvector_pop_back(self)


    def erase(self, *args) -> "std::vector< double >::iterator":
        """
        erase(dvector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(dvector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _sim2d.dvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> dvector
        __init__(std::vector<(double)> self, dvector arg2) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> dvector
        """
        this = _sim2d.new_dvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        """push_back(dvector self, std::vector< double >::value_type const & x)"""
        return _sim2d.dvector_push_back(self, x)


    def front(self) -> "std::vector< double >::value_type const &":
        """front(dvector self) -> std::vector< double >::value_type const &"""
        return _sim2d.dvector_front(self)


    def back(self) -> "std::vector< double >::value_type const &":
        """back(dvector self) -> std::vector< double >::value_type const &"""
        return _sim2d.dvector_back(self)


    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        """assign(dvector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _sim2d.dvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(dvector self, std::vector< double >::size_type new_size)
        resize(dvector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _sim2d.dvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _sim2d.dvector_insert(self, *args)


    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        """reserve(dvector self, std::vector< double >::size_type n)"""
        return _sim2d.dvector_reserve(self, n)


    def capacity(self) -> "std::vector< double >::size_type":
        """capacity(dvector self) -> std::vector< double >::size_type"""
        return _sim2d.dvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_dvector
    __del__ = lambda self: None
dvector_swigregister = _sim2d.dvector_swigregister
dvector_swigregister(dvector)

class _ddvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ddvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ddvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ddvector self) -> SwigPyIterator"""
        return _sim2d._ddvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ddvector self) -> bool"""
        return _sim2d._ddvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ddvector self) -> bool"""
        return _sim2d._ddvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< double > >::size_type":
        """__len__(_ddvector self) -> std::vector< std::vector< double > >::size_type"""
        return _sim2d._ddvector___len__(self)


    def pop(self) -> "std::vector< std::vector< double > >::value_type":
        """pop(_ddvector self) -> dvector"""
        return _sim2d._ddvector_pop(self)


    def __getslice__(self, i: 'std::vector< std::vector< double > >::difference_type', j: 'std::vector< std::vector< double > >::difference_type') -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *":
        """__getslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> _ddvector"""
        return _sim2d._ddvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, _ddvector v)
        __setslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        """
        return _sim2d._ddvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< double > >::difference_type', j: 'std::vector< std::vector< double > >::difference_type') -> "void":
        """__delslice__(_ddvector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _sim2d._ddvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ddvector self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(_ddvector self, PySliceObject * slice)
        """
        return _sim2d._ddvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< double > >::value_type const &":
        """
        __getitem__(_ddvector self, PySliceObject * slice) -> _ddvector
        __getitem__(_ddvector self, std::vector< std::vector< double > >::difference_type i) -> dvector
        """
        return _sim2d._ddvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ddvector self, PySliceObject * slice, _ddvector v)
        __setitem__(_ddvector self, PySliceObject * slice)
        __setitem__(_ddvector self, std::vector< std::vector< double > >::difference_type i, dvector x)
        """
        return _sim2d._ddvector___setitem__(self, *args)


    def append(self, x: 'dvector') -> "void":
        """append(_ddvector self, dvector x)"""
        return _sim2d._ddvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_ddvector self) -> bool"""
        return _sim2d._ddvector_empty(self)


    def size(self) -> "std::vector< std::vector< double > >::size_type":
        """size(_ddvector self) -> std::vector< std::vector< double > >::size_type"""
        return _sim2d._ddvector_size(self)


    def clear(self) -> "void":
        """clear(_ddvector self)"""
        return _sim2d._ddvector_clear(self)


    def swap(self, v: '_ddvector') -> "void":
        """swap(_ddvector self, _ddvector v)"""
        return _sim2d._ddvector_swap(self, v)


    def get_allocator(self) -> "std::vector< std::vector< double > >::allocator_type":
        """get_allocator(_ddvector self) -> std::vector< std::vector< double > >::allocator_type"""
        return _sim2d._ddvector_get_allocator(self)


    def begin(self) -> "std::vector< std::vector< double > >::iterator":
        """begin(_ddvector self) -> std::vector< std::vector< double > >::iterator"""
        return _sim2d._ddvector_begin(self)


    def end(self) -> "std::vector< std::vector< double > >::iterator":
        """end(_ddvector self) -> std::vector< std::vector< double > >::iterator"""
        return _sim2d._ddvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        """rbegin(_ddvector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _sim2d._ddvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        """rend(_ddvector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _sim2d._ddvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(_ddvector self)"""
        return _sim2d._ddvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< double > >::iterator":
        """
        erase(_ddvector self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(_ddvector self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _sim2d._ddvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> _ddvector
        __init__(std::vector<(std::vector<(double)>)> self, _ddvector arg2) -> _ddvector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> _ddvector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, dvector value) -> _ddvector
        """
        this = _sim2d.new__ddvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'dvector') -> "void":
        """push_back(_ddvector self, dvector x)"""
        return _sim2d._ddvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< double > >::value_type const &":
        """front(_ddvector self) -> dvector"""
        return _sim2d._ddvector_front(self)


    def back(self) -> "std::vector< std::vector< double > >::value_type const &":
        """back(_ddvector self) -> dvector"""
        return _sim2d._ddvector_back(self)


    def assign(self, n: 'std::vector< std::vector< double > >::size_type', x: 'dvector') -> "void":
        """assign(_ddvector self, std::vector< std::vector< double > >::size_type n, dvector x)"""
        return _sim2d._ddvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ddvector self, std::vector< std::vector< double > >::size_type new_size)
        resize(_ddvector self, std::vector< std::vector< double > >::size_type new_size, dvector x)
        """
        return _sim2d._ddvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ddvector self, std::vector< std::vector< double > >::iterator pos, dvector x) -> std::vector< std::vector< double > >::iterator
        insert(_ddvector self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, dvector x)
        """
        return _sim2d._ddvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< double > >::size_type') -> "void":
        """reserve(_ddvector self, std::vector< std::vector< double > >::size_type n)"""
        return _sim2d._ddvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< double > >::size_type":
        """capacity(_ddvector self) -> std::vector< std::vector< double > >::size_type"""
        return _sim2d._ddvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__ddvector
    __del__ = lambda self: None
_ddvector_swigregister = _sim2d._ddvector_swigregister
_ddvector_swigregister(_ddvector)

class _dddvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(double)>)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _dddvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _dddvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_dddvector self) -> SwigPyIterator"""
        return _sim2d._dddvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_dddvector self) -> bool"""
        return _sim2d._dddvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_dddvector self) -> bool"""
        return _sim2d._dddvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::vector< double > > >::size_type":
        """__len__(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _sim2d._dddvector___len__(self)


    def pop(self) -> "std::vector< std::vector< std::vector< double > > >::value_type":
        """pop(_dddvector self) -> _ddvector"""
        return _sim2d._dddvector_pop(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::vector< double > > >::difference_type', j: 'std::vector< std::vector< std::vector< double > > >::difference_type') -> "std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > *":
        """__getslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j) -> _dddvector"""
        return _sim2d._dddvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j, _dddvector v)
        __setslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j)
        """
        return _sim2d._dddvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::vector< double > > >::difference_type', j: 'std::vector< std::vector< std::vector< double > > >::difference_type') -> "void":
        """__delslice__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j)"""
        return _sim2d._dddvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i)
        __delitem__(_dddvector self, PySliceObject * slice)
        """
        return _sim2d._dddvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::vector< double > > >::value_type const &":
        """
        __getitem__(_dddvector self, PySliceObject * slice) -> _dddvector
        __getitem__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i) -> _ddvector
        """
        return _sim2d._dddvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_dddvector self, PySliceObject * slice, _dddvector v)
        __setitem__(_dddvector self, PySliceObject * slice)
        __setitem__(_dddvector self, std::vector< std::vector< std::vector< double > > >::difference_type i, _ddvector x)
        """
        return _sim2d._dddvector___setitem__(self, *args)


    def append(self, x: '_ddvector') -> "void":
        """append(_dddvector self, _ddvector x)"""
        return _sim2d._dddvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_dddvector self) -> bool"""
        return _sim2d._dddvector_empty(self)


    def size(self) -> "std::vector< std::vector< std::vector< double > > >::size_type":
        """size(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _sim2d._dddvector_size(self)


    def clear(self) -> "void":
        """clear(_dddvector self)"""
        return _sim2d._dddvector_clear(self)


    def swap(self, v: '_dddvector') -> "void":
        """swap(_dddvector self, _dddvector v)"""
        return _sim2d._dddvector_swap(self, v)


    def get_allocator(self) -> "std::vector< std::vector< std::vector< double > > >::allocator_type":
        """get_allocator(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::allocator_type"""
        return _sim2d._dddvector_get_allocator(self)


    def begin(self) -> "std::vector< std::vector< std::vector< double > > >::iterator":
        """begin(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::iterator"""
        return _sim2d._dddvector_begin(self)


    def end(self) -> "std::vector< std::vector< std::vector< double > > >::iterator":
        """end(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::iterator"""
        return _sim2d._dddvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::vector< double > > >::reverse_iterator":
        """rbegin(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::reverse_iterator"""
        return _sim2d._dddvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::vector< double > > >::reverse_iterator":
        """rend(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::reverse_iterator"""
        return _sim2d._dddvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(_dddvector self)"""
        return _sim2d._dddvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::vector< double > > >::iterator":
        """
        erase(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator pos) -> std::vector< std::vector< std::vector< double > > >::iterator
        erase(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator first, std::vector< std::vector< std::vector< double > > >::iterator last) -> std::vector< std::vector< std::vector< double > > >::iterator
        """
        return _sim2d._dddvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self) -> _dddvector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, _dddvector arg2) -> _dddvector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, std::vector< std::vector< std::vector< double > > >::size_type size) -> _dddvector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, std::vector< std::vector< std::vector< double > > >::size_type size, _ddvector value) -> _dddvector
        """
        this = _sim2d.new__dddvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: '_ddvector') -> "void":
        """push_back(_dddvector self, _ddvector x)"""
        return _sim2d._dddvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::vector< double > > >::value_type const &":
        """front(_dddvector self) -> _ddvector"""
        return _sim2d._dddvector_front(self)


    def back(self) -> "std::vector< std::vector< std::vector< double > > >::value_type const &":
        """back(_dddvector self) -> _ddvector"""
        return _sim2d._dddvector_back(self)


    def assign(self, n: 'std::vector< std::vector< std::vector< double > > >::size_type', x: '_ddvector') -> "void":
        """assign(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type n, _ddvector x)"""
        return _sim2d._dddvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type new_size)
        resize(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type new_size, _ddvector x)
        """
        return _sim2d._dddvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator pos, _ddvector x) -> std::vector< std::vector< std::vector< double > > >::iterator
        insert(_dddvector self, std::vector< std::vector< std::vector< double > > >::iterator pos, std::vector< std::vector< std::vector< double > > >::size_type n, _ddvector x)
        """
        return _sim2d._dddvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::vector< double > > >::size_type') -> "void":
        """reserve(_dddvector self, std::vector< std::vector< std::vector< double > > >::size_type n)"""
        return _sim2d._dddvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::vector< double > > >::size_type":
        """capacity(_dddvector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _sim2d._dddvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__dddvector
    __del__ = lambda self: None
_dddvector_swigregister = _sim2d._dddvector_swigregister
_dddvector_swigregister(_dddvector)

class cvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::complex<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(cvector self) -> SwigPyIterator"""
        return _sim2d.cvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(cvector self) -> bool"""
        return _sim2d.cvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(cvector self) -> bool"""
        return _sim2d.cvector___bool__(self)


    def __len__(self) -> "std::vector< std::complex< double > >::size_type":
        """__len__(cvector self) -> std::vector< std::complex< double > >::size_type"""
        return _sim2d.cvector___len__(self)


    def pop(self) -> "std::vector< std::complex< double > >::value_type":
        """pop(cvector self) -> std::vector< std::complex< double > >::value_type"""
        return _sim2d.cvector_pop(self)


    def __getslice__(self, i: 'std::vector< std::complex< double > >::difference_type', j: 'std::vector< std::complex< double > >::difference_type') -> "std::vector< std::complex< double >,std::allocator< std::complex< double > > > *":
        """__getslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> cvector"""
        return _sim2d.cvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, cvector v)
        __setslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        """
        return _sim2d.cvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::complex< double > >::difference_type', j: 'std::vector< std::complex< double > >::difference_type') -> "void":
        """__delslice__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _sim2d.cvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(cvector self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(cvector self, PySliceObject * slice)
        """
        return _sim2d.cvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::complex< double > >::value_type const &":
        """
        __getitem__(cvector self, PySliceObject * slice) -> cvector
        __getitem__(cvector self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _sim2d.cvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(cvector self, PySliceObject * slice, cvector v)
        __setitem__(cvector self, PySliceObject * slice)
        __setitem__(cvector self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _sim2d.cvector___setitem__(self, *args)


    def append(self, x: 'std::vector< std::complex< double > >::value_type const &') -> "void":
        """append(cvector self, std::vector< std::complex< double > >::value_type const & x)"""
        return _sim2d.cvector_append(self, x)


    def empty(self) -> "bool":
        """empty(cvector self) -> bool"""
        return _sim2d.cvector_empty(self)


    def size(self) -> "std::vector< std::complex< double > >::size_type":
        """size(cvector self) -> std::vector< std::complex< double > >::size_type"""
        return _sim2d.cvector_size(self)


    def clear(self) -> "void":
        """clear(cvector self)"""
        return _sim2d.cvector_clear(self)


    def swap(self, v: 'cvector') -> "void":
        """swap(cvector self, cvector v)"""
        return _sim2d.cvector_swap(self, v)


    def get_allocator(self) -> "std::vector< std::complex< double > >::allocator_type":
        """get_allocator(cvector self) -> std::vector< std::complex< double > >::allocator_type"""
        return _sim2d.cvector_get_allocator(self)


    def begin(self) -> "std::vector< std::complex< double > >::iterator":
        """begin(cvector self) -> std::vector< std::complex< double > >::iterator"""
        return _sim2d.cvector_begin(self)


    def end(self) -> "std::vector< std::complex< double > >::iterator":
        """end(cvector self) -> std::vector< std::complex< double > >::iterator"""
        return _sim2d.cvector_end(self)


    def rbegin(self) -> "std::vector< std::complex< double > >::reverse_iterator":
        """rbegin(cvector self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _sim2d.cvector_rbegin(self)


    def rend(self) -> "std::vector< std::complex< double > >::reverse_iterator":
        """rend(cvector self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _sim2d.cvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(cvector self)"""
        return _sim2d.cvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::complex< double > >::iterator":
        """
        erase(cvector self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(cvector self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _sim2d.cvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::complex<(double)>)> self) -> cvector
        __init__(std::vector<(std::complex<(double)>)> self, cvector arg2) -> cvector
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size) -> cvector
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> cvector
        """
        this = _sim2d.new_cvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< std::complex< double > >::value_type const &') -> "void":
        """push_back(cvector self, std::vector< std::complex< double > >::value_type const & x)"""
        return _sim2d.cvector_push_back(self, x)


    def front(self) -> "std::vector< std::complex< double > >::value_type const &":
        """front(cvector self) -> std::vector< std::complex< double > >::value_type const &"""
        return _sim2d.cvector_front(self)


    def back(self) -> "std::vector< std::complex< double > >::value_type const &":
        """back(cvector self) -> std::vector< std::complex< double > >::value_type const &"""
        return _sim2d.cvector_back(self)


    def assign(self, n: 'std::vector< std::complex< double > >::size_type', x: 'std::vector< std::complex< double > >::value_type const &') -> "void":
        """assign(cvector self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _sim2d.cvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(cvector self, std::vector< std::complex< double > >::size_type new_size)
        resize(cvector self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _sim2d.cvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(cvector self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(cvector self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _sim2d.cvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::complex< double > >::size_type') -> "void":
        """reserve(cvector self, std::vector< std::complex< double > >::size_type n)"""
        return _sim2d.cvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::complex< double > >::size_type":
        """capacity(cvector self) -> std::vector< std::complex< double > >::size_type"""
        return _sim2d.cvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_cvector
    __del__ = lambda self: None
cvector_swigregister = _sim2d.cvector_swigregister
cvector_swigregister(cvector)

class _ccvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::complex<(double)>)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ccvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ccvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_ccvector self) -> SwigPyIterator"""
        return _sim2d._ccvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_ccvector self) -> bool"""
        return _sim2d._ccvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_ccvector self) -> bool"""
        return _sim2d._ccvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        """__len__(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _sim2d._ccvector___len__(self)


    def pop(self) -> "std::vector< std::vector< std::complex< double > > >::value_type":
        """pop(_ccvector self) -> cvector"""
        return _sim2d._ccvector_pop(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::complex< double > > >::difference_type', j: 'std::vector< std::vector< std::complex< double > > >::difference_type') -> "std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > > *":
        """__getslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j) -> _ccvector"""
        return _sim2d._ccvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j, _ccvector v)
        __setslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j)
        """
        return _sim2d._ccvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::complex< double > > >::difference_type', j: 'std::vector< std::vector< std::complex< double > > >::difference_type') -> "void":
        """__delslice__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j)"""
        return _sim2d._ccvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i)
        __delitem__(_ccvector self, PySliceObject * slice)
        """
        return _sim2d._ccvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        """
        __getitem__(_ccvector self, PySliceObject * slice) -> _ccvector
        __getitem__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i) -> cvector
        """
        return _sim2d._ccvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_ccvector self, PySliceObject * slice, _ccvector v)
        __setitem__(_ccvector self, PySliceObject * slice)
        __setitem__(_ccvector self, std::vector< std::vector< std::complex< double > > >::difference_type i, cvector x)
        """
        return _sim2d._ccvector___setitem__(self, *args)


    def append(self, x: 'cvector') -> "void":
        """append(_ccvector self, cvector x)"""
        return _sim2d._ccvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_ccvector self) -> bool"""
        return _sim2d._ccvector_empty(self)


    def size(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        """size(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _sim2d._ccvector_size(self)


    def clear(self) -> "void":
        """clear(_ccvector self)"""
        return _sim2d._ccvector_clear(self)


    def swap(self, v: '_ccvector') -> "void":
        """swap(_ccvector self, _ccvector v)"""
        return _sim2d._ccvector_swap(self, v)


    def get_allocator(self) -> "std::vector< std::vector< std::complex< double > > >::allocator_type":
        """get_allocator(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::allocator_type"""
        return _sim2d._ccvector_get_allocator(self)


    def begin(self) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        """begin(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _sim2d._ccvector_begin(self)


    def end(self) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        """end(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _sim2d._ccvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::complex< double > > >::reverse_iterator":
        """rbegin(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _sim2d._ccvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::complex< double > > >::reverse_iterator":
        """rend(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _sim2d._ccvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(_ccvector self)"""
        return _sim2d._ccvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        """
        erase(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator pos) -> std::vector< std::vector< std::complex< double > > >::iterator
        erase(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator first, std::vector< std::vector< std::complex< double > > >::iterator last) -> std::vector< std::vector< std::complex< double > > >::iterator
        """
        return _sim2d._ccvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self) -> _ccvector
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, _ccvector arg2) -> _ccvector
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, std::vector< std::vector< std::complex< double > > >::size_type size) -> _ccvector
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, std::vector< std::vector< std::complex< double > > >::size_type size, cvector value) -> _ccvector
        """
        this = _sim2d.new__ccvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'cvector') -> "void":
        """push_back(_ccvector self, cvector x)"""
        return _sim2d._ccvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        """front(_ccvector self) -> cvector"""
        return _sim2d._ccvector_front(self)


    def back(self) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        """back(_ccvector self) -> cvector"""
        return _sim2d._ccvector_back(self)


    def assign(self, n: 'std::vector< std::vector< std::complex< double > > >::size_type', x: 'cvector') -> "void":
        """assign(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type n, cvector x)"""
        return _sim2d._ccvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type new_size)
        resize(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type new_size, cvector x)
        """
        return _sim2d._ccvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator pos, cvector x) -> std::vector< std::vector< std::complex< double > > >::iterator
        insert(_ccvector self, std::vector< std::vector< std::complex< double > > >::iterator pos, std::vector< std::vector< std::complex< double > > >::size_type n, cvector x)
        """
        return _sim2d._ccvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::complex< double > > >::size_type') -> "void":
        """reserve(_ccvector self, std::vector< std::vector< std::complex< double > > >::size_type n)"""
        return _sim2d._ccvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        """capacity(_ccvector self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _sim2d._ccvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__ccvector
    __del__ = lambda self: None
_ccvector_swigregister = _sim2d._ccvector_swigregister
_ccvector_swigregister(_ccvector)

class _cccvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cccvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _cccvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_cccvector self) -> SwigPyIterator"""
        return _sim2d._cccvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_cccvector self) -> bool"""
        return _sim2d._cccvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_cccvector self) -> bool"""
        return _sim2d._cccvector___bool__(self)


    def __len__(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::size_type":
        """__len__(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::size_type"""
        return _sim2d._cccvector___len__(self)


    def pop(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type":
        """pop(_cccvector self) -> _ccvector"""
        return _sim2d._cccvector_pop(self)


    def __getslice__(self, i: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type', j: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type') -> "std::vector< std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > >,std::allocator< std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > > > > *":
        """__getslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j) -> _cccvector"""
        return _sim2d._cccvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j, _cccvector v)
        __setslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j)
        """
        return _sim2d._cccvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type', j: 'std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type') -> "void":
        """__delslice__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type j)"""
        return _sim2d._cccvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i)
        __delitem__(_cccvector self, PySliceObject * slice)
        """
        return _sim2d._cccvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type const &":
        """
        __getitem__(_cccvector self, PySliceObject * slice) -> _cccvector
        __getitem__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i) -> _ccvector
        """
        return _sim2d._cccvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(_cccvector self, PySliceObject * slice, _cccvector v)
        __setitem__(_cccvector self, PySliceObject * slice)
        __setitem__(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::difference_type i, _ccvector x)
        """
        return _sim2d._cccvector___setitem__(self, *args)


    def append(self, x: '_ccvector') -> "void":
        """append(_cccvector self, _ccvector x)"""
        return _sim2d._cccvector_append(self, x)


    def empty(self) -> "bool":
        """empty(_cccvector self) -> bool"""
        return _sim2d._cccvector_empty(self)


    def size(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::size_type":
        """size(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::size_type"""
        return _sim2d._cccvector_size(self)


    def clear(self) -> "void":
        """clear(_cccvector self)"""
        return _sim2d._cccvector_clear(self)


    def swap(self, v: '_cccvector') -> "void":
        """swap(_cccvector self, _cccvector v)"""
        return _sim2d._cccvector_swap(self, v)


    def get_allocator(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::allocator_type":
        """get_allocator(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::allocator_type"""
        return _sim2d._cccvector_get_allocator(self)


    def begin(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::iterator":
        """begin(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator"""
        return _sim2d._cccvector_begin(self)


    def end(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::iterator":
        """end(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator"""
        return _sim2d._cccvector_end(self)


    def rbegin(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator":
        """rbegin(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator"""
        return _sim2d._cccvector_rbegin(self)


    def rend(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator":
        """rend(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::reverse_iterator"""
        return _sim2d._cccvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(_cccvector self)"""
        return _sim2d._cccvector_pop_back(self)


    def erase(self, *args) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::iterator":
        """
        erase(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator pos) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator
        erase(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator first, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator last) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator
        """
        return _sim2d._cccvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self) -> _cccvector
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self, _cccvector arg2) -> _cccvector
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type size) -> _cccvector
        __init__(std::vector<(std::vector<(std::vector<(std::complex<(double)>)>)>)> self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type size, _ccvector value) -> _cccvector
        """
        this = _sim2d.new__cccvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: '_ccvector') -> "void":
        """push_back(_cccvector self, _ccvector x)"""
        return _sim2d._cccvector_push_back(self, x)


    def front(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type const &":
        """front(_cccvector self) -> _ccvector"""
        return _sim2d._cccvector_front(self)


    def back(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::value_type const &":
        """back(_cccvector self) -> _ccvector"""
        return _sim2d._cccvector_back(self)


    def assign(self, n: 'std::vector< std::vector< std::vector< std::complex< double > > > >::size_type', x: '_ccvector') -> "void":
        """assign(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type n, _ccvector x)"""
        return _sim2d._cccvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type new_size)
        resize(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type new_size, _ccvector x)
        """
        return _sim2d._cccvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator pos, _ccvector x) -> std::vector< std::vector< std::vector< std::complex< double > > > >::iterator
        insert(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::iterator pos, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type n, _ccvector x)
        """
        return _sim2d._cccvector_insert(self, *args)


    def reserve(self, n: 'std::vector< std::vector< std::vector< std::complex< double > > > >::size_type') -> "void":
        """reserve(_cccvector self, std::vector< std::vector< std::vector< std::complex< double > > > >::size_type n)"""
        return _sim2d._cccvector_reserve(self, n)


    def capacity(self) -> "std::vector< std::vector< std::vector< std::complex< double > > > >::size_type":
        """capacity(_cccvector self) -> std::vector< std::vector< std::vector< std::complex< double > > > >::size_type"""
        return _sim2d._cccvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__cccvector
    __del__ = lambda self: None
_cccvector_swigregister = _sim2d._cccvector_swigregister
_cccvector_swigregister(_cccvector)

class ldvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(long double)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ldvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ldvector self) -> SwigPyIterator"""
        return _sim2d.ldvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ldvector self) -> bool"""
        return _sim2d.ldvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ldvector self) -> bool"""
        return _sim2d.ldvector___bool__(self)


    def __len__(self) -> "std::vector< long double >::size_type":
        """__len__(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2d.ldvector___len__(self)


    def pop(self) -> "std::vector< long double >::value_type":
        """pop(ldvector self) -> std::vector< long double >::value_type"""
        return _sim2d.ldvector_pop(self)


    def __getslice__(self, i: 'std::vector< long double >::difference_type', j: 'std::vector< long double >::difference_type') -> "std::vector< long double,std::allocator< long double > > *":
        """__getslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j) -> ldvector"""
        return _sim2d.ldvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j, ldvector v)
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)
        """
        return _sim2d.ldvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< long double >::difference_type', j: 'std::vector< long double >::difference_type') -> "void":
        """__delslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)"""
        return _sim2d.ldvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ldvector self, std::vector< long double >::difference_type i)
        __delitem__(ldvector self, PySliceObject * slice)
        """
        return _sim2d.ldvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< long double >::value_type const &":
        """
        __getitem__(ldvector self, PySliceObject * slice) -> ldvector
        __getitem__(ldvector self, std::vector< long double >::difference_type i) -> std::vector< long double >::value_type const &
        """
        return _sim2d.ldvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ldvector self, PySliceObject * slice, ldvector v)
        __setitem__(ldvector self, PySliceObject * slice)
        __setitem__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::value_type const & x)
        """
        return _sim2d.ldvector___setitem__(self, *args)


    def append(self, x: 'std::vector< long double >::value_type const &') -> "void":
        """append(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim2d.ldvector_append(self, x)


    def empty(self) -> "bool":
        """empty(ldvector self) -> bool"""
        return _sim2d.ldvector_empty(self)


    def size(self) -> "std::vector< long double >::size_type":
        """size(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2d.ldvector_size(self)


    def clear(self) -> "void":
        """clear(ldvector self)"""
        return _sim2d.ldvector_clear(self)


    def swap(self, v: 'ldvector') -> "void":
        """swap(ldvector self, ldvector v)"""
        return _sim2d.ldvector_swap(self, v)


    def get_allocator(self) -> "std::vector< long double >::allocator_type":
        """get_allocator(ldvector self) -> std::vector< long double >::allocator_type"""
        return _sim2d.ldvector_get_allocator(self)


    def begin(self) -> "std::vector< long double >::iterator":
        """begin(ldvector self) -> std::vector< long double >::iterator"""
        return _sim2d.ldvector_begin(self)


    def end(self) -> "std::vector< long double >::iterator":
        """end(ldvector self) -> std::vector< long double >::iterator"""
        return _sim2d.ldvector_end(self)


    def rbegin(self) -> "std::vector< long double >::reverse_iterator":
        """rbegin(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim2d.ldvector_rbegin(self)


    def rend(self) -> "std::vector< long double >::reverse_iterator":
        """rend(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim2d.ldvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(ldvector self)"""
        return _sim2d.ldvector_pop_back(self)


    def erase(self, *args) -> "std::vector< long double >::iterator":
        """
        erase(ldvector self, std::vector< long double >::iterator pos) -> std::vector< long double >::iterator
        erase(ldvector self, std::vector< long double >::iterator first, std::vector< long double >::iterator last) -> std::vector< long double >::iterator
        """
        return _sim2d.ldvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(long double)> self) -> ldvector
        __init__(std::vector<(long double)> self, ldvector arg2) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size, std::vector< long double >::value_type const & value) -> ldvector
        """
        this = _sim2d.new_ldvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< long double >::value_type const &') -> "void":
        """push_back(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim2d.ldvector_push_back(self, x)


    def front(self) -> "std::vector< long double >::value_type const &":
        """front(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim2d.ldvector_front(self)


    def back(self) -> "std::vector< long double >::value_type const &":
        """back(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim2d.ldvector_back(self)


    def assign(self, n: 'std::vector< long double >::size_type', x: 'std::vector< long double >::value_type const &') -> "void":
        """assign(ldvector self, std::vector< long double >::size_type n, std::vector< long double >::value_type const & x)"""
        return _sim2d.ldvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ldvector self, std::vector< long double >::size_type new_size)
        resize(ldvector self, std::vector< long double >::size_type new_size, std::vector< long double >::value_type const & x)
        """
        return _sim2d.ldvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::value_type const & x) -> std::vector< long double >::iterator
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::size_type n, std::vector< long double >::value_type const & x)
        """
        return _sim2d.ldvector_insert(self, *args)


    def reserve(self, n: 'std::vector< long double >::size_type') -> "void":
        """reserve(ldvector self, std::vector< long double >::size_type n)"""
        return _sim2d.ldvector_reserve(self, n)


    def capacity(self) -> "std::vector< long double >::size_type":
        """capacity(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2d.ldvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ldvector
    __del__ = lambda self: None
ldvector_swigregister = _sim2d.ldvector_swigregister
ldvector_swigregister(ldvector)

class ivector(collections.MutableSequence):
    """Proxy of C++ std::vector<(shared_ptr<(interaction)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ivector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ivector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ivector self) -> SwigPyIterator"""
        return _sim2d.ivector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ivector self) -> bool"""
        return _sim2d.ivector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ivector self) -> bool"""
        return _sim2d.ivector___bool__(self)


    def __len__(self) -> "std::vector< shared_ptr< interaction > >::size_type":
        """__len__(ivector self) -> std::vector< shared_ptr< interaction > >::size_type"""
        return _sim2d.ivector___len__(self)


    def pop(self) -> "std::vector< shared_ptr< interaction > >::value_type":
        """pop(ivector self) -> std::vector< shared_ptr< interaction > >::value_type"""
        return _sim2d.ivector_pop(self)


    def __getslice__(self, i: 'std::vector< shared_ptr< interaction > >::difference_type', j: 'std::vector< shared_ptr< interaction > >::difference_type') -> "std::vector< boost::shared_ptr< interaction >,std::allocator< boost::shared_ptr< interaction > > > *":
        """__getslice__(ivector self, std::vector< shared_ptr< interaction > >::difference_type i, std::vector< shared_ptr< interaction > >::difference_type j) -> std::vector< boost::shared_ptr< interaction >,std::allocator< boost::shared_ptr< interaction > > > *"""
        return _sim2d.ivector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ivector self, std::vector< shared_ptr< interaction > >::difference_type i, std::vector< shared_ptr< interaction > >::difference_type j, std::vector< boost::shared_ptr< interaction >,std::allocator< boost::shared_ptr< interaction > > > const & v)
        __setslice__(ivector self, std::vector< shared_ptr< interaction > >::difference_type i, std::vector< shared_ptr< interaction > >::difference_type j)
        """
        return _sim2d.ivector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< shared_ptr< interaction > >::difference_type', j: 'std::vector< shared_ptr< interaction > >::difference_type') -> "void":
        """__delslice__(ivector self, std::vector< shared_ptr< interaction > >::difference_type i, std::vector< shared_ptr< interaction > >::difference_type j)"""
        return _sim2d.ivector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ivector self, std::vector< shared_ptr< interaction > >::difference_type i)
        __delitem__(ivector self, PySliceObject * slice)
        """
        return _sim2d.ivector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< shared_ptr< interaction > >::value_type const &":
        """
        __getitem__(ivector self, PySliceObject * slice) -> std::vector< boost::shared_ptr< interaction >,std::allocator< boost::shared_ptr< interaction > > >
        __getitem__(ivector self, std::vector< shared_ptr< interaction > >::difference_type i) -> std::vector< shared_ptr< interaction > >::value_type const &
        """
        return _sim2d.ivector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ivector self, PySliceObject * slice, std::vector< boost::shared_ptr< interaction >,std::allocator< boost::shared_ptr< interaction > > > const & v)
        __setitem__(ivector self, PySliceObject * slice)
        __setitem__(ivector self, std::vector< shared_ptr< interaction > >::difference_type i, std::vector< shared_ptr< interaction > >::value_type const & x)
        """
        return _sim2d.ivector___setitem__(self, *args)


    def append(self, x: 'std::vector< shared_ptr< interaction > >::value_type const &') -> "void":
        """append(ivector self, std::vector< shared_ptr< interaction > >::value_type const & x)"""
        return _sim2d.ivector_append(self, x)


    def empty(self) -> "bool":
        """empty(ivector self) -> bool"""
        return _sim2d.ivector_empty(self)


    def size(self) -> "std::vector< shared_ptr< interaction > >::size_type":
        """size(ivector self) -> std::vector< shared_ptr< interaction > >::size_type"""
        return _sim2d.ivector_size(self)


    def clear(self) -> "void":
        """clear(ivector self)"""
        return _sim2d.ivector_clear(self)


    def swap(self, v: 'ivector') -> "void":
        """swap(ivector self, ivector v)"""
        return _sim2d.ivector_swap(self, v)


    def get_allocator(self) -> "std::vector< shared_ptr< interaction > >::allocator_type":
        """get_allocator(ivector self) -> std::vector< shared_ptr< interaction > >::allocator_type"""
        return _sim2d.ivector_get_allocator(self)


    def begin(self) -> "std::vector< shared_ptr< interaction > >::iterator":
        """begin(ivector self) -> std::vector< shared_ptr< interaction > >::iterator"""
        return _sim2d.ivector_begin(self)


    def end(self) -> "std::vector< shared_ptr< interaction > >::iterator":
        """end(ivector self) -> std::vector< shared_ptr< interaction > >::iterator"""
        return _sim2d.ivector_end(self)


    def rbegin(self) -> "std::vector< shared_ptr< interaction > >::reverse_iterator":
        """rbegin(ivector self) -> std::vector< shared_ptr< interaction > >::reverse_iterator"""
        return _sim2d.ivector_rbegin(self)


    def rend(self) -> "std::vector< shared_ptr< interaction > >::reverse_iterator":
        """rend(ivector self) -> std::vector< shared_ptr< interaction > >::reverse_iterator"""
        return _sim2d.ivector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(ivector self)"""
        return _sim2d.ivector_pop_back(self)


    def erase(self, *args) -> "std::vector< shared_ptr< interaction > >::iterator":
        """
        erase(ivector self, std::vector< shared_ptr< interaction > >::iterator pos) -> std::vector< shared_ptr< interaction > >::iterator
        erase(ivector self, std::vector< shared_ptr< interaction > >::iterator first, std::vector< shared_ptr< interaction > >::iterator last) -> std::vector< shared_ptr< interaction > >::iterator
        """
        return _sim2d.ivector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(shared_ptr<(interaction)>)> self) -> ivector
        __init__(std::vector<(shared_ptr<(interaction)>)> self, ivector arg2) -> ivector
        __init__(std::vector<(shared_ptr<(interaction)>)> self, std::vector< shared_ptr< interaction > >::size_type size) -> ivector
        __init__(std::vector<(shared_ptr<(interaction)>)> self, std::vector< shared_ptr< interaction > >::size_type size, std::vector< shared_ptr< interaction > >::value_type const & value) -> ivector
        """
        this = _sim2d.new_ivector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< shared_ptr< interaction > >::value_type const &') -> "void":
        """push_back(ivector self, std::vector< shared_ptr< interaction > >::value_type const & x)"""
        return _sim2d.ivector_push_back(self, x)


    def front(self) -> "std::vector< shared_ptr< interaction > >::value_type const &":
        """front(ivector self) -> std::vector< shared_ptr< interaction > >::value_type const &"""
        return _sim2d.ivector_front(self)


    def back(self) -> "std::vector< shared_ptr< interaction > >::value_type const &":
        """back(ivector self) -> std::vector< shared_ptr< interaction > >::value_type const &"""
        return _sim2d.ivector_back(self)


    def assign(self, n: 'std::vector< shared_ptr< interaction > >::size_type', x: 'std::vector< shared_ptr< interaction > >::value_type const &') -> "void":
        """assign(ivector self, std::vector< shared_ptr< interaction > >::size_type n, std::vector< shared_ptr< interaction > >::value_type const & x)"""
        return _sim2d.ivector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ivector self, std::vector< shared_ptr< interaction > >::size_type new_size)
        resize(ivector self, std::vector< shared_ptr< interaction > >::size_type new_size, std::vector< shared_ptr< interaction > >::value_type const & x)
        """
        return _sim2d.ivector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ivector self, std::vector< shared_ptr< interaction > >::iterator pos, std::vector< shared_ptr< interaction > >::value_type const & x) -> std::vector< shared_ptr< interaction > >::iterator
        insert(ivector self, std::vector< shared_ptr< interaction > >::iterator pos, std::vector< shared_ptr< interaction > >::size_type n, std::vector< shared_ptr< interaction > >::value_type const & x)
        """
        return _sim2d.ivector_insert(self, *args)


    def reserve(self, n: 'std::vector< shared_ptr< interaction > >::size_type') -> "void":
        """reserve(ivector self, std::vector< shared_ptr< interaction > >::size_type n)"""
        return _sim2d.ivector_reserve(self, n)


    def capacity(self) -> "std::vector< shared_ptr< interaction > >::size_type":
        """capacity(ivector self) -> std::vector< shared_ptr< interaction > >::size_type"""
        return _sim2d.ivector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ivector
    __del__ = lambda self: None
ivector_swigregister = _sim2d.ivector_swigregister
ivector_swigregister(ivector)

class ifxvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(shared_ptr<(interactionpairsx)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ifxvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ifxvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ifxvector self) -> SwigPyIterator"""
        return _sim2d.ifxvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ifxvector self) -> bool"""
        return _sim2d.ifxvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ifxvector self) -> bool"""
        return _sim2d.ifxvector___bool__(self)


    def __len__(self) -> "std::vector< shared_ptr< interactionpairsx > >::size_type":
        """__len__(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::size_type"""
        return _sim2d.ifxvector___len__(self)


    def pop(self) -> "std::vector< shared_ptr< interactionpairsx > >::value_type":
        """pop(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::value_type"""
        return _sim2d.ifxvector_pop(self)


    def __getslice__(self, i: 'std::vector< shared_ptr< interactionpairsx > >::difference_type', j: 'std::vector< shared_ptr< interactionpairsx > >::difference_type') -> "std::vector< boost::shared_ptr< interactionpairsx >,std::allocator< boost::shared_ptr< interactionpairsx > > > *":
        """__getslice__(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::difference_type i, std::vector< shared_ptr< interactionpairsx > >::difference_type j) -> std::vector< boost::shared_ptr< interactionpairsx >,std::allocator< boost::shared_ptr< interactionpairsx > > > *"""
        return _sim2d.ifxvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::difference_type i, std::vector< shared_ptr< interactionpairsx > >::difference_type j, std::vector< boost::shared_ptr< interactionpairsx >,std::allocator< boost::shared_ptr< interactionpairsx > > > const & v)
        __setslice__(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::difference_type i, std::vector< shared_ptr< interactionpairsx > >::difference_type j)
        """
        return _sim2d.ifxvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< shared_ptr< interactionpairsx > >::difference_type', j: 'std::vector< shared_ptr< interactionpairsx > >::difference_type') -> "void":
        """__delslice__(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::difference_type i, std::vector< shared_ptr< interactionpairsx > >::difference_type j)"""
        return _sim2d.ifxvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::difference_type i)
        __delitem__(ifxvector self, PySliceObject * slice)
        """
        return _sim2d.ifxvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< shared_ptr< interactionpairsx > >::value_type const &":
        """
        __getitem__(ifxvector self, PySliceObject * slice) -> std::vector< boost::shared_ptr< interactionpairsx >,std::allocator< boost::shared_ptr< interactionpairsx > > >
        __getitem__(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::difference_type i) -> std::vector< shared_ptr< interactionpairsx > >::value_type const &
        """
        return _sim2d.ifxvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ifxvector self, PySliceObject * slice, std::vector< boost::shared_ptr< interactionpairsx >,std::allocator< boost::shared_ptr< interactionpairsx > > > const & v)
        __setitem__(ifxvector self, PySliceObject * slice)
        __setitem__(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::difference_type i, std::vector< shared_ptr< interactionpairsx > >::value_type const & x)
        """
        return _sim2d.ifxvector___setitem__(self, *args)


    def append(self, x: 'std::vector< shared_ptr< interactionpairsx > >::value_type const &') -> "void":
        """append(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::value_type const & x)"""
        return _sim2d.ifxvector_append(self, x)


    def empty(self) -> "bool":
        """empty(ifxvector self) -> bool"""
        return _sim2d.ifxvector_empty(self)


    def size(self) -> "std::vector< shared_ptr< interactionpairsx > >::size_type":
        """size(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::size_type"""
        return _sim2d.ifxvector_size(self)


    def clear(self) -> "void":
        """clear(ifxvector self)"""
        return _sim2d.ifxvector_clear(self)


    def swap(self, v: 'ifxvector') -> "void":
        """swap(ifxvector self, ifxvector v)"""
        return _sim2d.ifxvector_swap(self, v)


    def get_allocator(self) -> "std::vector< shared_ptr< interactionpairsx > >::allocator_type":
        """get_allocator(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::allocator_type"""
        return _sim2d.ifxvector_get_allocator(self)


    def begin(self) -> "std::vector< shared_ptr< interactionpairsx > >::iterator":
        """begin(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::iterator"""
        return _sim2d.ifxvector_begin(self)


    def end(self) -> "std::vector< shared_ptr< interactionpairsx > >::iterator":
        """end(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::iterator"""
        return _sim2d.ifxvector_end(self)


    def rbegin(self) -> "std::vector< shared_ptr< interactionpairsx > >::reverse_iterator":
        """rbegin(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::reverse_iterator"""
        return _sim2d.ifxvector_rbegin(self)


    def rend(self) -> "std::vector< shared_ptr< interactionpairsx > >::reverse_iterator":
        """rend(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::reverse_iterator"""
        return _sim2d.ifxvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(ifxvector self)"""
        return _sim2d.ifxvector_pop_back(self)


    def erase(self, *args) -> "std::vector< shared_ptr< interactionpairsx > >::iterator":
        """
        erase(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::iterator pos) -> std::vector< shared_ptr< interactionpairsx > >::iterator
        erase(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::iterator first, std::vector< shared_ptr< interactionpairsx > >::iterator last) -> std::vector< shared_ptr< interactionpairsx > >::iterator
        """
        return _sim2d.ifxvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(shared_ptr<(interactionpairsx)>)> self) -> ifxvector
        __init__(std::vector<(shared_ptr<(interactionpairsx)>)> self, ifxvector arg2) -> ifxvector
        __init__(std::vector<(shared_ptr<(interactionpairsx)>)> self, std::vector< shared_ptr< interactionpairsx > >::size_type size) -> ifxvector
        __init__(std::vector<(shared_ptr<(interactionpairsx)>)> self, std::vector< shared_ptr< interactionpairsx > >::size_type size, std::vector< shared_ptr< interactionpairsx > >::value_type const & value) -> ifxvector
        """
        this = _sim2d.new_ifxvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< shared_ptr< interactionpairsx > >::value_type const &') -> "void":
        """push_back(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::value_type const & x)"""
        return _sim2d.ifxvector_push_back(self, x)


    def front(self) -> "std::vector< shared_ptr< interactionpairsx > >::value_type const &":
        """front(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::value_type const &"""
        return _sim2d.ifxvector_front(self)


    def back(self) -> "std::vector< shared_ptr< interactionpairsx > >::value_type const &":
        """back(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::value_type const &"""
        return _sim2d.ifxvector_back(self)


    def assign(self, n: 'std::vector< shared_ptr< interactionpairsx > >::size_type', x: 'std::vector< shared_ptr< interactionpairsx > >::value_type const &') -> "void":
        """assign(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::size_type n, std::vector< shared_ptr< interactionpairsx > >::value_type const & x)"""
        return _sim2d.ifxvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::size_type new_size)
        resize(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::size_type new_size, std::vector< shared_ptr< interactionpairsx > >::value_type const & x)
        """
        return _sim2d.ifxvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::iterator pos, std::vector< shared_ptr< interactionpairsx > >::value_type const & x) -> std::vector< shared_ptr< interactionpairsx > >::iterator
        insert(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::iterator pos, std::vector< shared_ptr< interactionpairsx > >::size_type n, std::vector< shared_ptr< interactionpairsx > >::value_type const & x)
        """
        return _sim2d.ifxvector_insert(self, *args)


    def reserve(self, n: 'std::vector< shared_ptr< interactionpairsx > >::size_type') -> "void":
        """reserve(ifxvector self, std::vector< shared_ptr< interactionpairsx > >::size_type n)"""
        return _sim2d.ifxvector_reserve(self, n)


    def capacity(self) -> "std::vector< shared_ptr< interactionpairsx > >::size_type":
        """capacity(ifxvector self) -> std::vector< shared_ptr< interactionpairsx > >::size_type"""
        return _sim2d.ifxvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ifxvector
    __del__ = lambda self: None
ifxvector_swigregister = _sim2d.ifxvector_swigregister
ifxvector_swigregister(ifxvector)

class tvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(shared_ptr<(statetracker)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, tvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(tvector self) -> SwigPyIterator"""
        return _sim2d.tvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(tvector self) -> bool"""
        return _sim2d.tvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(tvector self) -> bool"""
        return _sim2d.tvector___bool__(self)


    def __len__(self) -> "std::vector< shared_ptr< statetracker > >::size_type":
        """__len__(tvector self) -> std::vector< shared_ptr< statetracker > >::size_type"""
        return _sim2d.tvector___len__(self)


    def pop(self) -> "std::vector< shared_ptr< statetracker > >::value_type":
        """pop(tvector self) -> std::vector< shared_ptr< statetracker > >::value_type"""
        return _sim2d.tvector_pop(self)


    def __getslice__(self, i: 'std::vector< shared_ptr< statetracker > >::difference_type', j: 'std::vector< shared_ptr< statetracker > >::difference_type') -> "std::vector< boost::shared_ptr< statetracker >,std::allocator< boost::shared_ptr< statetracker > > > *":
        """__getslice__(tvector self, std::vector< shared_ptr< statetracker > >::difference_type i, std::vector< shared_ptr< statetracker > >::difference_type j) -> std::vector< boost::shared_ptr< statetracker >,std::allocator< boost::shared_ptr< statetracker > > > *"""
        return _sim2d.tvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(tvector self, std::vector< shared_ptr< statetracker > >::difference_type i, std::vector< shared_ptr< statetracker > >::difference_type j, std::vector< boost::shared_ptr< statetracker >,std::allocator< boost::shared_ptr< statetracker > > > const & v)
        __setslice__(tvector self, std::vector< shared_ptr< statetracker > >::difference_type i, std::vector< shared_ptr< statetracker > >::difference_type j)
        """
        return _sim2d.tvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< shared_ptr< statetracker > >::difference_type', j: 'std::vector< shared_ptr< statetracker > >::difference_type') -> "void":
        """__delslice__(tvector self, std::vector< shared_ptr< statetracker > >::difference_type i, std::vector< shared_ptr< statetracker > >::difference_type j)"""
        return _sim2d.tvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(tvector self, std::vector< shared_ptr< statetracker > >::difference_type i)
        __delitem__(tvector self, PySliceObject * slice)
        """
        return _sim2d.tvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< shared_ptr< statetracker > >::value_type const &":
        """
        __getitem__(tvector self, PySliceObject * slice) -> std::vector< boost::shared_ptr< statetracker >,std::allocator< boost::shared_ptr< statetracker > > >
        __getitem__(tvector self, std::vector< shared_ptr< statetracker > >::difference_type i) -> std::vector< shared_ptr< statetracker > >::value_type const &
        """
        return _sim2d.tvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(tvector self, PySliceObject * slice, std::vector< boost::shared_ptr< statetracker >,std::allocator< boost::shared_ptr< statetracker > > > const & v)
        __setitem__(tvector self, PySliceObject * slice)
        __setitem__(tvector self, std::vector< shared_ptr< statetracker > >::difference_type i, std::vector< shared_ptr< statetracker > >::value_type const & x)
        """
        return _sim2d.tvector___setitem__(self, *args)


    def append(self, x: 'std::vector< shared_ptr< statetracker > >::value_type const &') -> "void":
        """append(tvector self, std::vector< shared_ptr< statetracker > >::value_type const & x)"""
        return _sim2d.tvector_append(self, x)


    def empty(self) -> "bool":
        """empty(tvector self) -> bool"""
        return _sim2d.tvector_empty(self)


    def size(self) -> "std::vector< shared_ptr< statetracker > >::size_type":
        """size(tvector self) -> std::vector< shared_ptr< statetracker > >::size_type"""
        return _sim2d.tvector_size(self)


    def clear(self) -> "void":
        """clear(tvector self)"""
        return _sim2d.tvector_clear(self)


    def swap(self, v: 'tvector') -> "void":
        """swap(tvector self, tvector v)"""
        return _sim2d.tvector_swap(self, v)


    def get_allocator(self) -> "std::vector< shared_ptr< statetracker > >::allocator_type":
        """get_allocator(tvector self) -> std::vector< shared_ptr< statetracker > >::allocator_type"""
        return _sim2d.tvector_get_allocator(self)


    def begin(self) -> "std::vector< shared_ptr< statetracker > >::iterator":
        """begin(tvector self) -> std::vector< shared_ptr< statetracker > >::iterator"""
        return _sim2d.tvector_begin(self)


    def end(self) -> "std::vector< shared_ptr< statetracker > >::iterator":
        """end(tvector self) -> std::vector< shared_ptr< statetracker > >::iterator"""
        return _sim2d.tvector_end(self)


    def rbegin(self) -> "std::vector< shared_ptr< statetracker > >::reverse_iterator":
        """rbegin(tvector self) -> std::vector< shared_ptr< statetracker > >::reverse_iterator"""
        return _sim2d.tvector_rbegin(self)


    def rend(self) -> "std::vector< shared_ptr< statetracker > >::reverse_iterator":
        """rend(tvector self) -> std::vector< shared_ptr< statetracker > >::reverse_iterator"""
        return _sim2d.tvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(tvector self)"""
        return _sim2d.tvector_pop_back(self)


    def erase(self, *args) -> "std::vector< shared_ptr< statetracker > >::iterator":
        """
        erase(tvector self, std::vector< shared_ptr< statetracker > >::iterator pos) -> std::vector< shared_ptr< statetracker > >::iterator
        erase(tvector self, std::vector< shared_ptr< statetracker > >::iterator first, std::vector< shared_ptr< statetracker > >::iterator last) -> std::vector< shared_ptr< statetracker > >::iterator
        """
        return _sim2d.tvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(shared_ptr<(statetracker)>)> self) -> tvector
        __init__(std::vector<(shared_ptr<(statetracker)>)> self, tvector arg2) -> tvector
        __init__(std::vector<(shared_ptr<(statetracker)>)> self, std::vector< shared_ptr< statetracker > >::size_type size) -> tvector
        __init__(std::vector<(shared_ptr<(statetracker)>)> self, std::vector< shared_ptr< statetracker > >::size_type size, std::vector< shared_ptr< statetracker > >::value_type const & value) -> tvector
        """
        this = _sim2d.new_tvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< shared_ptr< statetracker > >::value_type const &') -> "void":
        """push_back(tvector self, std::vector< shared_ptr< statetracker > >::value_type const & x)"""
        return _sim2d.tvector_push_back(self, x)


    def front(self) -> "std::vector< shared_ptr< statetracker > >::value_type const &":
        """front(tvector self) -> std::vector< shared_ptr< statetracker > >::value_type const &"""
        return _sim2d.tvector_front(self)


    def back(self) -> "std::vector< shared_ptr< statetracker > >::value_type const &":
        """back(tvector self) -> std::vector< shared_ptr< statetracker > >::value_type const &"""
        return _sim2d.tvector_back(self)


    def assign(self, n: 'std::vector< shared_ptr< statetracker > >::size_type', x: 'std::vector< shared_ptr< statetracker > >::value_type const &') -> "void":
        """assign(tvector self, std::vector< shared_ptr< statetracker > >::size_type n, std::vector< shared_ptr< statetracker > >::value_type const & x)"""
        return _sim2d.tvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(tvector self, std::vector< shared_ptr< statetracker > >::size_type new_size)
        resize(tvector self, std::vector< shared_ptr< statetracker > >::size_type new_size, std::vector< shared_ptr< statetracker > >::value_type const & x)
        """
        return _sim2d.tvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(tvector self, std::vector< shared_ptr< statetracker > >::iterator pos, std::vector< shared_ptr< statetracker > >::value_type const & x) -> std::vector< shared_ptr< statetracker > >::iterator
        insert(tvector self, std::vector< shared_ptr< statetracker > >::iterator pos, std::vector< shared_ptr< statetracker > >::size_type n, std::vector< shared_ptr< statetracker > >::value_type const & x)
        """
        return _sim2d.tvector_insert(self, *args)


    def reserve(self, n: 'std::vector< shared_ptr< statetracker > >::size_type') -> "void":
        """reserve(tvector self, std::vector< shared_ptr< statetracker > >::size_type n)"""
        return _sim2d.tvector_reserve(self, n)


    def capacity(self) -> "std::vector< shared_ptr< statetracker > >::size_type":
        """capacity(tvector self) -> std::vector< shared_ptr< statetracker > >::size_type"""
        return _sim2d.tvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_tvector
    __del__ = lambda self: None
tvector_swigregister = _sim2d.tvector_swigregister
tvector_swigregister(tvector)

class constraintvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(shared_ptr<(constraint)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraintvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, constraintvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(constraintvector self) -> SwigPyIterator"""
        return _sim2d.constraintvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(constraintvector self) -> bool"""
        return _sim2d.constraintvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(constraintvector self) -> bool"""
        return _sim2d.constraintvector___bool__(self)


    def __len__(self) -> "std::vector< shared_ptr< constraint > >::size_type":
        """__len__(constraintvector self) -> std::vector< shared_ptr< constraint > >::size_type"""
        return _sim2d.constraintvector___len__(self)


    def pop(self) -> "std::vector< shared_ptr< constraint > >::value_type":
        """pop(constraintvector self) -> std::vector< shared_ptr< constraint > >::value_type"""
        return _sim2d.constraintvector_pop(self)


    def __getslice__(self, i: 'std::vector< shared_ptr< constraint > >::difference_type', j: 'std::vector< shared_ptr< constraint > >::difference_type') -> "std::vector< boost::shared_ptr< constraint >,std::allocator< boost::shared_ptr< constraint > > > *":
        """__getslice__(constraintvector self, std::vector< shared_ptr< constraint > >::difference_type i, std::vector< shared_ptr< constraint > >::difference_type j) -> std::vector< boost::shared_ptr< constraint >,std::allocator< boost::shared_ptr< constraint > > > *"""
        return _sim2d.constraintvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(constraintvector self, std::vector< shared_ptr< constraint > >::difference_type i, std::vector< shared_ptr< constraint > >::difference_type j, std::vector< boost::shared_ptr< constraint >,std::allocator< boost::shared_ptr< constraint > > > const & v)
        __setslice__(constraintvector self, std::vector< shared_ptr< constraint > >::difference_type i, std::vector< shared_ptr< constraint > >::difference_type j)
        """
        return _sim2d.constraintvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< shared_ptr< constraint > >::difference_type', j: 'std::vector< shared_ptr< constraint > >::difference_type') -> "void":
        """__delslice__(constraintvector self, std::vector< shared_ptr< constraint > >::difference_type i, std::vector< shared_ptr< constraint > >::difference_type j)"""
        return _sim2d.constraintvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(constraintvector self, std::vector< shared_ptr< constraint > >::difference_type i)
        __delitem__(constraintvector self, PySliceObject * slice)
        """
        return _sim2d.constraintvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< shared_ptr< constraint > >::value_type const &":
        """
        __getitem__(constraintvector self, PySliceObject * slice) -> std::vector< boost::shared_ptr< constraint >,std::allocator< boost::shared_ptr< constraint > > >
        __getitem__(constraintvector self, std::vector< shared_ptr< constraint > >::difference_type i) -> std::vector< shared_ptr< constraint > >::value_type const &
        """
        return _sim2d.constraintvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(constraintvector self, PySliceObject * slice, std::vector< boost::shared_ptr< constraint >,std::allocator< boost::shared_ptr< constraint > > > const & v)
        __setitem__(constraintvector self, PySliceObject * slice)
        __setitem__(constraintvector self, std::vector< shared_ptr< constraint > >::difference_type i, std::vector< shared_ptr< constraint > >::value_type const & x)
        """
        return _sim2d.constraintvector___setitem__(self, *args)


    def append(self, x: 'std::vector< shared_ptr< constraint > >::value_type const &') -> "void":
        """append(constraintvector self, std::vector< shared_ptr< constraint > >::value_type const & x)"""
        return _sim2d.constraintvector_append(self, x)


    def empty(self) -> "bool":
        """empty(constraintvector self) -> bool"""
        return _sim2d.constraintvector_empty(self)


    def size(self) -> "std::vector< shared_ptr< constraint > >::size_type":
        """size(constraintvector self) -> std::vector< shared_ptr< constraint > >::size_type"""
        return _sim2d.constraintvector_size(self)


    def clear(self) -> "void":
        """clear(constraintvector self)"""
        return _sim2d.constraintvector_clear(self)


    def swap(self, v: 'constraintvector') -> "void":
        """swap(constraintvector self, constraintvector v)"""
        return _sim2d.constraintvector_swap(self, v)


    def get_allocator(self) -> "std::vector< shared_ptr< constraint > >::allocator_type":
        """get_allocator(constraintvector self) -> std::vector< shared_ptr< constraint > >::allocator_type"""
        return _sim2d.constraintvector_get_allocator(self)


    def begin(self) -> "std::vector< shared_ptr< constraint > >::iterator":
        """begin(constraintvector self) -> std::vector< shared_ptr< constraint > >::iterator"""
        return _sim2d.constraintvector_begin(self)


    def end(self) -> "std::vector< shared_ptr< constraint > >::iterator":
        """end(constraintvector self) -> std::vector< shared_ptr< constraint > >::iterator"""
        return _sim2d.constraintvector_end(self)


    def rbegin(self) -> "std::vector< shared_ptr< constraint > >::reverse_iterator":
        """rbegin(constraintvector self) -> std::vector< shared_ptr< constraint > >::reverse_iterator"""
        return _sim2d.constraintvector_rbegin(self)


    def rend(self) -> "std::vector< shared_ptr< constraint > >::reverse_iterator":
        """rend(constraintvector self) -> std::vector< shared_ptr< constraint > >::reverse_iterator"""
        return _sim2d.constraintvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(constraintvector self)"""
        return _sim2d.constraintvector_pop_back(self)


    def erase(self, *args) -> "std::vector< shared_ptr< constraint > >::iterator":
        """
        erase(constraintvector self, std::vector< shared_ptr< constraint > >::iterator pos) -> std::vector< shared_ptr< constraint > >::iterator
        erase(constraintvector self, std::vector< shared_ptr< constraint > >::iterator first, std::vector< shared_ptr< constraint > >::iterator last) -> std::vector< shared_ptr< constraint > >::iterator
        """
        return _sim2d.constraintvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(shared_ptr<(constraint)>)> self) -> constraintvector
        __init__(std::vector<(shared_ptr<(constraint)>)> self, constraintvector arg2) -> constraintvector
        __init__(std::vector<(shared_ptr<(constraint)>)> self, std::vector< shared_ptr< constraint > >::size_type size) -> constraintvector
        __init__(std::vector<(shared_ptr<(constraint)>)> self, std::vector< shared_ptr< constraint > >::size_type size, std::vector< shared_ptr< constraint > >::value_type const & value) -> constraintvector
        """
        this = _sim2d.new_constraintvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< shared_ptr< constraint > >::value_type const &') -> "void":
        """push_back(constraintvector self, std::vector< shared_ptr< constraint > >::value_type const & x)"""
        return _sim2d.constraintvector_push_back(self, x)


    def front(self) -> "std::vector< shared_ptr< constraint > >::value_type const &":
        """front(constraintvector self) -> std::vector< shared_ptr< constraint > >::value_type const &"""
        return _sim2d.constraintvector_front(self)


    def back(self) -> "std::vector< shared_ptr< constraint > >::value_type const &":
        """back(constraintvector self) -> std::vector< shared_ptr< constraint > >::value_type const &"""
        return _sim2d.constraintvector_back(self)


    def assign(self, n: 'std::vector< shared_ptr< constraint > >::size_type', x: 'std::vector< shared_ptr< constraint > >::value_type const &') -> "void":
        """assign(constraintvector self, std::vector< shared_ptr< constraint > >::size_type n, std::vector< shared_ptr< constraint > >::value_type const & x)"""
        return _sim2d.constraintvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(constraintvector self, std::vector< shared_ptr< constraint > >::size_type new_size)
        resize(constraintvector self, std::vector< shared_ptr< constraint > >::size_type new_size, std::vector< shared_ptr< constraint > >::value_type const & x)
        """
        return _sim2d.constraintvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(constraintvector self, std::vector< shared_ptr< constraint > >::iterator pos, std::vector< shared_ptr< constraint > >::value_type const & x) -> std::vector< shared_ptr< constraint > >::iterator
        insert(constraintvector self, std::vector< shared_ptr< constraint > >::iterator pos, std::vector< shared_ptr< constraint > >::size_type n, std::vector< shared_ptr< constraint > >::value_type const & x)
        """
        return _sim2d.constraintvector_insert(self, *args)


    def reserve(self, n: 'std::vector< shared_ptr< constraint > >::size_type') -> "void":
        """reserve(constraintvector self, std::vector< shared_ptr< constraint > >::size_type n)"""
        return _sim2d.constraintvector_reserve(self, n)


    def capacity(self) -> "std::vector< shared_ptr< constraint > >::size_type":
        """capacity(constraintvector self) -> std::vector< shared_ptr< constraint > >::size_type"""
        return _sim2d.constraintvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_constraintvector
    __del__ = lambda self: None
constraintvector_swigregister = _sim2d.constraintvector_swigregister
constraintvector_swigregister(constraintvector)

class wallvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(shared_ptr<(SoftWall)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, wallvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, wallvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(wallvector self) -> SwigPyIterator"""
        return _sim2d.wallvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(wallvector self) -> bool"""
        return _sim2d.wallvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(wallvector self) -> bool"""
        return _sim2d.wallvector___bool__(self)


    def __len__(self) -> "std::vector< shared_ptr< SoftWall > >::size_type":
        """__len__(wallvector self) -> std::vector< shared_ptr< SoftWall > >::size_type"""
        return _sim2d.wallvector___len__(self)


    def pop(self) -> "std::vector< shared_ptr< SoftWall > >::value_type":
        """pop(wallvector self) -> std::vector< shared_ptr< SoftWall > >::value_type"""
        return _sim2d.wallvector_pop(self)


    def __getslice__(self, i: 'std::vector< shared_ptr< SoftWall > >::difference_type', j: 'std::vector< shared_ptr< SoftWall > >::difference_type') -> "std::vector< boost::shared_ptr< SoftWall >,std::allocator< boost::shared_ptr< SoftWall > > > *":
        """__getslice__(wallvector self, std::vector< shared_ptr< SoftWall > >::difference_type i, std::vector< shared_ptr< SoftWall > >::difference_type j) -> std::vector< boost::shared_ptr< SoftWall >,std::allocator< boost::shared_ptr< SoftWall > > > *"""
        return _sim2d.wallvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(wallvector self, std::vector< shared_ptr< SoftWall > >::difference_type i, std::vector< shared_ptr< SoftWall > >::difference_type j, std::vector< boost::shared_ptr< SoftWall >,std::allocator< boost::shared_ptr< SoftWall > > > const & v)
        __setslice__(wallvector self, std::vector< shared_ptr< SoftWall > >::difference_type i, std::vector< shared_ptr< SoftWall > >::difference_type j)
        """
        return _sim2d.wallvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< shared_ptr< SoftWall > >::difference_type', j: 'std::vector< shared_ptr< SoftWall > >::difference_type') -> "void":
        """__delslice__(wallvector self, std::vector< shared_ptr< SoftWall > >::difference_type i, std::vector< shared_ptr< SoftWall > >::difference_type j)"""
        return _sim2d.wallvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(wallvector self, std::vector< shared_ptr< SoftWall > >::difference_type i)
        __delitem__(wallvector self, PySliceObject * slice)
        """
        return _sim2d.wallvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< shared_ptr< SoftWall > >::value_type const &":
        """
        __getitem__(wallvector self, PySliceObject * slice) -> std::vector< boost::shared_ptr< SoftWall >,std::allocator< boost::shared_ptr< SoftWall > > >
        __getitem__(wallvector self, std::vector< shared_ptr< SoftWall > >::difference_type i) -> std::vector< shared_ptr< SoftWall > >::value_type const &
        """
        return _sim2d.wallvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(wallvector self, PySliceObject * slice, std::vector< boost::shared_ptr< SoftWall >,std::allocator< boost::shared_ptr< SoftWall > > > const & v)
        __setitem__(wallvector self, PySliceObject * slice)
        __setitem__(wallvector self, std::vector< shared_ptr< SoftWall > >::difference_type i, std::vector< shared_ptr< SoftWall > >::value_type const & x)
        """
        return _sim2d.wallvector___setitem__(self, *args)


    def append(self, x: 'std::vector< shared_ptr< SoftWall > >::value_type const &') -> "void":
        """append(wallvector self, std::vector< shared_ptr< SoftWall > >::value_type const & x)"""
        return _sim2d.wallvector_append(self, x)


    def empty(self) -> "bool":
        """empty(wallvector self) -> bool"""
        return _sim2d.wallvector_empty(self)


    def size(self) -> "std::vector< shared_ptr< SoftWall > >::size_type":
        """size(wallvector self) -> std::vector< shared_ptr< SoftWall > >::size_type"""
        return _sim2d.wallvector_size(self)


    def clear(self) -> "void":
        """clear(wallvector self)"""
        return _sim2d.wallvector_clear(self)


    def swap(self, v: 'wallvector') -> "void":
        """swap(wallvector self, wallvector v)"""
        return _sim2d.wallvector_swap(self, v)


    def get_allocator(self) -> "std::vector< shared_ptr< SoftWall > >::allocator_type":
        """get_allocator(wallvector self) -> std::vector< shared_ptr< SoftWall > >::allocator_type"""
        return _sim2d.wallvector_get_allocator(self)


    def begin(self) -> "std::vector< shared_ptr< SoftWall > >::iterator":
        """begin(wallvector self) -> std::vector< shared_ptr< SoftWall > >::iterator"""
        return _sim2d.wallvector_begin(self)


    def end(self) -> "std::vector< shared_ptr< SoftWall > >::iterator":
        """end(wallvector self) -> std::vector< shared_ptr< SoftWall > >::iterator"""
        return _sim2d.wallvector_end(self)


    def rbegin(self) -> "std::vector< shared_ptr< SoftWall > >::reverse_iterator":
        """rbegin(wallvector self) -> std::vector< shared_ptr< SoftWall > >::reverse_iterator"""
        return _sim2d.wallvector_rbegin(self)


    def rend(self) -> "std::vector< shared_ptr< SoftWall > >::reverse_iterator":
        """rend(wallvector self) -> std::vector< shared_ptr< SoftWall > >::reverse_iterator"""
        return _sim2d.wallvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(wallvector self)"""
        return _sim2d.wallvector_pop_back(self)


    def erase(self, *args) -> "std::vector< shared_ptr< SoftWall > >::iterator":
        """
        erase(wallvector self, std::vector< shared_ptr< SoftWall > >::iterator pos) -> std::vector< shared_ptr< SoftWall > >::iterator
        erase(wallvector self, std::vector< shared_ptr< SoftWall > >::iterator first, std::vector< shared_ptr< SoftWall > >::iterator last) -> std::vector< shared_ptr< SoftWall > >::iterator
        """
        return _sim2d.wallvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(shared_ptr<(SoftWall)>)> self) -> wallvector
        __init__(std::vector<(shared_ptr<(SoftWall)>)> self, wallvector arg2) -> wallvector
        __init__(std::vector<(shared_ptr<(SoftWall)>)> self, std::vector< shared_ptr< SoftWall > >::size_type size) -> wallvector
        __init__(std::vector<(shared_ptr<(SoftWall)>)> self, std::vector< shared_ptr< SoftWall > >::size_type size, std::vector< shared_ptr< SoftWall > >::value_type const & value) -> wallvector
        """
        this = _sim2d.new_wallvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< shared_ptr< SoftWall > >::value_type const &') -> "void":
        """push_back(wallvector self, std::vector< shared_ptr< SoftWall > >::value_type const & x)"""
        return _sim2d.wallvector_push_back(self, x)


    def front(self) -> "std::vector< shared_ptr< SoftWall > >::value_type const &":
        """front(wallvector self) -> std::vector< shared_ptr< SoftWall > >::value_type const &"""
        return _sim2d.wallvector_front(self)


    def back(self) -> "std::vector< shared_ptr< SoftWall > >::value_type const &":
        """back(wallvector self) -> std::vector< shared_ptr< SoftWall > >::value_type const &"""
        return _sim2d.wallvector_back(self)


    def assign(self, n: 'std::vector< shared_ptr< SoftWall > >::size_type', x: 'std::vector< shared_ptr< SoftWall > >::value_type const &') -> "void":
        """assign(wallvector self, std::vector< shared_ptr< SoftWall > >::size_type n, std::vector< shared_ptr< SoftWall > >::value_type const & x)"""
        return _sim2d.wallvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(wallvector self, std::vector< shared_ptr< SoftWall > >::size_type new_size)
        resize(wallvector self, std::vector< shared_ptr< SoftWall > >::size_type new_size, std::vector< shared_ptr< SoftWall > >::value_type const & x)
        """
        return _sim2d.wallvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(wallvector self, std::vector< shared_ptr< SoftWall > >::iterator pos, std::vector< shared_ptr< SoftWall > >::value_type const & x) -> std::vector< shared_ptr< SoftWall > >::iterator
        insert(wallvector self, std::vector< shared_ptr< SoftWall > >::iterator pos, std::vector< shared_ptr< SoftWall > >::size_type n, std::vector< shared_ptr< SoftWall > >::value_type const & x)
        """
        return _sim2d.wallvector_insert(self, *args)


    def reserve(self, n: 'std::vector< shared_ptr< SoftWall > >::size_type') -> "void":
        """reserve(wallvector self, std::vector< shared_ptr< SoftWall > >::size_type n)"""
        return _sim2d.wallvector_reserve(self, n)


    def capacity(self) -> "std::vector< shared_ptr< SoftWall > >::size_type":
        """capacity(wallvector self) -> std::vector< shared_ptr< SoftWall > >::size_type"""
        return _sim2d.wallvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_wallvector
    __del__ = lambda self: None
wallvector_swigregister = _sim2d.wallvector_swigregister
wallvector_swigregister(wallvector)

class idvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(atomid)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, idvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, idvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(idvector self) -> SwigPyIterator"""
        return _sim2d.idvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(idvector self) -> bool"""
        return _sim2d.idvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(idvector self) -> bool"""
        return _sim2d.idvector___bool__(self)


    def __len__(self) -> "std::vector< atomid >::size_type":
        """__len__(idvector self) -> std::vector< atomid >::size_type"""
        return _sim2d.idvector___len__(self)


    def pop(self) -> "std::vector< atomid >::value_type":
        """pop(idvector self) -> atomid"""
        return _sim2d.idvector_pop(self)


    def __getslice__(self, i: 'std::vector< atomid >::difference_type', j: 'std::vector< atomid >::difference_type') -> "std::vector< atomid,std::allocator< atomid > > *":
        """__getslice__(idvector self, std::vector< atomid >::difference_type i, std::vector< atomid >::difference_type j) -> idvector"""
        return _sim2d.idvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(idvector self, std::vector< atomid >::difference_type i, std::vector< atomid >::difference_type j, idvector v)
        __setslice__(idvector self, std::vector< atomid >::difference_type i, std::vector< atomid >::difference_type j)
        """
        return _sim2d.idvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< atomid >::difference_type', j: 'std::vector< atomid >::difference_type') -> "void":
        """__delslice__(idvector self, std::vector< atomid >::difference_type i, std::vector< atomid >::difference_type j)"""
        return _sim2d.idvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(idvector self, std::vector< atomid >::difference_type i)
        __delitem__(idvector self, PySliceObject * slice)
        """
        return _sim2d.idvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< atomid >::value_type const &":
        """
        __getitem__(idvector self, PySliceObject * slice) -> idvector
        __getitem__(idvector self, std::vector< atomid >::difference_type i) -> atomid
        """
        return _sim2d.idvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(idvector self, PySliceObject * slice, idvector v)
        __setitem__(idvector self, PySliceObject * slice)
        __setitem__(idvector self, std::vector< atomid >::difference_type i, atomid x)
        """
        return _sim2d.idvector___setitem__(self, *args)


    def append(self, x: 'atomid') -> "void":
        """append(idvector self, atomid x)"""
        return _sim2d.idvector_append(self, x)


    def empty(self) -> "bool":
        """empty(idvector self) -> bool"""
        return _sim2d.idvector_empty(self)


    def size(self) -> "std::vector< atomid >::size_type":
        """size(idvector self) -> std::vector< atomid >::size_type"""
        return _sim2d.idvector_size(self)


    def clear(self) -> "void":
        """clear(idvector self)"""
        return _sim2d.idvector_clear(self)


    def swap(self, v: 'idvector') -> "void":
        """swap(idvector self, idvector v)"""
        return _sim2d.idvector_swap(self, v)


    def get_allocator(self) -> "std::vector< atomid >::allocator_type":
        """get_allocator(idvector self) -> std::vector< atomid >::allocator_type"""
        return _sim2d.idvector_get_allocator(self)


    def begin(self) -> "std::vector< atomid >::iterator":
        """begin(idvector self) -> std::vector< atomid >::iterator"""
        return _sim2d.idvector_begin(self)


    def end(self) -> "std::vector< atomid >::iterator":
        """end(idvector self) -> std::vector< atomid >::iterator"""
        return _sim2d.idvector_end(self)


    def rbegin(self) -> "std::vector< atomid >::reverse_iterator":
        """rbegin(idvector self) -> std::vector< atomid >::reverse_iterator"""
        return _sim2d.idvector_rbegin(self)


    def rend(self) -> "std::vector< atomid >::reverse_iterator":
        """rend(idvector self) -> std::vector< atomid >::reverse_iterator"""
        return _sim2d.idvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(idvector self)"""
        return _sim2d.idvector_pop_back(self)


    def erase(self, *args) -> "std::vector< atomid >::iterator":
        """
        erase(idvector self, std::vector< atomid >::iterator pos) -> std::vector< atomid >::iterator
        erase(idvector self, std::vector< atomid >::iterator first, std::vector< atomid >::iterator last) -> std::vector< atomid >::iterator
        """
        return _sim2d.idvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(atomid)> self) -> idvector
        __init__(std::vector<(atomid)> self, idvector arg2) -> idvector
        __init__(std::vector<(atomid)> self, std::vector< atomid >::size_type size) -> idvector
        __init__(std::vector<(atomid)> self, std::vector< atomid >::size_type size, atomid value) -> idvector
        """
        this = _sim2d.new_idvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'atomid') -> "void":
        """push_back(idvector self, atomid x)"""
        return _sim2d.idvector_push_back(self, x)


    def front(self) -> "std::vector< atomid >::value_type const &":
        """front(idvector self) -> atomid"""
        return _sim2d.idvector_front(self)


    def back(self) -> "std::vector< atomid >::value_type const &":
        """back(idvector self) -> atomid"""
        return _sim2d.idvector_back(self)


    def assign(self, n: 'std::vector< atomid >::size_type', x: 'atomid') -> "void":
        """assign(idvector self, std::vector< atomid >::size_type n, atomid x)"""
        return _sim2d.idvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(idvector self, std::vector< atomid >::size_type new_size)
        resize(idvector self, std::vector< atomid >::size_type new_size, atomid x)
        """
        return _sim2d.idvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(idvector self, std::vector< atomid >::iterator pos, atomid x) -> std::vector< atomid >::iterator
        insert(idvector self, std::vector< atomid >::iterator pos, std::vector< atomid >::size_type n, atomid x)
        """
        return _sim2d.idvector_insert(self, *args)


    def reserve(self, n: 'std::vector< atomid >::size_type') -> "void":
        """reserve(idvector self, std::vector< atomid >::size_type n)"""
        return _sim2d.idvector_reserve(self, n)


    def capacity(self) -> "std::vector< atomid >::size_type":
        """capacity(idvector self) -> std::vector< atomid >::size_type"""
        return _sim2d.idvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_idvector
    __del__ = lambda self: None
idvector_swigregister = _sim2d.idvector_swigregister
idvector_swigregister(idvector)

class idpairvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(idpair)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, idpairvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, idpairvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(idpairvector self) -> SwigPyIterator"""
        return _sim2d.idpairvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(idpairvector self) -> bool"""
        return _sim2d.idpairvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(idpairvector self) -> bool"""
        return _sim2d.idpairvector___bool__(self)


    def __len__(self) -> "std::vector< idpair >::size_type":
        """__len__(idpairvector self) -> std::vector< idpair >::size_type"""
        return _sim2d.idpairvector___len__(self)


    def pop(self) -> "std::vector< idpair >::value_type":
        """pop(idpairvector self) -> idpair"""
        return _sim2d.idpairvector_pop(self)


    def __getslice__(self, i: 'std::vector< idpair >::difference_type', j: 'std::vector< idpair >::difference_type') -> "std::vector< idpair,std::allocator< idpair > > *":
        """__getslice__(idpairvector self, std::vector< idpair >::difference_type i, std::vector< idpair >::difference_type j) -> idpairvector"""
        return _sim2d.idpairvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(idpairvector self, std::vector< idpair >::difference_type i, std::vector< idpair >::difference_type j, idpairvector v)
        __setslice__(idpairvector self, std::vector< idpair >::difference_type i, std::vector< idpair >::difference_type j)
        """
        return _sim2d.idpairvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< idpair >::difference_type', j: 'std::vector< idpair >::difference_type') -> "void":
        """__delslice__(idpairvector self, std::vector< idpair >::difference_type i, std::vector< idpair >::difference_type j)"""
        return _sim2d.idpairvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(idpairvector self, std::vector< idpair >::difference_type i)
        __delitem__(idpairvector self, PySliceObject * slice)
        """
        return _sim2d.idpairvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< idpair >::value_type const &":
        """
        __getitem__(idpairvector self, PySliceObject * slice) -> idpairvector
        __getitem__(idpairvector self, std::vector< idpair >::difference_type i) -> idpair
        """
        return _sim2d.idpairvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(idpairvector self, PySliceObject * slice, idpairvector v)
        __setitem__(idpairvector self, PySliceObject * slice)
        __setitem__(idpairvector self, std::vector< idpair >::difference_type i, idpair x)
        """
        return _sim2d.idpairvector___setitem__(self, *args)


    def append(self, x: 'idpair') -> "void":
        """append(idpairvector self, idpair x)"""
        return _sim2d.idpairvector_append(self, x)


    def empty(self) -> "bool":
        """empty(idpairvector self) -> bool"""
        return _sim2d.idpairvector_empty(self)


    def size(self) -> "std::vector< idpair >::size_type":
        """size(idpairvector self) -> std::vector< idpair >::size_type"""
        return _sim2d.idpairvector_size(self)


    def clear(self) -> "void":
        """clear(idpairvector self)"""
        return _sim2d.idpairvector_clear(self)


    def swap(self, v: 'idpairvector') -> "void":
        """swap(idpairvector self, idpairvector v)"""
        return _sim2d.idpairvector_swap(self, v)


    def get_allocator(self) -> "std::vector< idpair >::allocator_type":
        """get_allocator(idpairvector self) -> std::vector< idpair >::allocator_type"""
        return _sim2d.idpairvector_get_allocator(self)


    def begin(self) -> "std::vector< idpair >::iterator":
        """begin(idpairvector self) -> std::vector< idpair >::iterator"""
        return _sim2d.idpairvector_begin(self)


    def end(self) -> "std::vector< idpair >::iterator":
        """end(idpairvector self) -> std::vector< idpair >::iterator"""
        return _sim2d.idpairvector_end(self)


    def rbegin(self) -> "std::vector< idpair >::reverse_iterator":
        """rbegin(idpairvector self) -> std::vector< idpair >::reverse_iterator"""
        return _sim2d.idpairvector_rbegin(self)


    def rend(self) -> "std::vector< idpair >::reverse_iterator":
        """rend(idpairvector self) -> std::vector< idpair >::reverse_iterator"""
        return _sim2d.idpairvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(idpairvector self)"""
        return _sim2d.idpairvector_pop_back(self)


    def erase(self, *args) -> "std::vector< idpair >::iterator":
        """
        erase(idpairvector self, std::vector< idpair >::iterator pos) -> std::vector< idpair >::iterator
        erase(idpairvector self, std::vector< idpair >::iterator first, std::vector< idpair >::iterator last) -> std::vector< idpair >::iterator
        """
        return _sim2d.idpairvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(idpair)> self) -> idpairvector
        __init__(std::vector<(idpair)> self, idpairvector arg2) -> idpairvector
        __init__(std::vector<(idpair)> self, std::vector< idpair >::size_type size) -> idpairvector
        __init__(std::vector<(idpair)> self, std::vector< idpair >::size_type size, idpair value) -> idpairvector
        """
        this = _sim2d.new_idpairvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'idpair') -> "void":
        """push_back(idpairvector self, idpair x)"""
        return _sim2d.idpairvector_push_back(self, x)


    def front(self) -> "std::vector< idpair >::value_type const &":
        """front(idpairvector self) -> idpair"""
        return _sim2d.idpairvector_front(self)


    def back(self) -> "std::vector< idpair >::value_type const &":
        """back(idpairvector self) -> idpair"""
        return _sim2d.idpairvector_back(self)


    def assign(self, n: 'std::vector< idpair >::size_type', x: 'idpair') -> "void":
        """assign(idpairvector self, std::vector< idpair >::size_type n, idpair x)"""
        return _sim2d.idpairvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(idpairvector self, std::vector< idpair >::size_type new_size)
        resize(idpairvector self, std::vector< idpair >::size_type new_size, idpair x)
        """
        return _sim2d.idpairvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(idpairvector self, std::vector< idpair >::iterator pos, idpair x) -> std::vector< idpair >::iterator
        insert(idpairvector self, std::vector< idpair >::iterator pos, std::vector< idpair >::size_type n, idpair x)
        """
        return _sim2d.idpairvector_insert(self, *args)


    def reserve(self, n: 'std::vector< idpair >::size_type') -> "void":
        """reserve(idpairvector self, std::vector< idpair >::size_type n)"""
        return _sim2d.idpairvector_reserve(self, n)


    def capacity(self) -> "std::vector< idpair >::size_type":
        """capacity(idpairvector self) -> std::vector< idpair >::size_type"""
        return _sim2d.idpairvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_idpairvector
    __del__ = lambda self: None
idpairvector_swigregister = _sim2d.idpairvector_swigregister
idpairvector_swigregister(idpairvector)

class intvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, intvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, intvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(intvector self) -> SwigPyIterator"""
        return _sim2d.intvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(intvector self) -> bool"""
        return _sim2d.intvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(intvector self) -> bool"""
        return _sim2d.intvector___bool__(self)


    def __len__(self) -> "std::vector< int >::size_type":
        """__len__(intvector self) -> std::vector< int >::size_type"""
        return _sim2d.intvector___len__(self)


    def pop(self) -> "std::vector< int >::value_type":
        """pop(intvector self) -> std::vector< int >::value_type"""
        return _sim2d.intvector_pop(self)


    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        """__getslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> intvector"""
        return _sim2d.intvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, intvector v)
        __setslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        """
        return _sim2d.intvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        """__delslice__(intvector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _sim2d.intvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(intvector self, std::vector< int >::difference_type i)
        __delitem__(intvector self, PySliceObject * slice)
        """
        return _sim2d.intvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        """
        __getitem__(intvector self, PySliceObject * slice) -> intvector
        __getitem__(intvector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _sim2d.intvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(intvector self, PySliceObject * slice, intvector v)
        __setitem__(intvector self, PySliceObject * slice)
        __setitem__(intvector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _sim2d.intvector___setitem__(self, *args)


    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        """append(intvector self, std::vector< int >::value_type const & x)"""
        return _sim2d.intvector_append(self, x)


    def empty(self) -> "bool":
        """empty(intvector self) -> bool"""
        return _sim2d.intvector_empty(self)


    def size(self) -> "std::vector< int >::size_type":
        """size(intvector self) -> std::vector< int >::size_type"""
        return _sim2d.intvector_size(self)


    def clear(self) -> "void":
        """clear(intvector self)"""
        return _sim2d.intvector_clear(self)


    def swap(self, v: 'intvector') -> "void":
        """swap(intvector self, intvector v)"""
        return _sim2d.intvector_swap(self, v)


    def get_allocator(self) -> "std::vector< int >::allocator_type":
        """get_allocator(intvector self) -> std::vector< int >::allocator_type"""
        return _sim2d.intvector_get_allocator(self)


    def begin(self) -> "std::vector< int >::iterator":
        """begin(intvector self) -> std::vector< int >::iterator"""
        return _sim2d.intvector_begin(self)


    def end(self) -> "std::vector< int >::iterator":
        """end(intvector self) -> std::vector< int >::iterator"""
        return _sim2d.intvector_end(self)


    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        """rbegin(intvector self) -> std::vector< int >::reverse_iterator"""
        return _sim2d.intvector_rbegin(self)


    def rend(self) -> "std::vector< int >::reverse_iterator":
        """rend(intvector self) -> std::vector< int >::reverse_iterator"""
        return _sim2d.intvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(intvector self)"""
        return _sim2d.intvector_pop_back(self)


    def erase(self, *args) -> "std::vector< int >::iterator":
        """
        erase(intvector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(intvector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _sim2d.intvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> intvector
        __init__(std::vector<(int)> self, intvector arg2) -> intvector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> intvector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> intvector
        """
        this = _sim2d.new_intvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        """push_back(intvector self, std::vector< int >::value_type const & x)"""
        return _sim2d.intvector_push_back(self, x)


    def front(self) -> "std::vector< int >::value_type const &":
        """front(intvector self) -> std::vector< int >::value_type const &"""
        return _sim2d.intvector_front(self)


    def back(self) -> "std::vector< int >::value_type const &":
        """back(intvector self) -> std::vector< int >::value_type const &"""
        return _sim2d.intvector_back(self)


    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        """assign(intvector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _sim2d.intvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(intvector self, std::vector< int >::size_type new_size)
        resize(intvector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _sim2d.intvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(intvector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(intvector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _sim2d.intvector_insert(self, *args)


    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        """reserve(intvector self, std::vector< int >::size_type n)"""
        return _sim2d.intvector_reserve(self, n)


    def capacity(self) -> "std::vector< int >::size_type":
        """capacity(intvector self) -> std::vector< int >::size_type"""
        return _sim2d.intvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_intvector
    __del__ = lambda self: None
intvector_swigregister = _sim2d.intvector_swigregister
intvector_swigregister(intvector)

class uintvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uintvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uintvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(uintvector self) -> SwigPyIterator"""
        return _sim2d.uintvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(uintvector self) -> bool"""
        return _sim2d.uintvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(uintvector self) -> bool"""
        return _sim2d.uintvector___bool__(self)


    def __len__(self) -> "std::vector< unsigned int >::size_type":
        """__len__(uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2d.uintvector___len__(self)


    def pop(self) -> "std::vector< unsigned int >::value_type":
        """pop(uintvector self) -> std::vector< unsigned int >::value_type"""
        return _sim2d.uintvector_pop(self)


    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        """__getslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> uintvector"""
        return _sim2d.uintvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, uintvector v)
        __setslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        """
        return _sim2d.uintvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        """__delslice__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _sim2d.uintvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(uintvector self, std::vector< unsigned int >::difference_type i)
        __delitem__(uintvector self, PySliceObject * slice)
        """
        return _sim2d.uintvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        """
        __getitem__(uintvector self, PySliceObject * slice) -> uintvector
        __getitem__(uintvector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _sim2d.uintvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(uintvector self, PySliceObject * slice, uintvector v)
        __setitem__(uintvector self, PySliceObject * slice)
        __setitem__(uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2d.uintvector___setitem__(self, *args)


    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """append(uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim2d.uintvector_append(self, x)


    def empty(self) -> "bool":
        """empty(uintvector self) -> bool"""
        return _sim2d.uintvector_empty(self)


    def size(self) -> "std::vector< unsigned int >::size_type":
        """size(uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2d.uintvector_size(self)


    def clear(self) -> "void":
        """clear(uintvector self)"""
        return _sim2d.uintvector_clear(self)


    def swap(self, v: 'uintvector') -> "void":
        """swap(uintvector self, uintvector v)"""
        return _sim2d.uintvector_swap(self, v)


    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        """get_allocator(uintvector self) -> std::vector< unsigned int >::allocator_type"""
        return _sim2d.uintvector_get_allocator(self)


    def begin(self) -> "std::vector< unsigned int >::iterator":
        """begin(uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim2d.uintvector_begin(self)


    def end(self) -> "std::vector< unsigned int >::iterator":
        """end(uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim2d.uintvector_end(self)


    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rbegin(uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim2d.uintvector_rbegin(self)


    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        """rend(uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim2d.uintvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(uintvector self)"""
        return _sim2d.uintvector_pop_back(self)


    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        """
        erase(uintvector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(uintvector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _sim2d.uintvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned int)> self) -> uintvector
        __init__(std::vector<(unsigned int)> self, uintvector arg2) -> uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> uintvector
        """
        this = _sim2d.new_uintvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """push_back(uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim2d.uintvector_push_back(self, x)


    def front(self) -> "std::vector< unsigned int >::value_type const &":
        """front(uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim2d.uintvector_front(self)


    def back(self) -> "std::vector< unsigned int >::value_type const &":
        """back(uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim2d.uintvector_back(self)


    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        """assign(uintvector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _sim2d.uintvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(uintvector self, std::vector< unsigned int >::size_type new_size)
        resize(uintvector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2d.uintvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2d.uintvector_insert(self, *args)


    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        """reserve(uintvector self, std::vector< unsigned int >::size_type n)"""
        return _sim2d.uintvector_reserve(self, n)


    def capacity(self) -> "std::vector< unsigned int >::size_type":
        """capacity(uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2d.uintvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_uintvector
    __del__ = lambda self: None
uintvector_swigregister = _sim2d.uintvector_swigregister
uintvector_swigregister(uintvector)

class ulongvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(unsigned long)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ulongvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ulongvector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(ulongvector self) -> SwigPyIterator"""
        return _sim2d.ulongvector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(ulongvector self) -> bool"""
        return _sim2d.ulongvector___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(ulongvector self) -> bool"""
        return _sim2d.ulongvector___bool__(self)


    def __len__(self) -> "std::vector< unsigned long >::size_type":
        """__len__(ulongvector self) -> std::vector< unsigned long >::size_type"""
        return _sim2d.ulongvector___len__(self)


    def pop(self) -> "std::vector< unsigned long >::value_type":
        """pop(ulongvector self) -> std::vector< unsigned long >::value_type"""
        return _sim2d.ulongvector_pop(self)


    def __getslice__(self, i: 'std::vector< unsigned long >::difference_type', j: 'std::vector< unsigned long >::difference_type') -> "std::vector< unsigned long,std::allocator< unsigned long > > *":
        """__getslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> ulongvector"""
        return _sim2d.ulongvector___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, ulongvector v)
        __setslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        """
        return _sim2d.ulongvector___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< unsigned long >::difference_type', j: 'std::vector< unsigned long >::difference_type') -> "void":
        """__delslice__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _sim2d.ulongvector___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(ulongvector self, std::vector< unsigned long >::difference_type i)
        __delitem__(ulongvector self, PySliceObject * slice)
        """
        return _sim2d.ulongvector___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< unsigned long >::value_type const &":
        """
        __getitem__(ulongvector self, PySliceObject * slice) -> ulongvector
        __getitem__(ulongvector self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _sim2d.ulongvector___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(ulongvector self, PySliceObject * slice, ulongvector v)
        __setitem__(ulongvector self, PySliceObject * slice)
        __setitem__(ulongvector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _sim2d.ulongvector___setitem__(self, *args)


    def append(self, x: 'std::vector< unsigned long >::value_type const &') -> "void":
        """append(ulongvector self, std::vector< unsigned long >::value_type const & x)"""
        return _sim2d.ulongvector_append(self, x)


    def empty(self) -> "bool":
        """empty(ulongvector self) -> bool"""
        return _sim2d.ulongvector_empty(self)


    def size(self) -> "std::vector< unsigned long >::size_type":
        """size(ulongvector self) -> std::vector< unsigned long >::size_type"""
        return _sim2d.ulongvector_size(self)


    def clear(self) -> "void":
        """clear(ulongvector self)"""
        return _sim2d.ulongvector_clear(self)


    def swap(self, v: 'ulongvector') -> "void":
        """swap(ulongvector self, ulongvector v)"""
        return _sim2d.ulongvector_swap(self, v)


    def get_allocator(self) -> "std::vector< unsigned long >::allocator_type":
        """get_allocator(ulongvector self) -> std::vector< unsigned long >::allocator_type"""
        return _sim2d.ulongvector_get_allocator(self)


    def begin(self) -> "std::vector< unsigned long >::iterator":
        """begin(ulongvector self) -> std::vector< unsigned long >::iterator"""
        return _sim2d.ulongvector_begin(self)


    def end(self) -> "std::vector< unsigned long >::iterator":
        """end(ulongvector self) -> std::vector< unsigned long >::iterator"""
        return _sim2d.ulongvector_end(self)


    def rbegin(self) -> "std::vector< unsigned long >::reverse_iterator":
        """rbegin(ulongvector self) -> std::vector< unsigned long >::reverse_iterator"""
        return _sim2d.ulongvector_rbegin(self)


    def rend(self) -> "std::vector< unsigned long >::reverse_iterator":
        """rend(ulongvector self) -> std::vector< unsigned long >::reverse_iterator"""
        return _sim2d.ulongvector_rend(self)


    def pop_back(self) -> "void":
        """pop_back(ulongvector self)"""
        return _sim2d.ulongvector_pop_back(self)


    def erase(self, *args) -> "std::vector< unsigned long >::iterator":
        """
        erase(ulongvector self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(ulongvector self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _sim2d.ulongvector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned long)> self) -> ulongvector
        __init__(std::vector<(unsigned long)> self, ulongvector arg2) -> ulongvector
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size) -> ulongvector
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> ulongvector
        """
        this = _sim2d.new_ulongvector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned long >::value_type const &') -> "void":
        """push_back(ulongvector self, std::vector< unsigned long >::value_type const & x)"""
        return _sim2d.ulongvector_push_back(self, x)


    def front(self) -> "std::vector< unsigned long >::value_type const &":
        """front(ulongvector self) -> std::vector< unsigned long >::value_type const &"""
        return _sim2d.ulongvector_front(self)


    def back(self) -> "std::vector< unsigned long >::value_type const &":
        """back(ulongvector self) -> std::vector< unsigned long >::value_type const &"""
        return _sim2d.ulongvector_back(self)


    def assign(self, n: 'std::vector< unsigned long >::size_type', x: 'std::vector< unsigned long >::value_type const &') -> "void":
        """assign(ulongvector self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _sim2d.ulongvector_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(ulongvector self, std::vector< unsigned long >::size_type new_size)
        resize(ulongvector self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _sim2d.ulongvector_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(ulongvector self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(ulongvector self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _sim2d.ulongvector_insert(self, *args)


    def reserve(self, n: 'std::vector< unsigned long >::size_type') -> "void":
        """reserve(ulongvector self, std::vector< unsigned long >::size_type n)"""
        return _sim2d.ulongvector_reserve(self, n)


    def capacity(self) -> "std::vector< unsigned long >::size_type":
        """capacity(ulongvector self) -> std::vector< unsigned long >::size_type"""
        return _sim2d.ulongvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ulongvector
    __del__ = lambda self: None
ulongvector_swigregister = _sim2d.ulongvector_swigregister
ulongvector_swigregister(ulongvector)

class _eventset(collections.MutableSet):
    """Proxy of C++ std::set<(event)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _eventset, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _eventset, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(_eventset self) -> SwigPyIterator"""
        return _sim2d._eventset_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(_eventset self) -> bool"""
        return _sim2d._eventset___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(_eventset self) -> bool"""
        return _sim2d._eventset___bool__(self)


    def __len__(self) -> "std::set< event >::size_type":
        """__len__(_eventset self) -> std::set< event >::size_type"""
        return _sim2d._eventset___len__(self)


    def append(self, x: 'event') -> "void":
        """append(_eventset self, event x)"""
        return _sim2d._eventset_append(self, x)


    def __contains__(self, x: 'event') -> "bool":
        """__contains__(_eventset self, event x) -> bool"""
        return _sim2d._eventset___contains__(self, x)


    def __getitem__(self, i: 'std::set< event >::difference_type') -> "std::set< event >::value_type":
        """__getitem__(_eventset self, std::set< event >::difference_type i) -> event"""
        return _sim2d._eventset___getitem__(self, i)


    def add(self, x: 'event') -> "void":
        """add(_eventset self, event x)"""
        return _sim2d._eventset_add(self, x)


    def discard(self, x: 'event') -> "void":
        """discard(_eventset self, event x)"""
        return _sim2d._eventset_discard(self, x)


    def __init__(self, *args):
        """
        __init__(std::set<(event)> self, std::less< event > const & arg2) -> _eventset
        __init__(std::set<(event)> self) -> _eventset
        __init__(std::set<(event)> self, _eventset arg2) -> _eventset
        """
        this = _sim2d.new__eventset(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self) -> "bool":
        """empty(_eventset self) -> bool"""
        return _sim2d._eventset_empty(self)


    def size(self) -> "std::set< event >::size_type":
        """size(_eventset self) -> std::set< event >::size_type"""
        return _sim2d._eventset_size(self)


    def clear(self) -> "void":
        """clear(_eventset self)"""
        return _sim2d._eventset_clear(self)


    def swap(self, v: '_eventset') -> "void":
        """swap(_eventset self, _eventset v)"""
        return _sim2d._eventset_swap(self, v)


    def count(self, x: 'event') -> "std::set< event >::size_type":
        """count(_eventset self, event x) -> std::set< event >::size_type"""
        return _sim2d._eventset_count(self, x)


    def begin(self) -> "std::set< event >::iterator":
        """begin(_eventset self) -> std::set< event >::iterator"""
        return _sim2d._eventset_begin(self)


    def end(self) -> "std::set< event >::iterator":
        """end(_eventset self) -> std::set< event >::iterator"""
        return _sim2d._eventset_end(self)


    def rbegin(self) -> "std::set< event >::reverse_iterator":
        """rbegin(_eventset self) -> std::set< event >::reverse_iterator"""
        return _sim2d._eventset_rbegin(self)


    def rend(self) -> "std::set< event >::reverse_iterator":
        """rend(_eventset self) -> std::set< event >::reverse_iterator"""
        return _sim2d._eventset_rend(self)


    def erase(self, *args) -> "void":
        """
        erase(_eventset self, event x) -> std::set< event >::size_type
        erase(_eventset self, std::set< event >::iterator pos)
        erase(_eventset self, std::set< event >::iterator first, std::set< event >::iterator last)
        """
        return _sim2d._eventset_erase(self, *args)


    def find(self, x: 'event') -> "std::set< event >::iterator":
        """find(_eventset self, event x) -> std::set< event >::iterator"""
        return _sim2d._eventset_find(self, x)


    def lower_bound(self, x: 'event') -> "std::set< event >::iterator":
        """lower_bound(_eventset self, event x) -> std::set< event >::iterator"""
        return _sim2d._eventset_lower_bound(self, x)


    def upper_bound(self, x: 'event') -> "std::set< event >::iterator":
        """upper_bound(_eventset self, event x) -> std::set< event >::iterator"""
        return _sim2d._eventset_upper_bound(self, x)


    def equal_range(self, x: 'event') -> "std::pair< std::set< event >::iterator,std::set< event >::iterator >":
        """equal_range(_eventset self, event x) -> std::pair< std::set< event >::iterator,std::set< event >::iterator >"""
        return _sim2d._eventset_equal_range(self, x)


    def insert(self, __x: 'event') -> "std::pair< std::set< event >::iterator,bool >":
        """insert(_eventset self, event __x) -> std::pair< std::set< event >::iterator,bool >"""
        return _sim2d._eventset_insert(self, __x)

    __swig_destroy__ = _sim2d.delete__eventset
    __del__ = lambda self: None
_eventset_swigregister = _sim2d._eventset_swigregister
_eventset_swigregister(_eventset)

class pair_uint_CNodePath(_object):
    """Proxy of C++ std::pair<(unsigned int,CNodePath)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pair_uint_CNodePath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pair_uint_CNodePath, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(unsigned int,CNodePath)> self) -> pair_uint_CNodePath
        __init__(std::pair<(unsigned int,CNodePath)> self, unsigned int first, CNodePath second) -> pair_uint_CNodePath
        __init__(std::pair<(unsigned int,CNodePath)> self, pair_uint_CNodePath p) -> pair_uint_CNodePath
        """
        this = _sim2d.new_pair_uint_CNodePath(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_setmethods__["first"] = _sim2d.pair_uint_CNodePath_first_set
    __swig_getmethods__["first"] = _sim2d.pair_uint_CNodePath_first_get
    if _newclass:
        first = _swig_property(_sim2d.pair_uint_CNodePath_first_get, _sim2d.pair_uint_CNodePath_first_set)
    __swig_setmethods__["second"] = _sim2d.pair_uint_CNodePath_second_set
    __swig_getmethods__["second"] = _sim2d.pair_uint_CNodePath_second_get
    if _newclass:
        second = _swig_property(_sim2d.pair_uint_CNodePath_second_get, _sim2d.pair_uint_CNodePath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _sim2d.delete_pair_uint_CNodePath
    __del__ = lambda self: None
pair_uint_CNodePath_swigregister = _sim2d.pair_uint_CNodePath_swigregister
pair_uint_CNodePath_swigregister(pair_uint_CNodePath)

class map_uint_CNodePath(collections.MutableMapping):
    """Proxy of C++ std::map<(unsigned int,CNodePath)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, map_uint_CNodePath, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, map_uint_CNodePath, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(map_uint_CNodePath self) -> SwigPyIterator"""
        return _sim2d.map_uint_CNodePath_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(map_uint_CNodePath self) -> bool"""
        return _sim2d.map_uint_CNodePath___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(map_uint_CNodePath self) -> bool"""
        return _sim2d.map_uint_CNodePath___bool__(self)


    def __len__(self) -> "std::map< unsigned int,CNodePath >::size_type":
        """__len__(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::size_type"""
        return _sim2d.map_uint_CNodePath___len__(self)

    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::mapped_type const &":
        """__getitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key) -> CNodePath"""
        return _sim2d.map_uint_CNodePath___getitem__(self, key)


    def __delitem__(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "void":
        """__delitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key)"""
        return _sim2d.map_uint_CNodePath___delitem__(self, key)


    def has_key(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "bool":
        """has_key(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key) -> bool"""
        return _sim2d.map_uint_CNodePath_has_key(self, key)


    def keys(self) -> "PyObject *":
        """keys(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_keys(self)


    def values(self) -> "PyObject *":
        """values(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_values(self)


    def items(self) -> "PyObject *":
        """items(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_items(self)


    def __contains__(self, key: 'std::map< unsigned int,CNodePath >::key_type const &') -> "bool":
        """__contains__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key) -> bool"""
        return _sim2d.map_uint_CNodePath___contains__(self, key)


    def key_iterator(self) -> "swig::SwigPyIterator *":
        """key_iterator(map_uint_CNodePath self) -> SwigPyIterator"""
        return _sim2d.map_uint_CNodePath_key_iterator(self)


    def value_iterator(self) -> "swig::SwigPyIterator *":
        """value_iterator(map_uint_CNodePath self) -> SwigPyIterator"""
        return _sim2d.map_uint_CNodePath_value_iterator(self)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key)
        __setitem__(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & key, CNodePath x)
        """
        return _sim2d.map_uint_CNodePath___setitem__(self, *args)


    def asdict(self) -> "PyObject *":
        """asdict(map_uint_CNodePath self) -> PyObject *"""
        return _sim2d.map_uint_CNodePath_asdict(self)


    def __init__(self, *args):
        """
        __init__(std::map<(unsigned int,CNodePath)> self, std::less< unsigned int > const & arg2) -> map_uint_CNodePath
        __init__(std::map<(unsigned int,CNodePath)> self) -> map_uint_CNodePath
        __init__(std::map<(unsigned int,CNodePath)> self, map_uint_CNodePath arg2) -> map_uint_CNodePath
        """
        this = _sim2d.new_map_uint_CNodePath(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self) -> "bool":
        """empty(map_uint_CNodePath self) -> bool"""
        return _sim2d.map_uint_CNodePath_empty(self)


    def size(self) -> "std::map< unsigned int,CNodePath >::size_type":
        """size(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::size_type"""
        return _sim2d.map_uint_CNodePath_size(self)


    def clear(self) -> "void":
        """clear(map_uint_CNodePath self)"""
        return _sim2d.map_uint_CNodePath_clear(self)


    def swap(self, v: 'map_uint_CNodePath') -> "void":
        """swap(map_uint_CNodePath self, map_uint_CNodePath v)"""
        return _sim2d.map_uint_CNodePath_swap(self, v)


    def get_allocator(self) -> "std::map< unsigned int,CNodePath >::allocator_type":
        """get_allocator(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::allocator_type"""
        return _sim2d.map_uint_CNodePath_get_allocator(self)


    def begin(self) -> "std::map< unsigned int,CNodePath >::iterator":
        """begin(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_begin(self)


    def end(self) -> "std::map< unsigned int,CNodePath >::iterator":
        """end(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_end(self)


    def rbegin(self) -> "std::map< unsigned int,CNodePath >::reverse_iterator":
        """rbegin(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::reverse_iterator"""
        return _sim2d.map_uint_CNodePath_rbegin(self)


    def rend(self) -> "std::map< unsigned int,CNodePath >::reverse_iterator":
        """rend(map_uint_CNodePath self) -> std::map< unsigned int,CNodePath >::reverse_iterator"""
        return _sim2d.map_uint_CNodePath_rend(self)


    def count(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::size_type":
        """count(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::size_type"""
        return _sim2d.map_uint_CNodePath_count(self, x)


    def erase(self, *args) -> "void":
        """
        erase(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::size_type
        erase(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::iterator position)
        erase(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::iterator first, std::map< unsigned int,CNodePath >::iterator last)
        """
        return _sim2d.map_uint_CNodePath_erase(self, *args)


    def find(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::iterator":
        """find(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_find(self, x)


    def lower_bound(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::iterator":
        """lower_bound(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_lower_bound(self, x)


    def upper_bound(self, x: 'std::map< unsigned int,CNodePath >::key_type const &') -> "std::map< unsigned int,CNodePath >::iterator":
        """upper_bound(map_uint_CNodePath self, std::map< unsigned int,CNodePath >::key_type const & x) -> std::map< unsigned int,CNodePath >::iterator"""
        return _sim2d.map_uint_CNodePath_upper_bound(self, x)

    __swig_destroy__ = _sim2d.delete_map_uint_CNodePath
    __del__ = lambda self: None
map_uint_CNodePath_swigregister = _sim2d.map_uint_CNodePath_swigregister
map_uint_CNodePath_swigregister(map_uint_CNodePath)

class vector_CNode(collections.MutableSequence):
    """Proxy of C++ std::vector<(CNode)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_CNode, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, vector_CNode, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(vector_CNode self) -> SwigPyIterator"""
        return _sim2d.vector_CNode_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(vector_CNode self) -> bool"""
        return _sim2d.vector_CNode___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(vector_CNode self) -> bool"""
        return _sim2d.vector_CNode___bool__(self)


    def __len__(self) -> "std::vector< CNode >::size_type":
        """__len__(vector_CNode self) -> std::vector< CNode >::size_type"""
        return _sim2d.vector_CNode___len__(self)


    def pop(self) -> "std::vector< CNode >::value_type":
        """pop(vector_CNode self) -> CNode"""
        return _sim2d.vector_CNode_pop(self)


    def __getslice__(self, i: 'std::vector< CNode >::difference_type', j: 'std::vector< CNode >::difference_type') -> "std::vector< CNode,std::allocator< CNode > > *":
        """__getslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j) -> vector_CNode"""
        return _sim2d.vector_CNode___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j, vector_CNode v)
        __setslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j)
        """
        return _sim2d.vector_CNode___setslice__(self, *args)


    def __delslice__(self, i: 'std::vector< CNode >::difference_type', j: 'std::vector< CNode >::difference_type') -> "void":
        """__delslice__(vector_CNode self, std::vector< CNode >::difference_type i, std::vector< CNode >::difference_type j)"""
        return _sim2d.vector_CNode___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(vector_CNode self, std::vector< CNode >::difference_type i)
        __delitem__(vector_CNode self, PySliceObject * slice)
        """
        return _sim2d.vector_CNode___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::vector< CNode >::value_type const &":
        """
        __getitem__(vector_CNode self, PySliceObject * slice) -> vector_CNode
        __getitem__(vector_CNode self, std::vector< CNode >::difference_type i) -> CNode
        """
        return _sim2d.vector_CNode___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(vector_CNode self, PySliceObject * slice, vector_CNode v)
        __setitem__(vector_CNode self, PySliceObject * slice)
        __setitem__(vector_CNode self, std::vector< CNode >::difference_type i, CNode x)
        """
        return _sim2d.vector_CNode___setitem__(self, *args)


    def append(self, x: 'CNode') -> "void":
        """append(vector_CNode self, CNode x)"""
        return _sim2d.vector_CNode_append(self, x)


    def empty(self) -> "bool":
        """empty(vector_CNode self) -> bool"""
        return _sim2d.vector_CNode_empty(self)


    def size(self) -> "std::vector< CNode >::size_type":
        """size(vector_CNode self) -> std::vector< CNode >::size_type"""
        return _sim2d.vector_CNode_size(self)


    def clear(self) -> "void":
        """clear(vector_CNode self)"""
        return _sim2d.vector_CNode_clear(self)


    def swap(self, v: 'vector_CNode') -> "void":
        """swap(vector_CNode self, vector_CNode v)"""
        return _sim2d.vector_CNode_swap(self, v)


    def get_allocator(self) -> "std::vector< CNode >::allocator_type":
        """get_allocator(vector_CNode self) -> std::vector< CNode >::allocator_type"""
        return _sim2d.vector_CNode_get_allocator(self)


    def begin(self) -> "std::vector< CNode >::iterator":
        """begin(vector_CNode self) -> std::vector< CNode >::iterator"""
        return _sim2d.vector_CNode_begin(self)


    def end(self) -> "std::vector< CNode >::iterator":
        """end(vector_CNode self) -> std::vector< CNode >::iterator"""
        return _sim2d.vector_CNode_end(self)


    def rbegin(self) -> "std::vector< CNode >::reverse_iterator":
        """rbegin(vector_CNode self) -> std::vector< CNode >::reverse_iterator"""
        return _sim2d.vector_CNode_rbegin(self)


    def rend(self) -> "std::vector< CNode >::reverse_iterator":
        """rend(vector_CNode self) -> std::vector< CNode >::reverse_iterator"""
        return _sim2d.vector_CNode_rend(self)


    def pop_back(self) -> "void":
        """pop_back(vector_CNode self)"""
        return _sim2d.vector_CNode_pop_back(self)


    def erase(self, *args) -> "std::vector< CNode >::iterator":
        """
        erase(vector_CNode self, std::vector< CNode >::iterator pos) -> std::vector< CNode >::iterator
        erase(vector_CNode self, std::vector< CNode >::iterator first, std::vector< CNode >::iterator last) -> std::vector< CNode >::iterator
        """
        return _sim2d.vector_CNode_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(CNode)> self) -> vector_CNode
        __init__(std::vector<(CNode)> self, vector_CNode arg2) -> vector_CNode
        __init__(std::vector<(CNode)> self, std::vector< CNode >::size_type size) -> vector_CNode
        __init__(std::vector<(CNode)> self, std::vector< CNode >::size_type size, CNode value) -> vector_CNode
        """
        this = _sim2d.new_vector_CNode(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'CNode') -> "void":
        """push_back(vector_CNode self, CNode x)"""
        return _sim2d.vector_CNode_push_back(self, x)


    def front(self) -> "std::vector< CNode >::value_type const &":
        """front(vector_CNode self) -> CNode"""
        return _sim2d.vector_CNode_front(self)


    def back(self) -> "std::vector< CNode >::value_type const &":
        """back(vector_CNode self) -> CNode"""
        return _sim2d.vector_CNode_back(self)


    def assign(self, n: 'std::vector< CNode >::size_type', x: 'CNode') -> "void":
        """assign(vector_CNode self, std::vector< CNode >::size_type n, CNode x)"""
        return _sim2d.vector_CNode_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(vector_CNode self, std::vector< CNode >::size_type new_size)
        resize(vector_CNode self, std::vector< CNode >::size_type new_size, CNode x)
        """
        return _sim2d.vector_CNode_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(vector_CNode self, std::vector< CNode >::iterator pos, CNode x) -> std::vector< CNode >::iterator
        insert(vector_CNode self, std::vector< CNode >::iterator pos, std::vector< CNode >::size_type n, CNode x)
        """
        return _sim2d.vector_CNode_insert(self, *args)


    def reserve(self, n: 'std::vector< CNode >::size_type') -> "void":
        """reserve(vector_CNode self, std::vector< CNode >::size_type n)"""
        return _sim2d.vector_CNode_reserve(self, n)


    def capacity(self) -> "std::vector< CNode >::size_type":
        """capacity(vector_CNode self) -> std::vector< CNode >::size_type"""
        return _sim2d.vector_CNode_capacity(self)

    __swig_destroy__ = _sim2d.delete_vector_CNode
    __del__ = lambda self: None
vector_CNode_swigregister = _sim2d.vector_CNode_swigregister
vector_CNode_swigregister(vector_CNode)

class pair_int_CNode(_object):
    """Proxy of C++ std::pair<(int,std::vector<(CNode)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pair_int_CNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pair_int_CNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(int,std::vector<(CNode)>)> self) -> pair_int_CNode
        __init__(std::pair<(int,std::vector<(CNode)>)> self, int first, vector_CNode second) -> pair_int_CNode
        __init__(std::pair<(int,std::vector<(CNode)>)> self, pair_int_CNode p) -> pair_int_CNode
        """
        this = _sim2d.new_pair_int_CNode(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_setmethods__["first"] = _sim2d.pair_int_CNode_first_set
    __swig_getmethods__["first"] = _sim2d.pair_int_CNode_first_get
    if _newclass:
        first = _swig_property(_sim2d.pair_int_CNode_first_get, _sim2d.pair_int_CNode_first_set)
    __swig_setmethods__["second"] = _sim2d.pair_int_CNode_second_set
    __swig_getmethods__["second"] = _sim2d.pair_int_CNode_second_get
    if _newclass:
        second = _swig_property(_sim2d.pair_int_CNode_second_get, _sim2d.pair_int_CNode_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _sim2d.delete_pair_int_CNode
    __del__ = lambda self: None
pair_int_CNode_swigregister = _sim2d.pair_int_CNode_swigregister
pair_int_CNode_swigregister(pair_int_CNode)

class map_int_CNode(collections.MutableMapping):
    """Proxy of C++ std::map<(int,std::vector<(CNode)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, map_int_CNode, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableMapping]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, map_int_CNode, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(map_int_CNode self) -> SwigPyIterator"""
        return _sim2d.map_int_CNode_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(map_int_CNode self) -> bool"""
        return _sim2d.map_int_CNode___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(map_int_CNode self) -> bool"""
        return _sim2d.map_int_CNode___bool__(self)


    def __len__(self) -> "std::map< int,std::vector< CNode > >::size_type":
        """__len__(map_int_CNode self) -> std::map< int,std::vector< CNode > >::size_type"""
        return _sim2d.map_int_CNode___len__(self)

    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< int,std::vector< CNode > >::key_type const &') -> "std::map< int,std::vector< CNode > >::mapped_type const &":
        """__getitem__(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & key) -> vector_CNode"""
        return _sim2d.map_int_CNode___getitem__(self, key)


    def __delitem__(self, key: 'std::map< int,std::vector< CNode > >::key_type const &') -> "void":
        """__delitem__(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & key)"""
        return _sim2d.map_int_CNode___delitem__(self, key)


    def has_key(self, key: 'std::map< int,std::vector< CNode > >::key_type const &') -> "bool":
        """has_key(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & key) -> bool"""
        return _sim2d.map_int_CNode_has_key(self, key)


    def keys(self) -> "PyObject *":
        """keys(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_keys(self)


    def values(self) -> "PyObject *":
        """values(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_values(self)


    def items(self) -> "PyObject *":
        """items(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_items(self)


    def __contains__(self, key: 'std::map< int,std::vector< CNode > >::key_type const &') -> "bool":
        """__contains__(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & key) -> bool"""
        return _sim2d.map_int_CNode___contains__(self, key)


    def key_iterator(self) -> "swig::SwigPyIterator *":
        """key_iterator(map_int_CNode self) -> SwigPyIterator"""
        return _sim2d.map_int_CNode_key_iterator(self)


    def value_iterator(self) -> "swig::SwigPyIterator *":
        """value_iterator(map_int_CNode self) -> SwigPyIterator"""
        return _sim2d.map_int_CNode_value_iterator(self)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & key)
        __setitem__(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & key, vector_CNode x)
        """
        return _sim2d.map_int_CNode___setitem__(self, *args)


    def asdict(self) -> "PyObject *":
        """asdict(map_int_CNode self) -> PyObject *"""
        return _sim2d.map_int_CNode_asdict(self)


    def __init__(self, *args):
        """
        __init__(std::map<(int,std::vector<(CNode)>)> self, std::less< int > const & arg2) -> map_int_CNode
        __init__(std::map<(int,std::vector<(CNode)>)> self) -> map_int_CNode
        __init__(std::map<(int,std::vector<(CNode)>)> self, map_int_CNode arg2) -> map_int_CNode
        """
        this = _sim2d.new_map_int_CNode(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self) -> "bool":
        """empty(map_int_CNode self) -> bool"""
        return _sim2d.map_int_CNode_empty(self)


    def size(self) -> "std::map< int,std::vector< CNode > >::size_type":
        """size(map_int_CNode self) -> std::map< int,std::vector< CNode > >::size_type"""
        return _sim2d.map_int_CNode_size(self)


    def clear(self) -> "void":
        """clear(map_int_CNode self)"""
        return _sim2d.map_int_CNode_clear(self)


    def swap(self, v: 'map_int_CNode') -> "void":
        """swap(map_int_CNode self, map_int_CNode v)"""
        return _sim2d.map_int_CNode_swap(self, v)


    def get_allocator(self) -> "std::map< int,std::vector< CNode > >::allocator_type":
        """get_allocator(map_int_CNode self) -> std::map< int,std::vector< CNode > >::allocator_type"""
        return _sim2d.map_int_CNode_get_allocator(self)


    def begin(self) -> "std::map< int,std::vector< CNode > >::iterator":
        """begin(map_int_CNode self) -> std::map< int,std::vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_begin(self)


    def end(self) -> "std::map< int,std::vector< CNode > >::iterator":
        """end(map_int_CNode self) -> std::map< int,std::vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_end(self)


    def rbegin(self) -> "std::map< int,std::vector< CNode > >::reverse_iterator":
        """rbegin(map_int_CNode self) -> std::map< int,std::vector< CNode > >::reverse_iterator"""
        return _sim2d.map_int_CNode_rbegin(self)


    def rend(self) -> "std::map< int,std::vector< CNode > >::reverse_iterator":
        """rend(map_int_CNode self) -> std::map< int,std::vector< CNode > >::reverse_iterator"""
        return _sim2d.map_int_CNode_rend(self)


    def count(self, x: 'std::map< int,std::vector< CNode > >::key_type const &') -> "std::map< int,std::vector< CNode > >::size_type":
        """count(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & x) -> std::map< int,std::vector< CNode > >::size_type"""
        return _sim2d.map_int_CNode_count(self, x)


    def erase(self, *args) -> "void":
        """
        erase(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & x) -> std::map< int,std::vector< CNode > >::size_type
        erase(map_int_CNode self, std::map< int,std::vector< CNode > >::iterator position)
        erase(map_int_CNode self, std::map< int,std::vector< CNode > >::iterator first, std::map< int,std::vector< CNode > >::iterator last)
        """
        return _sim2d.map_int_CNode_erase(self, *args)


    def find(self, x: 'std::map< int,std::vector< CNode > >::key_type const &') -> "std::map< int,std::vector< CNode > >::iterator":
        """find(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & x) -> std::map< int,std::vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_find(self, x)


    def lower_bound(self, x: 'std::map< int,std::vector< CNode > >::key_type const &') -> "std::map< int,std::vector< CNode > >::iterator":
        """lower_bound(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & x) -> std::map< int,std::vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_lower_bound(self, x)


    def upper_bound(self, x: 'std::map< int,std::vector< CNode > >::key_type const &') -> "std::map< int,std::vector< CNode > >::iterator":
        """upper_bound(map_int_CNode self, std::map< int,std::vector< CNode > >::key_type const & x) -> std::map< int,std::vector< CNode > >::iterator"""
        return _sim2d.map_int_CNode_upper_bound(self, x)

    __swig_destroy__ = _sim2d.delete_map_int_CNode
    __del__ = lambda self: None
map_int_CNode_swigregister = _sim2d.map_int_CNode_swigregister
map_int_CNode_swigregister(map_int_CNode)


_sim2d.NDIM_swigconstant(_sim2d)
NDIM = _sim2d.NDIM

def vec(*args) -> "Vec3":
    """
    vec() -> Vec
    vec(double x, double y) -> Vec2
    vec(double x, double y, double z) -> Vec3
    """
    return _sim2d.vec(*args)

def cross(*args) -> "Vec2":
    """
    cross(Vec3 v1, Vec3 v2) -> Vec3
    cross(Vec2 v1, Vec2 v2) -> flt
    cross(Vec2 v, flt n) -> Vec2
    """
    return _sim2d.cross(*args)

def perp(v: 'Vec2') -> "Vec2":
    """perp(Vec2 v) -> Vec2"""
    return _sim2d.perp(v)

def perpto(r: 'Vec', to: 'Vec') -> "Vec":
    """perpto(Vec r, Vec to) -> Vec"""
    return _sim2d.perpto(r, to)

def rotate(v: 'Vec2', i: 'uint') -> "Vec2":
    """rotate(Vec2 v, uint i) -> Vec2"""
    return _sim2d.rotate(v, i)

def flip(v: 'Vec2') -> "Vec2":
    """flip(Vec2 v) -> Vec2"""
    return _sim2d.flip(v)

def rotate_flip(v: 'Vec2', i: 'uint') -> "Vec2":
    """rotate_flip(Vec2 v, uint i) -> Vec2"""
    return _sim2d.rotate_flip(v, i)

def rotate_flip_inv(v: 'Vec2', i: 'uint') -> "Vec2":
    """rotate_flip_inv(Vec2 v, uint i) -> Vec2"""
    return _sim2d.rotate_flip_inv(v, i)

def vecsize() -> "uint":
    """vecsize() -> uint"""
    return _sim2d.vecsize()

def rand01() -> "flt":
    """rand01() -> flt"""
    return _sim2d.rand01()

def randVec() -> "Vec":
    """randVec() -> Vec"""
    return _sim2d.randVec()

def randVecBoxed() -> "Vec":
    """randVecBoxed() -> Vec"""
    return _sim2d.randVecBoxed()

def seed(*args) -> "unsigned int":
    """
    seed(unsigned int n) -> unsigned int
    seed() -> unsigned int
    """
    return _sim2d.seed(*args)
class gaussVec(_object):
    """Proxy of C++ gaussVec class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, gaussVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, gaussVec, name)
    __repr__ = _swig_repr

    def __init__(self, sigma: 'flt'):
        """__init__(gaussVec self, flt sigma) -> gaussVec"""
        this = _sim2d.new_gaussVec(sigma)
        try:
            self.this.append(this)
        except:
            self.this = this

    def set(self, sigma: 'flt') -> "void":
        """set(gaussVec self, flt sigma)"""
        return _sim2d.gaussVec_set(self, sigma)


    def generate(self) -> "Vec":
        """generate(gaussVec self) -> Vec"""
        return _sim2d.gaussVec_generate(self)

    __swig_destroy__ = _sim2d.delete_gaussVec
    __del__ = lambda self: None
gaussVec_swigregister = _sim2d.gaussVec_swigregister
gaussVec_swigregister(gaussVec)
cvar = _sim2d.cvar
OVERNDIM = cvar.OVERNDIM

class bivariateGauss(_object):
    """Proxy of C++ bivariateGauss class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bivariateGauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bivariateGauss, name)
    __repr__ = _swig_repr

    def __init__(self, s1: 'flt const'=1, s2: 'flt const'=1, corr: 'flt const'=0):
        """
        __init__(bivariateGauss self, flt const s1=1, flt const s2=1, flt const corr=0) -> bivariateGauss
        __init__(bivariateGauss self, flt const s1=1, flt const s2=1) -> bivariateGauss
        __init__(bivariateGauss self, flt const s1=1) -> bivariateGauss
        __init__(bivariateGauss self) -> bivariateGauss
        """
        this = _sim2d.new_bivariateGauss(s1, s2, corr)
        try:
            self.this.append(this)
        except:
            self.this = this

    def set(self, s1: 'flt const', s2: 'flt const', corr: 'flt const') -> "void":
        """set(bivariateGauss self, flt const s1, flt const s2, flt const corr)"""
        return _sim2d.bivariateGauss_set(self, s1, s2, corr)


    def generate(self) -> "Eigen::Matrix< flt,1,2 >":
        """generate(bivariateGauss self) -> Eigen::Matrix< flt,1,2 >"""
        return _sim2d.bivariateGauss_generate(self)


    def genVec(self) -> "Vec":
        """genVec(bivariateGauss self) -> Vec"""
        return _sim2d.bivariateGauss_genVec(self)


    def genVecs(self) -> "VecPair":
        """genVecs(bivariateGauss self) -> VecPair"""
        return _sim2d.bivariateGauss_genVecs(self)

    __swig_destroy__ = _sim2d.delete_bivariateGauss
    __del__ = lambda self: None
bivariateGauss_swigregister = _sim2d.bivariateGauss_swigregister
bivariateGauss_swigregister(bivariateGauss)


def toLD(e: 'double') -> "long double":
    """toLD(double e) -> long double"""
    return _sim2d.toLD(e)

def fromLD(e: 'long double') -> "double":
    """fromLD(long double e) -> double"""
    return _sim2d.fromLD(e)

def LDVector(dists: 'dvector') -> "std::vector< long double,std::allocator< long double > >":
    """LDVector(dvector dists) -> ldvector"""
    return _sim2d.LDVector(dists)

def toBuffer(arr: 'std::vector< Vec *,std::allocator< Vec * > >', buffer: 'double *') -> "bool":
    """toBuffer(std::vector< Vec *,std::allocator< Vec * > > arr, double * buffer) -> bool"""
    return _sim2d.toBuffer(arr, buffer)
class Box(_object):
    """Proxy of C++ Box class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Box, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Box, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def diff(self, r1: 'Vec', r2: 'Vec') -> "Vec":
        """diff(Box self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.Box_diff(self, r1, r2)


    def V(self) -> "flt":
        """V(Box self) -> flt"""
        return _sim2d.Box_V(self)

    __swig_destroy__ = _sim2d.delete_Box
    __del__ = lambda self: None
Box_swigregister = _sim2d.Box_swigregister
Box_swigregister(Box)


def vecmod(r1: 'Vec', r2: 'Vec') -> "Vec":
    """vecmod(Vec r1, Vec r2) -> Vec"""
    return _sim2d.vecmod(r1, r2)
class InfiniteBox(Box):
    """Proxy of C++ InfiniteBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfiniteBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfiniteBox, name)
    __repr__ = _swig_repr

    def diff(self, r1: 'Vec', r2: 'Vec') -> "Vec":
        """diff(InfiniteBox self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.InfiniteBox_diff(self, r1, r2)


    def V(self) -> "flt":
        """V(InfiniteBox self) -> flt"""
        return _sim2d.InfiniteBox_V(self)


    def __init__(self):
        """__init__(InfiniteBox self) -> InfiniteBox"""
        this = _sim2d.new_InfiniteBox()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_InfiniteBox
    __del__ = lambda self: None
InfiniteBox_swigregister = _sim2d.InfiniteBox_swigregister
InfiniteBox_swigregister(InfiniteBox)

class OriginBox(Box):
    """Proxy of C++ OriginBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OriginBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OriginBox, name)
    __repr__ = _swig_repr

    def diff(self, *args) -> "Vec":
        """
        diff(OriginBox self, Vec r1, Vec r2) -> Vec
        diff(OriginBox self, Vec r1, Vec r2, array< int,2 > boxes) -> Vec
        """
        return _sim2d.OriginBox_diff(self, *args)


    def box_round(self, r1: 'Vec', r2: 'Vec') -> "array< int,2 >":
        """box_round(OriginBox self, Vec r1, Vec r2) -> array< int,2 >"""
        return _sim2d.OriginBox_box_round(self, r1, r2)


    def __init__(self, *args):
        """
        __init__(OriginBox self, Vec size) -> OriginBox
        __init__(OriginBox self, flt L) -> OriginBox
        """
        this = _sim2d.new_OriginBox(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def V(self) -> "flt":
        """V(OriginBox self) -> flt"""
        return _sim2d.OriginBox_V(self)


    def L(self) -> "flt":
        """L(OriginBox self) -> flt"""
        return _sim2d.OriginBox_L(self)


    def resize(self, *args) -> "flt":
        """
        resize(OriginBox self, flt factor) -> flt
        resize(OriginBox self, Vec newsize) -> flt
        """
        return _sim2d.OriginBox_resize(self, *args)


    def resizeV(self, newV: 'flt') -> "flt":
        """resizeV(OriginBox self, flt newV) -> flt"""
        return _sim2d.OriginBox_resizeV(self, newV)


    def resizeL(self, newL: 'flt') -> "flt":
        """resizeL(OriginBox self, flt newL) -> flt"""
        return _sim2d.OriginBox_resizeL(self, newL)


    def randLoc(self) -> "Vec":
        """randLoc(OriginBox self) -> Vec"""
        return _sim2d.OriginBox_randLoc(self)


    def boxshape(self) -> "Vec":
        """boxshape(OriginBox self) -> Vec"""
        return _sim2d.OriginBox_boxshape(self)

    __swig_destroy__ = _sim2d.delete_OriginBox
    __del__ = lambda self: None
OriginBox_swigregister = _sim2d.OriginBox_swigregister
OriginBox_swigregister(OriginBox)

class LeesEdwardsBox(OriginBox):
    """Proxy of C++ LeesEdwardsBox class"""
    __swig_setmethods__ = {}
    for _s in [OriginBox]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LeesEdwardsBox, name, value)
    __swig_getmethods__ = {}
    for _s in [OriginBox]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LeesEdwardsBox, name)
    __repr__ = _swig_repr

    def __init__(self, size: 'Vec', gamma: 'flt'=0.0):
        """
        __init__(LeesEdwardsBox self, Vec size, flt gamma=0.0) -> LeesEdwardsBox
        __init__(LeesEdwardsBox self, Vec size) -> LeesEdwardsBox
        """
        this = _sim2d.new_LeesEdwardsBox(size, gamma)
        try:
            self.this.append(this)
        except:
            self.this = this

    def diff(self, *args) -> "Vec":
        """
        diff(LeesEdwardsBox self, Vec r1, Vec r2) -> Vec
        diff(LeesEdwardsBox self, Vec r1, Vec r2, array< int,2 > boxes) -> Vec
        """
        return _sim2d.LeesEdwardsBox_diff(self, *args)


    def box_round(self, r1: 'Vec', r2: 'Vec') -> "array< int,2 >":
        """box_round(LeesEdwardsBox self, Vec r1, Vec r2) -> array< int,2 >"""
        return _sim2d.LeesEdwardsBox_box_round(self, r1, r2)


    def get_gamma(self) -> "flt":
        """get_gamma(LeesEdwardsBox self) -> flt"""
        return _sim2d.LeesEdwardsBox_get_gamma(self)


    def shear(self, dgamma: 'flt', atoms: 'atomgroup') -> "void":
        """shear(LeesEdwardsBox self, flt dgamma, atomgroup atoms)"""
        return _sim2d.LeesEdwardsBox_shear(self, dgamma, atoms)


    def nonaffine(self, v: 'Vec') -> "Vec":
        """nonaffine(LeesEdwardsBox self, Vec v) -> Vec"""
        return _sim2d.LeesEdwardsBox_nonaffine(self, v)


    def affine(self, v: 'Vec') -> "Vec":
        """affine(LeesEdwardsBox self, Vec v) -> Vec"""
        return _sim2d.LeesEdwardsBox_affine(self, v)

    __swig_destroy__ = _sim2d.delete_LeesEdwardsBox
    __del__ = lambda self: None
LeesEdwardsBox_swigregister = _sim2d.LeesEdwardsBox_swigregister
LeesEdwardsBox_swigregister(LeesEdwardsBox)

class SCbox(Box):
    """Proxy of C++ SCbox class"""
    __swig_setmethods__ = {}
    for _s in [Box]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCbox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCbox, name)
    __repr__ = _swig_repr

    def __init__(self, L: 'flt', R: 'flt'):
        """__init__(SCbox self, flt L, flt R) -> SCbox"""
        this = _sim2d.new_SCbox(L, R)
        try:
            self.this.append(this)
        except:
            self.this = this

    def diff(self, r1: 'Vec', r2: 'Vec') -> "Vec":
        """diff(SCbox self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.SCbox_diff(self, r1, r2)


    def V(self) -> "flt":
        """V(SCbox self) -> flt"""
        return _sim2d.SCbox_V(self)


    def dist(self, r1: 'Vec') -> "Vec":
        """dist(SCbox self, Vec r1) -> Vec"""
        return _sim2d.SCbox_dist(self, r1)


    def edgedist(self, r1: 'Vec') -> "Vec":
        """edgedist(SCbox self, Vec r1) -> Vec"""
        return _sim2d.SCbox_edgedist(self, r1)


    def inside(self, r1: 'Vec', buffer: 'flt'=0.0) -> "bool":
        """
        inside(SCbox self, Vec r1, flt buffer=0.0) -> bool
        inside(SCbox self, Vec r1) -> bool
        """
        return _sim2d.SCbox_inside(self, r1, buffer)


    def randLoc(self, min_dist_to_wall: 'flt'=0.0) -> "Vec":
        """
        randLoc(SCbox self, flt min_dist_to_wall=0.0) -> Vec
        randLoc(SCbox self) -> Vec
        """
        return _sim2d.SCbox_randLoc(self, min_dist_to_wall)


    def length(self) -> "flt":
        """length(SCbox self) -> flt"""
        return _sim2d.SCbox_length(self)


    def radius(self) -> "flt":
        """radius(SCbox self) -> flt"""
        return _sim2d.SCbox_radius(self)

    __swig_destroy__ = _sim2d.delete_SCbox
    __del__ = lambda self: None
SCbox_swigregister = _sim2d.SCbox_swigregister
SCbox_swigregister(SCbox)

class atom(_object):
    """Proxy of C++ atom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _sim2d.atom_x_set
    __swig_getmethods__["x"] = _sim2d.atom_x_get
    if _newclass:
        x = _swig_property(_sim2d.atom_x_get, _sim2d.atom_x_set)
    __swig_setmethods__["v"] = _sim2d.atom_v_set
    __swig_getmethods__["v"] = _sim2d.atom_v_get
    if _newclass:
        v = _swig_property(_sim2d.atom_v_get, _sim2d.atom_v_set)
    __swig_setmethods__["a"] = _sim2d.atom_a_set
    __swig_getmethods__["a"] = _sim2d.atom_a_get
    if _newclass:
        a = _swig_property(_sim2d.atom_a_get, _sim2d.atom_a_set)
    __swig_setmethods__["f"] = _sim2d.atom_f_set
    __swig_getmethods__["f"] = _sim2d.atom_f_get
    if _newclass:
        f = _swig_property(_sim2d.atom_f_get, _sim2d.atom_f_set)
    __swig_setmethods__["m"] = _sim2d.atom_m_set
    __swig_getmethods__["m"] = _sim2d.atom_m_get
    if _newclass:
        m = _swig_property(_sim2d.atom_m_get, _sim2d.atom_m_set)

    def __getstate__(self):
        return (tuple(self.x),tuple(self.v),tuple(self.f), tuple(self.a))

    def __setstate__(self, lst):
        self.x, self.v, self.f, self.a = [Vec(*r) for r in lst]

    def __str__(self):
        if hasattr(self, 'name'):
            return "<atom %s>" % self.name
        return "<atom>"

    def __repr__(self):
    #ifdef VEC2D
        x,y = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f)>" % (self.name,x,y)
        return "<atom at (%.2f,%.2f)>" % (x,y)
    #else
        x,y,z = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f,%.2f)>" % (self.name,x,y,z)
        return "<atom at (%.2f,%.2f,%.2f)>" % (x,y,z)
    #endif


    def __init__(self):
        """__init__(atom self) -> atom"""
        this = _sim2d.new_atom()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_atom
    __del__ = lambda self: None
atom_swigregister = _sim2d.atom_swigregister
atom_swigregister(atom)

class atomref(_object):
    """Proxy of C++ atomref class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomref, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomref, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(atomref self) -> atomref
        __init__(atomref self, atom a) -> atomref
        """
        this = _sim2d.new_atomref(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __ref__(self) -> "atom &":
        """__ref__(atomref self) -> atom"""
        return _sim2d.atomref___ref__(self)


    def __deref__(self) -> "atom *":
        """__deref__(atomref self) -> atom"""
        return _sim2d.atomref___deref__(self)


    def __eq__(self, *args) -> "bool":
        """
        __eq__(atomref self, atomref other) -> bool
        __eq__(atomref self, atom other) -> bool
        """
        return _sim2d.atomref___eq__(self, *args)


    def __ne__(self, other: 'atomref') -> "bool":
        """__ne__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___ne__(self, other)


    def __lt__(self, other: 'atomref') -> "bool":
        """__lt__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___lt__(self, other)


    def __le__(self, other: 'atomref') -> "bool":
        """__le__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___le__(self, other)


    def __ge__(self, other: 'atomref') -> "bool":
        """__ge__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___ge__(self, other)


    def __gt__(self, other: 'atomref') -> "bool":
        """__gt__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___gt__(self, other)


    def is_null(self) -> "bool":
        """is_null(atomref self) -> bool"""
        return _sim2d.atomref_is_null(self)

    __swig_destroy__ = _sim2d.delete_atomref
    __del__ = lambda self: None
    __swig_setmethods__["x"] = _sim2d.atomref_x_set
    __swig_getmethods__["x"] = _sim2d.atomref_x_get
    if _newclass:
        x = _swig_property(_sim2d.atomref_x_get, _sim2d.atomref_x_set)
    __swig_setmethods__["v"] = _sim2d.atomref_v_set
    __swig_getmethods__["v"] = _sim2d.atomref_v_get
    if _newclass:
        v = _swig_property(_sim2d.atomref_v_get, _sim2d.atomref_v_set)
    __swig_setmethods__["a"] = _sim2d.atomref_a_set
    __swig_getmethods__["a"] = _sim2d.atomref_a_get
    if _newclass:
        a = _swig_property(_sim2d.atomref_a_get, _sim2d.atomref_a_set)
    __swig_setmethods__["f"] = _sim2d.atomref_f_set
    __swig_getmethods__["f"] = _sim2d.atomref_f_get
    if _newclass:
        f = _swig_property(_sim2d.atomref_f_get, _sim2d.atomref_f_set)
    __swig_setmethods__["m"] = _sim2d.atomref_m_set
    __swig_getmethods__["m"] = _sim2d.atomref_m_get
    if _newclass:
        m = _swig_property(_sim2d.atomref_m_get, _sim2d.atomref_m_set)
atomref_swigregister = _sim2d.atomref_swigregister
atomref_swigregister(atomref)

class atomid(atomref):
    """Proxy of C++ atomid class"""
    __swig_setmethods__ = {}
    for _s in [atomref]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomid, name, value)
    __swig_getmethods__ = {}
    for _s in [atomref]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomid, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(atomid self) -> atomid
        __init__(atomid self, atom a, uint n) -> atomid
        """
        this = _sim2d.new_atomid(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def n(self) -> "uint":
        """n(atomid self) -> uint"""
        return _sim2d.atomid_n(self)


    def __str__(self):
        return "<atomid %s>" % self.n()

    def __repr__(self):
    #ifdef VEC2D
        x,y = tuple(self.x)
        return "<atomid %s at (%.2f,%.2f)>" % (self.n(),x,y)
    #else
        x,y,z = tuple(self.x)
        return "<atomid %s at (%.2f,%.2f,%.2f)>" % (self.n(),x,y,z)
    #endif

    __swig_destroy__ = _sim2d.delete_atomid
    __del__ = lambda self: None
atomid_swigregister = _sim2d.atomid_swigregister
atomid_swigregister(atomid)

class idpair(_object):
    """Proxy of C++ idpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, idpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, idpair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(idpair self) -> idpair
        __init__(idpair self, atomid a, atomid b) -> idpair
        """
        this = _sim2d.new_idpair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def first(self) -> "atomid":
        """first(idpair self) -> atomid"""
        return _sim2d.idpair_first(self)


    def last(self) -> "atomid":
        """last(idpair self) -> atomid"""
        return _sim2d.idpair_last(self)


    def __iter__(self):
        return iter((self.first(), self.last()))

    __swig_destroy__ = _sim2d.delete_idpair
    __del__ = lambda self: None
idpair_swigregister = _sim2d.idpair_swigregister
idpair_swigregister(idpair)

class atomgroup(_object):
    """Proxy of C++ atomgroup class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomgroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomgroup, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def vec(self) -> "atomvec &":
        """vec(atomgroup self) -> atomvec"""
        return _sim2d.atomgroup_vec(self)


    def get(self, n: 'cuint') -> "atom &":
        """get(atomgroup self, cuint n) -> atom"""
        return _sim2d.atomgroup_get(self, n)


    def get_id(self, n: 'cuint') -> "atomid":
        """get_id(atomgroup self, cuint n) -> atomid"""
        return _sim2d.atomgroup_get_id(self, n)


    def size(self) -> "uint":
        """size(atomgroup self) -> uint"""
        return _sim2d.atomgroup_size(self)


    def begin(self) -> "AtomIter":
        """begin(atomgroup self) -> AtomIter"""
        return _sim2d.atomgroup_begin(self)


    def end(self) -> "AtomIter":
        """end(atomgroup self) -> AtomIter"""
        return _sim2d.atomgroup_end(self)


    def com(self) -> "Vec":
        """com(atomgroup self) -> Vec"""
        return _sim2d.atomgroup_com(self)


    def comv(self) -> "Vec":
        """comv(atomgroup self) -> Vec"""
        return _sim2d.atomgroup_comv(self)


    def comf(self) -> "Vec":
        """comf(atomgroup self) -> Vec"""
        return _sim2d.atomgroup_comf(self)


    def mass(self) -> "flt":
        """mass(atomgroup self) -> flt"""
        return _sim2d.atomgroup_mass(self)


    def kinetic(self, *args) -> "flt":
        """
        kinetic(atomgroup self, Vec const & originvelocity) -> flt
        kinetic(atomgroup self) -> flt
        """
        return _sim2d.atomgroup_kinetic(self, *args)


    def momentum(self) -> "Vec":
        """momentum(atomgroup self) -> Vec"""
        return _sim2d.atomgroup_momentum(self)


    def gyradius(self) -> "flt":
        """gyradius(atomgroup self) -> flt"""
        return _sim2d.atomgroup_gyradius(self)


    def moment(self, loc: 'Vec const &') -> "flt":
        """moment(atomgroup self, Vec const & loc) -> flt"""
        return _sim2d.atomgroup_moment(self, loc)


    def angmomentum(self, loc: 'Vec const &') -> "flt":
        """angmomentum(atomgroup self, Vec const & loc) -> flt"""
        return _sim2d.atomgroup_angmomentum(self, loc)


    def torque(self, loc: 'Vec const &') -> "flt":
        """torque(atomgroup self, Vec const & loc) -> flt"""
        return _sim2d.atomgroup_torque(self, loc)


    def omega(self, loc: 'Vec const &') -> "flt":
        """omega(atomgroup self, Vec const & loc) -> flt"""
        return _sim2d.atomgroup_omega(self, loc)


    def addOmega(self, w: 'flt', origin: 'Vec') -> "void":
        """addOmega(atomgroup self, flt w, Vec origin)"""
        return _sim2d.atomgroup_addOmega(self, w, origin)


    def resetL(self) -> "void":
        """resetL(atomgroup self)"""
        return _sim2d.atomgroup_resetL(self)


    def addv(self, v: 'Vec') -> "void":
        """addv(atomgroup self, Vec v)"""
        return _sim2d.atomgroup_addv(self, v)


    def resetcomv(self) -> "void":
        """resetcomv(atomgroup self)"""
        return _sim2d.atomgroup_resetcomv(self)


    def randomize_velocities(self, T: 'flt') -> "void":
        """randomize_velocities(atomgroup self, flt T)"""
        return _sim2d.atomgroup_randomize_velocities(self, T)


    def resetForces(self) -> "void":
        """resetForces(atomgroup self)"""
        return _sim2d.atomgroup_resetForces(self)

    __swig_destroy__ = _sim2d.delete_atomgroup
    __del__ = lambda self: None

    def __iter__(self):
        for i in range(self.size()):
            yield self.get_id(i)

atomgroup_swigregister = _sim2d.atomgroup_swigregister
atomgroup_swigregister(atomgroup)

class atomvec(atomgroup):
    """Proxy of C++ atomvec class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomvec, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomvec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(atomvec self, dvector masses) -> atomvec
        __init__(atomvec self, uint N, flt mass) -> atomvec
        __init__(atomvec self, atomvec other) -> atomvec
        """
        this = _sim2d.new_atomvec(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def vec(self) -> "atomvec &":
        """vec(atomvec self) -> atomvec"""
        return _sim2d.atomvec_vec(self)


    def get_id(self, n: 'cuint') -> "atomid":
        """get_id(atomvec self, cuint n) -> atomid"""
        return _sim2d.atomvec_get_id(self, n)


    def size(self) -> "uint":
        """size(atomvec self) -> uint"""
        return _sim2d.atomvec_size(self)

    __swig_destroy__ = _sim2d.delete_atomvec
    __del__ = lambda self: None

    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def __len__(self):
        return self.size()

    def __getitem__(self, obj):
        return self.get_id(obj)

    #def __setitem__(self, obj, val):
    #    return self.set(obj, val)

    def __getstate__(self):
        return ([self.getmass(i) for i in range(self.N())],
                    [a.__getstate__() for a in self])

    def __setstate__(self, lst):
        masses, atomstates = lst
        self.__init__(fvector(masses))
        for i, atomstate in enumerate(atomstates):
    #~ print "i:",i
            a = self.get(i)
            a.__setstate__(atomstate)

atomvec_swigregister = _sim2d.atomvec_swigregister
atomvec_swigregister(atomvec)

class subgroup(atomgroup):
    """Proxy of C++ subgroup class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, subgroup, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, subgroup, name)
    __repr__ = _swig_repr

    def __init__(self, atoms: 'boost::shared_ptr< atomvec >'):
        """__init__(subgroup self, boost::shared_ptr< atomvec > atoms) -> subgroup"""
        this = _sim2d.new_subgroup(atoms)
        try:
            self.this.append(this)
        except:
            self.this = this

    def vec(self) -> "atomvec &":
        """vec(subgroup self) -> atomvec"""
        return _sim2d.subgroup_vec(self)


    def get(self, n: 'cuint') -> "atom &":
        """get(subgroup self, cuint n) -> atom"""
        return _sim2d.subgroup_get(self, n)


    def add(self, a: 'atomid') -> "void":
        """add(subgroup self, atomid a)"""
        return _sim2d.subgroup_add(self, a)


    def get_id(self, n: 'cuint') -> "atomid":
        """get_id(subgroup self, cuint n) -> atomid"""
        return _sim2d.subgroup_get_id(self, n)


    def size(self) -> "uint":
        """size(subgroup self) -> uint"""
        return _sim2d.subgroup_size(self)

    __swig_destroy__ = _sim2d.delete_subgroup
    __del__ = lambda self: None
subgroup_swigregister = _sim2d.subgroup_swigregister
subgroup_swigregister(subgroup)

class statetracker(_object):
    """Proxy of C++ statetracker class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, statetracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, statetracker, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def update(self, box: 'Box') -> "void":
        """update(statetracker self, Box box)"""
        return _sim2d.statetracker_update(self, box)

    __swig_destroy__ = _sim2d.delete_statetracker
    __del__ = lambda self: None
statetracker_swigregister = _sim2d.statetracker_swigregister
statetracker_swigregister(statetracker)

class pairlist(_object):
    """Proxy of C++ pairlist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pairlist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pairlist, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(pairlist self) -> pairlist"""
        this = _sim2d.new_pairlist()
        try:
            self.this.append(this)
        except:
            self.this = this

    def ensure(self, *args) -> "void":
        """
        ensure(pairlist self, atomid a)
        ensure(pairlist self, idvector ps)
        ensure(pairlist self, atomgroup group)
        """
        return _sim2d.pairlist_ensure(self, *args)


    def has_pair(self, a1: 'atomid', a2: 'atomid') -> "bool":
        """has_pair(pairlist self, atomid a1, atomid a2) -> bool"""
        return _sim2d.pairlist_has_pair(self, a1, a2)


    def add_pair(self, a1: 'atomid', a2: 'atomid') -> "void":
        """add_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim2d.pairlist_add_pair(self, a1, a2)


    def erase_pair(self, a1: 'atomid', a2: 'atomid') -> "void":
        """erase_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim2d.pairlist_erase_pair(self, a1, a2)


    def get_pairs(self, a: 'atomid') -> "std::set< atomid >":
        """get_pairs(pairlist self, atomid a) -> std::set< atomid >"""
        return _sim2d.pairlist_get_pairs(self, a)


    def begin(self, a: 'atomid') -> "std::set< atomid,std::less< atomid >,std::allocator< atomid > >::iterator":
        """begin(pairlist self, atomid a) -> std::set< atomid,std::less< atomid >,std::allocator< atomid > >::iterator"""
        return _sim2d.pairlist_begin(self, a)


    def end(self, a: 'atomid') -> "std::set< atomid,std::less< atomid >,std::allocator< atomid > >::iterator":
        """end(pairlist self, atomid a) -> std::set< atomid,std::less< atomid >,std::allocator< atomid > >::iterator"""
        return _sim2d.pairlist_end(self, a)


    def size(self) -> "uint":
        """size(pairlist self) -> uint"""
        return _sim2d.pairlist_size(self)


    def clear(self) -> "void":
        """clear(pairlist self)"""
        return _sim2d.pairlist_clear(self)

    __swig_destroy__ = _sim2d.delete_pairlist
    __del__ = lambda self: None
pairlist_swigregister = _sim2d.pairlist_swigregister
pairlist_swigregister(pairlist)

class neighborlist(statetracker):
    """Proxy of C++ neighborlist class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, neighborlist, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, neighborlist, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', atoms: 'boost::shared_ptr< atomvec >', skin: 'flt const'):
        """__init__(neighborlist self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atoms, flt const skin) -> neighborlist"""
        this = _sim2d.new_neighborlist(box, atoms, skin)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update(self, newbox: 'Box') -> "void":
        """update(neighborlist self, Box newbox)"""
        return _sim2d.neighborlist_update(self, newbox)


    def update_list(self, force: 'bool'=True) -> "bool":
        """
        update_list(neighborlist self, bool force=True) -> bool
        update_list(neighborlist self) -> bool
        """
        return _sim2d.neighborlist_update_list(self, force)


    def vec(self) -> "atomvec &":
        """vec(neighborlist self) -> atomvec"""
        return _sim2d.neighborlist_vec(self)


    def which(self) -> "uint":
        """which(neighborlist self) -> uint"""
        return _sim2d.neighborlist_which(self)


    def numpairs(self) -> "uint":
        """numpairs(neighborlist self) -> uint"""
        return _sim2d.neighborlist_numpairs(self)


    def ignore(self, a: 'atomid', b: 'atomid') -> "void":
        """ignore(neighborlist self, atomid a, atomid b)"""
        return _sim2d.neighborlist_ignore(self, a, b)


    def add(self, a: 'atomid', diameter: 'flt') -> "void":
        """add(neighborlist self, atomid a, flt diameter)"""
        return _sim2d.neighborlist_add(self, a, diameter)


    def ignore_size(self) -> "uint":
        """ignore_size(neighborlist self) -> uint"""
        return _sim2d.neighborlist_ignore_size(self)


    def size(self) -> "uint":
        """size(neighborlist self) -> uint"""
        return _sim2d.neighborlist_size(self)


    def begin(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator":
        """begin(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim2d.neighborlist_begin(self)


    def end(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator":
        """end(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim2d.neighborlist_end(self)


    def get(self, i: 'uint') -> "idpair":
        """get(neighborlist self, uint i) -> idpair"""
        return _sim2d.neighborlist_get(self, i)

    __swig_destroy__ = _sim2d.delete_neighborlist
    __del__ = lambda self: None

    def __getitem__(self, i: 'size_t') -> "idpair":
        """__getitem__(neighborlist self, size_t i) -> idpair"""
        return _sim2d.neighborlist___getitem__(self, i)


    def __iter__(self):
        for i in range(self.numpairs()):
            yield self[i]

neighborlist_swigregister = _sim2d.neighborlist_swigregister
neighborlist_swigregister(neighborlist)

class Grid(_object):
    """Proxy of C++ Grid class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Grid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Grid, name)
    __repr__ = _swig_repr
    __swig_setmethods__["box"] = _sim2d.Grid_box_set
    __swig_getmethods__["box"] = _sim2d.Grid_box_get
    if _newclass:
        box = _swig_property(_sim2d.Grid_box_get, _sim2d.Grid_box_set)
    __swig_setmethods__["atoms"] = _sim2d.Grid_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.Grid_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.Grid_atoms_get, _sim2d.Grid_atoms_set)
    __swig_setmethods__["minwidth"] = _sim2d.Grid_minwidth_set
    __swig_getmethods__["minwidth"] = _sim2d.Grid_minwidth_get
    if _newclass:
        minwidth = _swig_property(_sim2d.Grid_minwidth_get, _sim2d.Grid_minwidth_set)
    __swig_setmethods__["goalwidth"] = _sim2d.Grid_goalwidth_set
    __swig_getmethods__["goalwidth"] = _sim2d.Grid_goalwidth_get
    if _newclass:
        goalwidth = _swig_property(_sim2d.Grid_goalwidth_get, _sim2d.Grid_goalwidth_set)
    __swig_setmethods__["widths"] = _sim2d.Grid_widths_set
    __swig_getmethods__["widths"] = _sim2d.Grid_widths_get
    if _newclass:
        widths = _swig_property(_sim2d.Grid_widths_get, _sim2d.Grid_widths_set)
    __swig_setmethods__["gridlocs"] = _sim2d.Grid_gridlocs_set
    __swig_getmethods__["gridlocs"] = _sim2d.Grid_gridlocs_get
    if _newclass:
        gridlocs = _swig_property(_sim2d.Grid_gridlocs_get, _sim2d.Grid_gridlocs_set)

    def neighbors(self, i: 'uint') -> "std::vector< uint >":
        """neighbors(Grid self, uint i) -> uintvector"""
        return _sim2d.Grid_neighbors(self, i)


    def get_loc(self, v: 'Vec', bsize: 'Vec') -> "uint":
        """get_loc(Grid self, Vec v, Vec bsize) -> uint"""
        return _sim2d.Grid_get_loc(self, v, bsize)


    def __init__(self, *args):
        """
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, uint const width=1) -> Grid
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms) -> Grid
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, uintvector width) -> Grid
        __init__(Grid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const minwidth, flt const goalwidth) -> Grid
        """
        this = _sim2d.new_Grid(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def optimize_widths(self) -> "void":
        """optimize_widths(Grid self)"""
        return _sim2d.Grid_optimize_widths(self)


    def make_grid(self) -> "void":
        """make_grid(Grid self)"""
        return _sim2d.Grid_make_grid(self)


    def begin(self) -> "Grid::iterator":
        """begin(Grid self) -> GridIterator"""
        return _sim2d.Grid_begin(self)


    def end(self) -> "Grid::iterator":
        """end(Grid self) -> GridIterator"""
        return _sim2d.Grid_end(self)


    def pairs(self, a: 'atomid') -> "Grid::pair_iter":
        """pairs(Grid self, atomid a) -> GridPairedIterator"""
        return _sim2d.Grid_pairs(self, a)


    def time_to_edge(self, *args) -> "flt":
        """
        time_to_edge(Grid self, atom a) -> flt
        time_to_edge(Grid self, uint i) -> flt
        """
        return _sim2d.Grid_time_to_edge(self, *args)


    def allpairs(self, *args) -> "std::vector< atomid >":
        """
        allpairs(Grid self) -> idpairvector
        allpairs(Grid self, atomid a) -> idvector
        """
        return _sim2d.Grid_allpairs(self, *args)


    def numcells(self, *args) -> "uint":
        """
        numcells(Grid self, uint i) -> uint
        numcells(Grid self) -> uint
        """
        return _sim2d.Grid_numcells(self, *args)

    __swig_destroy__ = _sim2d.delete_Grid
    __del__ = lambda self: None
Grid_swigregister = _sim2d.Grid_swigregister
Grid_swigregister(Grid)

class GridPairedIterator(_object):
    """Proxy of C++ GridPairedIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridPairedIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GridPairedIterator, name)
    __repr__ = _swig_repr

    def __init__(self, grid: 'Grid', a: 'atomid'):
        """__init__(GridPairedIterator self, Grid grid, atomid a) -> GridPairedIterator"""
        this = _sim2d.new_GridPairedIterator(grid, a)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __ref__(self) -> "atomid":
        """__ref__(GridPairedIterator self) -> atomid"""
        return _sim2d.GridPairedIterator___ref__(self)


    def __eq__(self, *args) -> "bool":
        """
        __eq__(GridPairedIterator self, GridPairedIterator other) -> bool
        __eq__(GridPairedIterator self, GridPairedIterator::end_type const other) -> bool
        """
        return _sim2d.GridPairedIterator___eq__(self, *args)


    def __ne__(self, *args) -> "bool":
        """
        __ne__(GridPairedIterator self, GridPairedIterator other) -> bool
        __ne__(GridPairedIterator self, GridPairedIterator::end_type const other) -> bool
        """
        return _sim2d.GridPairedIterator___ne__(self, *args)


    def end(self) -> "GridPairedIterator::end_type":
        """end(GridPairedIterator self) -> GridPairedIterator::end_type"""
        return _sim2d.GridPairedIterator_end(self)

    __swig_destroy__ = _sim2d.delete_GridPairedIterator
    __del__ = lambda self: None
GridPairedIterator_swigregister = _sim2d.GridPairedIterator_swigregister
GridPairedIterator_swigregister(GridPairedIterator)

class GridIterator(_object):
    """Proxy of C++ GridIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GridIterator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GridIterator self, Grid grid) -> GridIterator
        __init__(GridIterator self, Grid grid, std::vector< std::set< atomid,std::less< atomid >,std::allocator< atomid > >,std::allocator< std::set< atomid,std::less< atomid >,std::allocator< atomid > > > >::iterator cell1) -> GridIterator
        """
        this = _sim2d.new_GridIterator(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __ref__(self) -> "idpair":
        """__ref__(GridIterator self) -> idpair"""
        return _sim2d.GridIterator___ref__(self)


    def __eq__(self, other: 'GridIterator') -> "bool":
        """__eq__(GridIterator self, GridIterator other) -> bool"""
        return _sim2d.GridIterator___eq__(self, other)


    def __ne__(self, other: 'GridIterator') -> "bool":
        """__ne__(GridIterator self, GridIterator other) -> bool"""
        return _sim2d.GridIterator___ne__(self, other)

    __swig_destroy__ = _sim2d.delete_GridIterator
    __del__ = lambda self: None
GridIterator_swigregister = _sim2d.GridIterator_swigregister
GridIterator_swigregister(GridIterator)

class interaction(_object):
    """Proxy of C++ interaction class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interaction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interaction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def energy(self, box: 'Box') -> "flt":
        """energy(interaction self, Box box) -> flt"""
        return _sim2d.interaction_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(interaction self, Box box)"""
        return _sim2d.interaction_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(interaction self, Box box) -> flt"""
        return _sim2d.interaction_setForcesGetPressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(interaction self, Box box) -> flt"""
        return _sim2d.interaction_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_interaction
    __del__ = lambda self: None
interaction_swigregister = _sim2d.interaction_swigregister
interaction_swigregister(interaction)

class interactpair(_object):
    """Proxy of C++ interactpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interactpair, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def energy(self, diff: 'Vec const') -> "flt":
        """energy(interactpair self, Vec const diff) -> flt"""
        return _sim2d.interactpair_energy(self, diff)


    def forces(self, diff: 'Vec const') -> "Vec":
        """forces(interactpair self, Vec const diff) -> Vec"""
        return _sim2d.interactpair_forces(self, diff)

    __swig_destroy__ = _sim2d.delete_interactpair
    __del__ = lambda self: None
interactpair_swigregister = _sim2d.interactpair_swigregister
interactpair_swigregister(interactpair)

class LJrepulsive(_object):
    """Proxy of C++ LJrepulsive class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJrepulsive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJrepulsive, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const'):
        """__init__(LJrepulsive self, flt const epsilon, flt const sigma) -> LJrepulsive"""
        this = _sim2d.new_LJrepulsive(epsilon, sigma)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, *args) -> "flt":
        """
        energy(LJrepulsive self, Vec const diff, flt const eps, flt const sig) -> flt
        energy(LJrepulsive self, Vec const & diff) -> flt
        """
        return _sim2d.LJrepulsive_energy(self, *args)


    def forces(self, *args) -> "Vec":
        """
        forces(LJrepulsive self, Vec const diff, flt const eps, flt const sig) -> Vec
        forces(LJrepulsive self, Vec const & diff) -> Vec
        """
        return _sim2d.LJrepulsive_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJrepulsive
    __del__ = lambda self: None
LJrepulsive_swigregister = _sim2d.LJrepulsive_swigregister
LJrepulsive_swigregister(LJrepulsive)
LJr0 = cvar.LJr0
LJr0sq = cvar.LJr0sq

class LJattract(_object):
    """Proxy of C++ LJattract class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattract, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattract, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const'):
        """__init__(LJattract self, flt const epsilon, flt const sigma) -> LJattract"""
        this = _sim2d.new_LJattract(epsilon, sigma)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, *args) -> "flt":
        """
        energy(LJattract self, Vec const diff, flt const eps, flt const sig) -> flt
        energy(LJattract self, flt const rsig) -> flt
        energy(LJattract self, Vec const & diff) -> flt
        """
        return _sim2d.LJattract_energy(self, *args)


    def forces(self, *args) -> "Vec":
        """
        forces(LJattract self, Vec const diff, flt const eps, flt const sig) -> Vec
        forces(LJattract self, flt const rsig) -> flt
        forces(LJattract self, Vec const & diff) -> Vec
        """
        return _sim2d.LJattract_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJattract
    __del__ = lambda self: None
LJattract_swigregister = _sim2d.LJattract_swigregister
LJattract_swigregister(LJattract)

class LJattractCut(_object):
    """Proxy of C++ LJattractCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattractCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattractCut, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const', cutsig: 'flt const'):
        """__init__(LJattractCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJattractCut"""
        this = _sim2d.new_LJattractCut(epsilon, sigma, cutsig)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, *args) -> "flt":
        """
        energy(LJattractCut self, Vec const diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJattractCut self, Vec const & diff) -> flt
        """
        return _sim2d.LJattractCut_energy(self, *args)


    def forces(self, *args) -> "Vec":
        """
        forces(LJattractCut self, Vec const diff, flt const eps, flt const sig, flt const cutsig) -> Vec
        forces(LJattractCut self, Vec const & diff) -> Vec
        """
        return _sim2d.LJattractCut_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJattractCut
    __del__ = lambda self: None
LJattractCut_swigregister = _sim2d.LJattractCut_swigregister
LJattractCut_swigregister(LJattractCut)

class LJFullCut(_object):
    """Proxy of C++ LJFullCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJFullCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJFullCut, name)
    __repr__ = _swig_repr

    def __init__(self, epsilon: 'flt const', sigma: 'flt const', cutsig: 'flt const'):
        """__init__(LJFullCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJFullCut"""
        this = _sim2d.new_LJFullCut(epsilon, sigma, cutsig)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, diff: 'Vec const &') -> "flt":
        """energy(LJFullCut self, Vec const & diff) -> flt"""
        return _sim2d.LJFullCut_energy(self, diff)


    def forces(self, *args) -> "Vec":
        """
        forces(LJFullCut self, Vec const diff, flt const eps, flt const sig, flt const cutsig) -> Vec
        forces(LJFullCut self, flt const rsig, flt const cutsig) -> flt
        forces(LJFullCut self, Vec const & diff) -> Vec
        """
        return _sim2d.LJFullCut_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJFullCut
    __del__ = lambda self: None
LJFullCut_swigregister = _sim2d.LJFullCut_swigregister
LJFullCut_swigregister(LJFullCut)

class spring(interactpair):
    """Proxy of C++ spring class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, spring, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, spring, name)
    __repr__ = _swig_repr

    def __init__(self, k: 'flt const', x0: 'flt const'):
        """__init__(spring self, flt const k, flt const x0) -> spring"""
        this = _sim2d.new_spring(k, x0)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, diff: 'Vec const') -> "flt":
        """energy(spring self, Vec const diff) -> flt"""
        return _sim2d.spring_energy(self, diff)


    def forces(self, diff: 'Vec const') -> "Vec":
        """forces(spring self, Vec const diff) -> Vec"""
        return _sim2d.spring_forces(self, diff)

    __swig_destroy__ = _sim2d.delete_spring
    __del__ = lambda self: None
spring_swigregister = _sim2d.spring_swigregister
spring_swigregister(spring)

class bondangle(_object):
    """Proxy of C++ bondangle class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondangle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondangle, name)
    __repr__ = _swig_repr

    def __init__(self, k: 'flt const', theta: 'flt const', cosine: 'bool const'=False):
        """
        __init__(bondangle self, flt const k, flt const theta, bool const cosine=False) -> bondangle
        __init__(bondangle self, flt const k, flt const theta) -> bondangle
        """
        this = _sim2d.new_bondangle(k, theta, cosine)
        try:
            self.this.append(this)
        except:
            self.this = this

    def get_angle(r1: 'Vec const &', r2: 'Vec const &') -> "flt":
        """get_angle(Vec const & r1, Vec const & r2) -> flt"""
        return _sim2d.bondangle_get_angle(r1, r2)

    if _newclass:
        get_angle = staticmethod(get_angle)
    __swig_getmethods__["get_angle"] = lambda x: get_angle

    def energy(self, diff1: 'Vec const &', diff2: 'Vec const &') -> "flt":
        """energy(bondangle self, Vec const & diff1, Vec const & diff2) -> flt"""
        return _sim2d.bondangle_energy(self, diff1, diff2)


    def forces(self, diff1: 'Vec const &', diff2: 'Vec const &') -> "array< Vec,3 >":
        """forces(bondangle self, Vec const & diff1, Vec const & diff2) -> array< Vec,3 >"""
        return _sim2d.bondangle_forces(self, diff1, diff2)

    __swig_destroy__ = _sim2d.delete_bondangle
    __del__ = lambda self: None
bondangle_swigregister = _sim2d.bondangle_swigregister
bondangle_swigregister(bondangle)

def bondangle_get_angle(r1: 'Vec const &', r2: 'Vec const &') -> "flt":
    """bondangle_get_angle(Vec const & r1, Vec const & r2) -> flt"""
    return _sim2d.bondangle_get_angle(r1, r2)

class electricScreened(interactpair):
    """Proxy of C++ electricScreened class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, electricScreened, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, electricScreened, name)
    __repr__ = _swig_repr

    def __init__(self, screenLength: 'flt const', q1: 'flt const', q2: 'flt const', cutoff: 'flt const'):
        """__init__(electricScreened self, flt const screenLength, flt const q1, flt const q2, flt const cutoff) -> electricScreened"""
        this = _sim2d.new_electricScreened(screenLength, q1, q2, cutoff)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(*args) -> "flt":
        """
        energy(Vec const r) -> flt
        energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
        energy(flt const r, flt const qaqb, flt const screen) -> flt
        """
        return _sim2d.electricScreened_energy(*args)

    if _newclass:
        energy = staticmethod(energy)
    __swig_getmethods__["energy"] = lambda x: energy

    def forces(*args) -> "Vec":
        """
        forces(Vec const r) -> Vec
        forces(Vec const r, flt const qaqb, flt const screen, flt const cutoff=0) -> Vec
        forces(Vec const r, flt const qaqb, flt const screen) -> Vec
        """
        return _sim2d.electricScreened_forces(*args)

    if _newclass:
        forces = staticmethod(forces)
    __swig_getmethods__["forces"] = lambda x: forces
    __swig_destroy__ = _sim2d.delete_electricScreened
    __del__ = lambda self: None
electricScreened_swigregister = _sim2d.electricScreened_swigregister
electricScreened_swigregister(electricScreened)

def electricScreened_energy(*args) -> "flt":
    """
    energy(Vec const r) -> flt
    energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
    electricScreened_energy(flt const r, flt const qaqb, flt const screen) -> flt
    """
    return _sim2d.electricScreened_energy(*args)

def electricScreened_forces(*args) -> "Vec":
    """
    forces(Vec const r) -> Vec
    forces(Vec const r, flt const qaqb, flt const screen, flt const cutoff=0) -> Vec
    electricScreened_forces(Vec const r, flt const qaqb, flt const screen) -> Vec
    """
    return _sim2d.electricScreened_forces(*args)

class fixedForceAtom(_object):
    """Proxy of C++ fixedForceAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForceAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForceAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["F"] = _sim2d.fixedForceAtom_F_set
    __swig_getmethods__["F"] = _sim2d.fixedForceAtom_F_get
    if _newclass:
        F = _swig_property(_sim2d.fixedForceAtom_F_get, _sim2d.fixedForceAtom_F_set)
    __swig_setmethods__["a"] = _sim2d.fixedForceAtom_a_set
    __swig_getmethods__["a"] = _sim2d.fixedForceAtom_a_get
    if _newclass:
        a = _swig_property(_sim2d.fixedForceAtom_a_get, _sim2d.fixedForceAtom_a_set)

    def __init__(self, F: 'Vec', a: 'atomid'):
        """__init__(fixedForceAtom self, Vec F, atomid a) -> fixedForceAtom"""
        this = _sim2d.new_fixedForceAtom(F, a)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(fixedForceAtom self, Box box) -> flt"""
        return _sim2d.fixedForceAtom_energy(self, box)


    def setForce(self, box: 'Box') -> "void":
        """setForce(fixedForceAtom self, Box box)"""
        return _sim2d.fixedForceAtom_setForce(self, box)

    __swig_destroy__ = _sim2d.delete_fixedForceAtom
    __del__ = lambda self: None
fixedForceAtom_swigregister = _sim2d.fixedForceAtom_swigregister
fixedForceAtom_swigregister(fixedForceAtom)

class fixedForce(interaction):
    """Proxy of C++ fixedForce class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForce, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(fixedForce self, std::vector< fixedForceAtom > atoms) -> fixedForce
        __init__(fixedForce self) -> fixedForce
        """
        this = _sim2d.new_fixedForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(fixedForce self, fixedForceAtom a)
        add(fixedForce self, Vec F, atomid a)
        add(fixedForce self, flt x, flt y, atomid a)
        """
        return _sim2d.fixedForce_add(self, *args)


    def size(self) -> "uint":
        """size(fixedForce self) -> uint"""
        return _sim2d.fixedForce_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(fixedForce self, Box box) -> flt"""
        return _sim2d.fixedForce_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(fixedForce self, Box box)"""
        return _sim2d.fixedForce_setForces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(fixedForce self, Box box) -> flt"""
        return _sim2d.fixedForce_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_fixedForce
    __del__ = lambda self: None
fixedForce_swigregister = _sim2d.fixedForce_swigregister
fixedForce_swigregister(fixedForce)

class fixedForceRegionAtom(atomid):
    """Proxy of C++ fixedForceRegionAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForceRegionAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForceRegionAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["direction"] = _sim2d.fixedForceRegionAtom_direction_set
    __swig_getmethods__["direction"] = _sim2d.fixedForceRegionAtom_direction_get
    if _newclass:
        direction = _swig_property(_sim2d.fixedForceRegionAtom_direction_get, _sim2d.fixedForceRegionAtom_direction_set)
    __swig_setmethods__["boundaries"] = _sim2d.fixedForceRegionAtom_boundaries_set
    __swig_getmethods__["boundaries"] = _sim2d.fixedForceRegionAtom_boundaries_get
    if _newclass:
        boundaries = _swig_property(_sim2d.fixedForceRegionAtom_boundaries_get, _sim2d.fixedForceRegionAtom_boundaries_set)
    __swig_setmethods__["Fs"] = _sim2d.fixedForceRegionAtom_Fs_set
    __swig_getmethods__["Fs"] = _sim2d.fixedForceRegionAtom_Fs_get
    if _newclass:
        Fs = _swig_property(_sim2d.fixedForceRegionAtom_Fs_get, _sim2d.fixedForceRegionAtom_Fs_set)

    def __init__(self, a: 'atomid', direction: 'Vec', boundaries: 'dvector', Fs: 'dvector'):
        """__init__(fixedForceRegionAtom self, atomid a, Vec direction, dvector boundaries, dvector Fs) -> fixedForceRegionAtom"""
        this = _sim2d.new_fixedForceRegionAtom(a, direction, boundaries, Fs)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(fixedForceRegionAtom self, Box box) -> flt"""
        return _sim2d.fixedForceRegionAtom_energy(self, box)


    def setForce(self, box: 'Box') -> "void":
        """setForce(fixedForceRegionAtom self, Box box)"""
        return _sim2d.fixedForceRegionAtom_setForce(self, box)

    __swig_destroy__ = _sim2d.delete_fixedForceRegionAtom
    __del__ = lambda self: None
fixedForceRegionAtom_swigregister = _sim2d.fixedForceRegionAtom_swigregister
fixedForceRegionAtom_swigregister(fixedForceRegionAtom)

class fixedForceRegion(interaction):
    """Proxy of C++ fixedForceRegion class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForceRegion, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForceRegion, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(fixedForceRegion self, std::vector< fixedForceRegionAtom > atoms) -> fixedForceRegion
        __init__(fixedForceRegion self) -> fixedForceRegion
        """
        this = _sim2d.new_fixedForceRegion(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(fixedForceRegion self, fixedForceRegionAtom a)
        add(fixedForceRegion self, atomid a, Vec dir, dvector bound, dvector F)
        """
        return _sim2d.fixedForceRegion_add(self, *args)


    def size(self) -> "uint":
        """size(fixedForceRegion self) -> uint"""
        return _sim2d.fixedForceRegion_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(fixedForceRegion self, Box box) -> flt"""
        return _sim2d.fixedForceRegion_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(fixedForceRegion self, Box box)"""
        return _sim2d.fixedForceRegion_setForces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(fixedForceRegion self, Box box) -> flt"""
        return _sim2d.fixedForceRegion_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_fixedForceRegion
    __del__ = lambda self: None
fixedForceRegion_swigregister = _sim2d.fixedForceRegion_swigregister
fixedForceRegion_swigregister(fixedForceRegion)

class fixedSpringAtom(_object):
    """Proxy of C++ fixedSpringAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpringAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpringAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["loc"] = _sim2d.fixedSpringAtom_loc_set
    __swig_getmethods__["loc"] = _sim2d.fixedSpringAtom_loc_get
    if _newclass:
        loc = _swig_property(_sim2d.fixedSpringAtom_loc_get, _sim2d.fixedSpringAtom_loc_set)
    __swig_setmethods__["k"] = _sim2d.fixedSpringAtom_k_set
    __swig_getmethods__["k"] = _sim2d.fixedSpringAtom_k_get
    if _newclass:
        k = _swig_property(_sim2d.fixedSpringAtom_k_get, _sim2d.fixedSpringAtom_k_set)
    __swig_setmethods__["usecoord"] = _sim2d.fixedSpringAtom_usecoord_set
    __swig_getmethods__["usecoord"] = _sim2d.fixedSpringAtom_usecoord_get
    if _newclass:
        usecoord = _swig_property(_sim2d.fixedSpringAtom_usecoord_get, _sim2d.fixedSpringAtom_usecoord_set)
    __swig_setmethods__["a"] = _sim2d.fixedSpringAtom_a_set
    __swig_getmethods__["a"] = _sim2d.fixedSpringAtom_a_get
    if _newclass:
        a = _swig_property(_sim2d.fixedSpringAtom_a_get, _sim2d.fixedSpringAtom_a_set)

    def __init__(self, a: 'atomid', loc: 'Vec', k: 'flt', usex: 'bool'=True, usey: 'bool'=True, usez: 'bool'=True):
        """
        __init__(fixedSpringAtom self, atomid a, Vec loc, flt k, bool usex=True, bool usey=True, bool usez=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atomid a, Vec loc, flt k, bool usex=True, bool usey=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atomid a, Vec loc, flt k, bool usex=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atomid a, Vec loc, flt k) -> fixedSpringAtom
        """
        this = _sim2d.new_fixedSpringAtom(a, loc, k, usex, usey, usez)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(fixedSpringAtom self, Box box) -> flt"""
        return _sim2d.fixedSpringAtom_energy(self, box)


    def setForce(self, box: 'Box') -> "void":
        """setForce(fixedSpringAtom self, Box box)"""
        return _sim2d.fixedSpringAtom_setForce(self, box)

    __swig_destroy__ = _sim2d.delete_fixedSpringAtom
    __del__ = lambda self: None
fixedSpringAtom_swigregister = _sim2d.fixedSpringAtom_swigregister
fixedSpringAtom_swigregister(fixedSpringAtom)

class fixedSpring(interaction):
    """Proxy of C++ fixedSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpring, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(fixedSpring self, std::vector< fixedSpringAtom > atoms) -> fixedSpring
        __init__(fixedSpring self) -> fixedSpring
        """
        this = _sim2d.new_fixedSpring(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(fixedSpring self, fixedSpringAtom a)
        add(fixedSpring self, atomid a, Vec loc, flt k, bool usex=True, bool usey=True, bool usez=True)
        add(fixedSpring self, atomid a, Vec loc, flt k, bool usex=True, bool usey=True)
        add(fixedSpring self, atomid a, Vec loc, flt k, bool usex=True)
        add(fixedSpring self, atomid a, Vec loc, flt k)
        """
        return _sim2d.fixedSpring_add(self, *args)


    def size(self) -> "uint":
        """size(fixedSpring self) -> uint"""
        return _sim2d.fixedSpring_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(fixedSpring self, Box box) -> flt"""
        return _sim2d.fixedSpring_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(fixedSpring self, Box box)"""
        return _sim2d.fixedSpring_setForces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(fixedSpring self, Box box) -> flt"""
        return _sim2d.fixedSpring_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_fixedSpring
    __del__ = lambda self: None
fixedSpring_swigregister = _sim2d.fixedSpring_swigregister
fixedSpring_swigregister(fixedSpring)

class COMSpring(interaction):
    """Proxy of C++ COMSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, COMSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, COMSpring, name)
    __repr__ = _swig_repr

    def __init__(self, g1: 'atomgroup', g2: 'atomgroup', k: 'flt', x0: 'flt'=0):
        """
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k, flt x0=0) -> COMSpring
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k) -> COMSpring
        """
        this = _sim2d.new_COMSpring(g1, g2, k, x0)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(COMSpring self, Box box) -> flt"""
        return _sim2d.COMSpring_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(COMSpring self, Box box)"""
        return _sim2d.COMSpring_setForces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(COMSpring self, Box box) -> flt"""
        return _sim2d.COMSpring_pressure(self, box)

    __swig_destroy__ = _sim2d.delete_COMSpring
    __del__ = lambda self: None
COMSpring_swigregister = _sim2d.COMSpring_swigregister
COMSpring_swigregister(COMSpring)


_sim2d.FIXED_swigconstant(_sim2d)
FIXED = _sim2d.FIXED

_sim2d.UNIFORM_swigconstant(_sim2d)
UNIFORM = _sim2d.UNIFORM

_sim2d.GAUSSIAN_swigconstant(_sim2d)
GAUSSIAN = _sim2d.GAUSSIAN
class RandomForceAtom(atomref):
    """Proxy of C++ RandomForceAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomref]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RandomForceAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomref]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RandomForceAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["force_mag"] = _sim2d.RandomForceAtom_force_mag_set
    __swig_getmethods__["force_mag"] = _sim2d.RandomForceAtom_force_mag_get
    if _newclass:
        force_mag = _swig_property(_sim2d.RandomForceAtom_force_mag_get, _sim2d.RandomForceAtom_force_mag_set)
    __swig_setmethods__["freq"] = _sim2d.RandomForceAtom_freq_set
    __swig_getmethods__["freq"] = _sim2d.RandomForceAtom_freq_get
    if _newclass:
        freq = _swig_property(_sim2d.RandomForceAtom_freq_get, _sim2d.RandomForceAtom_freq_set)
    __swig_setmethods__["force_type"] = _sim2d.RandomForceAtom_force_type_set
    __swig_getmethods__["force_type"] = _sim2d.RandomForceAtom_force_type_get
    if _newclass:
        force_type = _swig_property(_sim2d.RandomForceAtom_force_type_get, _sim2d.RandomForceAtom_force_type_set)

    def __init__(self, a: 'atomid', force_mag: 'flt', freq: 'flt', force_type: 'RandomForceType'=UNIFORM):
        """
        __init__(RandomForceAtom self, atomid a, flt force_mag, flt freq, RandomForceType force_type=UNIFORM) -> RandomForceAtom
        __init__(RandomForceAtom self, atomid a, flt force_mag, flt freq) -> RandomForceAtom
        """
        this = _sim2d.new_RandomForceAtom(a, force_mag, freq, force_type)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_RandomForceAtom
    __del__ = lambda self: None
RandomForceAtom_swigregister = _sim2d.RandomForceAtom_swigregister
RandomForceAtom_swigregister(RandomForceAtom)

class RandomForce(interaction):
    """Proxy of C++ RandomForce class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RandomForce, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RandomForce, name)
    __repr__ = _swig_repr
    __swig_setmethods__["group"] = _sim2d.RandomForce_group_set
    __swig_getmethods__["group"] = _sim2d.RandomForce_group_get
    if _newclass:
        group = _swig_property(_sim2d.RandomForce_group_get, _sim2d.RandomForce_group_set)

    def __init__(self, *args):
        """
        __init__(RandomForce self) -> RandomForce
        __init__(RandomForce self, atomgroup agroup, flt force_mag, flt freq, RandomForceType force_type=UNIFORM) -> RandomForce
        __init__(RandomForce self, atomgroup agroup, flt force_mag, flt freq) -> RandomForce
        """
        this = _sim2d.new_RandomForce(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def size(self) -> "uint":
        """size(RandomForce self) -> uint"""
        return _sim2d.RandomForce_size(self)


    def get(self, i: 'uint') -> "RandomForceAtom":
        """get(RandomForce self, uint i) -> RandomForceAtom"""
        return _sim2d.RandomForce_get(self, i)


    def add(self, a: 'RandomForceAtom', replace: 'bool'=True) -> "bool":
        """
        add(RandomForce self, RandomForceAtom a, bool replace=True) -> bool
        add(RandomForce self, RandomForceAtom a) -> bool
        """
        return _sim2d.RandomForce_add(self, a, replace)


    def energy(self, box: 'Box') -> "flt":
        """energy(RandomForce self, Box box) -> flt"""
        return _sim2d.RandomForce_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(RandomForce self, Box box)"""
        return _sim2d.RandomForce_setForces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(RandomForce self, Box box) -> flt"""
        return _sim2d.RandomForce_pressure(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(RandomForce self, Box box) -> flt"""
        return _sim2d.RandomForce_setForcesGetPressure(self, box)

    __swig_destroy__ = _sim2d.delete_RandomForce
    __del__ = lambda self: None
RandomForce_swigregister = _sim2d.RandomForce_swigregister
RandomForce_swigregister(RandomForce)


_sim2d.BOXED_swigconstant(_sim2d)
BOXED = _sim2d.BOXED

_sim2d.UNBOXED_swigconstant(_sim2d)
UNBOXED = _sim2d.UNBOXED

_sim2d.FIXEDBOX_swigconstant(_sim2d)
FIXEDBOX = _sim2d.FIXEDBOX
class bondgrouping(_object):
    """Proxy of C++ bondgrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondgrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondgrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2d.bondgrouping_k_set
    __swig_getmethods__["k"] = _sim2d.bondgrouping_k_get
    if _newclass:
        k = _swig_property(_sim2d.bondgrouping_k_get, _sim2d.bondgrouping_k_set)
    __swig_setmethods__["x0"] = _sim2d.bondgrouping_x0_set
    __swig_getmethods__["x0"] = _sim2d.bondgrouping_x0_get
    if _newclass:
        x0 = _swig_property(_sim2d.bondgrouping_x0_get, _sim2d.bondgrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2d.bondgrouping_a1_set
    __swig_getmethods__["a1"] = _sim2d.bondgrouping_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.bondgrouping_a1_get, _sim2d.bondgrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2d.bondgrouping_a2_set
    __swig_getmethods__["a2"] = _sim2d.bondgrouping_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.bondgrouping_a2_get, _sim2d.bondgrouping_a2_set)
    __swig_setmethods__["diff_type"] = _sim2d.bondgrouping_diff_type_set
    __swig_getmethods__["diff_type"] = _sim2d.bondgrouping_diff_type_get
    if _newclass:
        diff_type = _swig_property(_sim2d.bondgrouping_diff_type_get, _sim2d.bondgrouping_diff_type_set)
    __swig_setmethods__["fixed_box"] = _sim2d.bondgrouping_fixed_box_set
    __swig_getmethods__["fixed_box"] = _sim2d.bondgrouping_fixed_box_get
    if _newclass:
        fixed_box = _swig_property(_sim2d.bondgrouping_fixed_box_get, _sim2d.bondgrouping_fixed_box_set)

    def __init__(self, k: 'flt', x0: 'flt', a1: 'atomid', a2: 'atomid', diff: 'BondDiffType'=UNBOXED, box: 'OriginBox'=None):
        """
        __init__(bondgrouping self, flt k, flt x0, atomid a1, atomid a2, BondDiffType diff=UNBOXED, OriginBox box=None) -> bondgrouping
        __init__(bondgrouping self, flt k, flt x0, atomid a1, atomid a2, BondDiffType diff=UNBOXED) -> bondgrouping
        __init__(bondgrouping self, flt k, flt x0, atomid a1, atomid a2) -> bondgrouping
        """
        this = _sim2d.new_bondgrouping(k, x0, a1, a2, diff, box)
        try:
            self.this.append(this)
        except:
            self.this = this

    def diff(self, box: 'Box') -> "Vec":
        """diff(bondgrouping self, Box box) -> Vec"""
        return _sim2d.bondgrouping_diff(self, box)


    def get_fixed(self, i: 'uint') -> "int":
        """get_fixed(bondgrouping self, uint i) -> int"""
        return _sim2d.bondgrouping_get_fixed(self, i)


    def same_atoms(self, other: 'bondgrouping') -> "bool":
        """same_atoms(bondgrouping self, bondgrouping other) -> bool"""
        return _sim2d.bondgrouping_same_atoms(self, other)

    __swig_destroy__ = _sim2d.delete_bondgrouping
    __del__ = lambda self: None
bondgrouping_swigregister = _sim2d.bondgrouping_swigregister
bondgrouping_swigregister(bondgrouping)

class bondpairs(interaction):
    """Proxy of C++ bondpairs class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondpairs, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, bondpairs, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(bondpairs self, std::vector< bondgrouping > pairs, bool zeropressure=True) -> bondpairs
        __init__(bondpairs self, std::vector< bondgrouping > pairs) -> bondpairs
        __init__(bondpairs self, bool zeropressure=True) -> bondpairs
        __init__(bondpairs self) -> bondpairs
        """
        this = _sim2d.new_bondpairs(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add_forced(self, b: 'bondgrouping') -> "void":
        """add_forced(bondpairs self, bondgrouping b)"""
        return _sim2d.bondpairs_add_forced(self, b)


    def add(self, *args) -> "bool":
        """
        add(bondpairs self, bondgrouping b, bool replace=True) -> bool
        add(bondpairs self, bondgrouping b) -> bool
        add(bondpairs self, flt k, flt x0, atomid a1, atomid a2, bool replace=True) -> bool
        add(bondpairs self, flt k, flt x0, atomid a1, atomid a2) -> bool
        add(bondpairs self, flt k, atomid a1, atomid a2, bool replace=True) -> bool
        add(bondpairs self, flt k, atomid a1, atomid a2) -> bool
        """
        return _sim2d.bondpairs_add(self, *args)


    def size(self) -> "uint":
        """size(bondpairs self) -> uint"""
        return _sim2d.bondpairs_size(self)


    def get(self, i: 'uint') -> "bondgrouping":
        """get(bondpairs self, uint i) -> bondgrouping"""
        return _sim2d.bondpairs_get(self, i)


    def mean_dists(self, box: 'Box') -> "flt":
        """mean_dists(bondpairs self, Box box) -> flt"""
        return _sim2d.bondpairs_mean_dists(self, box)


    def std_dists(self, box: 'Box') -> "flt":
        """std_dists(bondpairs self, Box box) -> flt"""
        return _sim2d.bondpairs_std_dists(self, box)


    def energy(self, box: 'Box') -> "flt":
        """energy(bondpairs self, Box box) -> flt"""
        return _sim2d.bondpairs_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(bondpairs self, Box box)"""
        return _sim2d.bondpairs_setForces(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(bondpairs self, Box box) -> flt"""
        return _sim2d.bondpairs_pressure(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(bondpairs self, Box box) -> flt"""
        return _sim2d.bondpairs_setForcesGetPressure(self, box)

    __swig_destroy__ = _sim2d.delete_bondpairs
    __del__ = lambda self: None
bondpairs_swigregister = _sim2d.bondpairs_swigregister
bondpairs_swigregister(bondpairs)

class anglegrouping(_object):
    """Proxy of C++ anglegrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, anglegrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, anglegrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2d.anglegrouping_k_set
    __swig_getmethods__["k"] = _sim2d.anglegrouping_k_get
    if _newclass:
        k = _swig_property(_sim2d.anglegrouping_k_get, _sim2d.anglegrouping_k_set)
    __swig_setmethods__["x0"] = _sim2d.anglegrouping_x0_set
    __swig_getmethods__["x0"] = _sim2d.anglegrouping_x0_get
    if _newclass:
        x0 = _swig_property(_sim2d.anglegrouping_x0_get, _sim2d.anglegrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2d.anglegrouping_a1_set
    __swig_getmethods__["a1"] = _sim2d.anglegrouping_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.anglegrouping_a1_get, _sim2d.anglegrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2d.anglegrouping_a2_set
    __swig_getmethods__["a2"] = _sim2d.anglegrouping_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.anglegrouping_a2_get, _sim2d.anglegrouping_a2_set)
    __swig_setmethods__["a3"] = _sim2d.anglegrouping_a3_set
    __swig_getmethods__["a3"] = _sim2d.anglegrouping_a3_get
    if _newclass:
        a3 = _swig_property(_sim2d.anglegrouping_a3_get, _sim2d.anglegrouping_a3_set)

    def __init__(self, k: 'flt', x0: 'flt', a1: 'atomid', a2: 'atomid', a3: 'atomid'):
        """__init__(anglegrouping self, flt k, flt x0, atomid a1, atomid a2, atomid a3) -> anglegrouping"""
        this = _sim2d.new_anglegrouping(k, x0, a1, a2, a3)
        try:
            self.this.append(this)
        except:
            self.this = this

    def same_atoms(self, other: 'anglegrouping') -> "bool":
        """same_atoms(anglegrouping self, anglegrouping other) -> bool"""
        return _sim2d.anglegrouping_same_atoms(self, other)

    __swig_destroy__ = _sim2d.delete_anglegrouping
    __del__ = lambda self: None
anglegrouping_swigregister = _sim2d.anglegrouping_swigregister
anglegrouping_swigregister(anglegrouping)

class angletriples(interaction):
    """Proxy of C++ angletriples class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, angletriples, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, angletriples, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(angletriples self, std::vector< anglegrouping > triples) -> angletriples
        __init__(angletriples self) -> angletriples
        """
        this = _sim2d.new_angletriples(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, *args) -> "bool":
        """
        add(angletriples self, anglegrouping b, bool replace=True) -> bool
        add(angletriples self, anglegrouping b) -> bool
        add(angletriples self, flt k, flt x0, atomid a1, atomid a2, atomid a3, bool replace=True) -> bool
        add(angletriples self, flt k, flt x0, atomid a1, atomid a2, atomid a3) -> bool
        add(angletriples self, flt k, atomid a1, atomid a2, atomid a3, bool replace=True) -> bool
        add(angletriples self, flt k, atomid a1, atomid a2, atomid a3) -> bool
        """
        return _sim2d.angletriples_add(self, *args)


    def add_forced(self, b: 'anglegrouping') -> "void":
        """add_forced(angletriples self, anglegrouping b)"""
        return _sim2d.angletriples_add_forced(self, b)


    def energy(self, box: 'Box') -> "flt":
        """energy(angletriples self, Box box) -> flt"""
        return _sim2d.angletriples_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(angletriples self, Box box) -> flt"""
        return _sim2d.angletriples_pressure(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(angletriples self, Box box)"""
        return _sim2d.angletriples_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(angletriples self, Box box) -> flt"""
        return _sim2d.angletriples_setForcesGetPressure(self, box)


    def size(self) -> "uint":
        """size(angletriples self) -> uint"""
        return _sim2d.angletriples_size(self)


    def mean_dists(self) -> "flt":
        """mean_dists(angletriples self) -> flt"""
        return _sim2d.angletriples_mean_dists(self)


    def std_dists(self) -> "flt":
        """std_dists(angletriples self) -> flt"""
        return _sim2d.angletriples_std_dists(self)

    __swig_destroy__ = _sim2d.delete_angletriples
    __del__ = lambda self: None
angletriples_swigregister = _sim2d.angletriples_swigregister
angletriples_swigregister(angletriples)

class forcepair(_object):
    """Proxy of C++ forcepair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2d.forcepair_a1_set
    __swig_getmethods__["a1"] = _sim2d.forcepair_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.forcepair_a1_get, _sim2d.forcepair_a1_set)
    __swig_setmethods__["a2"] = _sim2d.forcepair_a2_set
    __swig_getmethods__["a2"] = _sim2d.forcepair_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.forcepair_a2_get, _sim2d.forcepair_a2_set)
    __swig_setmethods__["fij"] = _sim2d.forcepair_fij_set
    __swig_getmethods__["fij"] = _sim2d.forcepair_fij_get
    if _newclass:
        fij = _swig_property(_sim2d.forcepair_fij_get, _sim2d.forcepair_fij_set)

    def __init__(self):
        """__init__(forcepair self) -> forcepair"""
        this = _sim2d.new_forcepair()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_forcepair
    __del__ = lambda self: None
forcepair_swigregister = _sim2d.forcepair_swigregister
forcepair_swigregister(forcepair)

class forcepairx(_object):
    """Proxy of C++ forcepairx class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepairx, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepairx, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2d.forcepairx_a1_set
    __swig_getmethods__["a1"] = _sim2d.forcepairx_a1_get
    if _newclass:
        a1 = _swig_property(_sim2d.forcepairx_a1_get, _sim2d.forcepairx_a1_set)
    __swig_setmethods__["a2"] = _sim2d.forcepairx_a2_set
    __swig_getmethods__["a2"] = _sim2d.forcepairx_a2_get
    if _newclass:
        a2 = _swig_property(_sim2d.forcepairx_a2_get, _sim2d.forcepairx_a2_set)
    __swig_setmethods__["xij"] = _sim2d.forcepairx_xij_set
    __swig_getmethods__["xij"] = _sim2d.forcepairx_xij_get
    if _newclass:
        xij = _swig_property(_sim2d.forcepairx_xij_get, _sim2d.forcepairx_xij_set)
    __swig_setmethods__["fij"] = _sim2d.forcepairx_fij_set
    __swig_getmethods__["fij"] = _sim2d.forcepairx_fij_get
    if _newclass:
        fij = _swig_property(_sim2d.forcepairx_fij_get, _sim2d.forcepairx_fij_set)

    def __init__(self):
        """__init__(forcepairx self) -> forcepairx"""
        this = _sim2d.new_forcepairx()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_forcepairx
    __del__ = lambda self: None
forcepairx_swigregister = _sim2d.forcepairx_swigregister
forcepairx_swigregister(forcepairx)

class fpairxFunct(_object):
    """Proxy of C++ fpairxFunct class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fpairxFunct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fpairxFunct, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def run(self, arg2: 'forcepairx') -> "void":
        """run(fpairxFunct self, forcepairx arg2)"""
        return _sim2d.fpairxFunct_run(self, arg2)

    __swig_destroy__ = _sim2d.delete_fpairxFunct
    __del__ = lambda self: None
fpairxFunct_swigregister = _sim2d.fpairxFunct_swigregister
fpairxFunct_swigregister(fpairxFunct)

class interactionpairsx(interaction):
    """Proxy of C++ interactionpairsx class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactionpairsx, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, interactionpairsx, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setForces(self, *args) -> "void":
        """
        setForces(interactionpairsx self, Box box)
        setForces(interactionpairsx self, Box box, fpairxFunct arg3)
        """
        return _sim2d.interactionpairsx_setForces(self, *args)

    __swig_destroy__ = _sim2d.delete_interactionpairsx
    __del__ = lambda self: None
interactionpairsx_swigregister = _sim2d.interactionpairsx_swigregister
interactionpairsx_swigregister(interactionpairsx)

class Charged(atomid):
    """Proxy of C++ Charged class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charged, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charged, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q"] = _sim2d.Charged_q_set
    __swig_getmethods__["q"] = _sim2d.Charged_q_get
    if _newclass:
        q = _swig_property(_sim2d.Charged_q_get, _sim2d.Charged_q_set)

    def __init__(self, *args):
        """
        __init__(Charged self) -> Charged
        __init__(Charged self, flt q, atomid a) -> Charged
        """
        this = _sim2d.new_Charged(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_Charged
    __del__ = lambda self: None
Charged_swigregister = _sim2d.Charged_swigregister
Charged_swigregister(Charged)

class ChargePair(_object):
    """Proxy of C++ ChargePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChargePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChargePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q1q2"] = _sim2d.ChargePair_q1q2_set
    __swig_getmethods__["q1q2"] = _sim2d.ChargePair_q1q2_get
    if _newclass:
        q1q2 = _swig_property(_sim2d.ChargePair_q1q2_get, _sim2d.ChargePair_q1q2_set)
    __swig_setmethods__["atom1"] = _sim2d.ChargePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.ChargePair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.ChargePair_atom1_get, _sim2d.ChargePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.ChargePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.ChargePair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.ChargePair_atom2_get, _sim2d.ChargePair_atom2_set)

    def __init__(self, a1: 'Charged', a2: 'Charged'):
        """__init__(ChargePair self, Charged a1, Charged a2) -> ChargePair"""
        this = _sim2d.new_ChargePair(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_ChargePair
    __del__ = lambda self: None
ChargePair_swigregister = _sim2d.ChargePair_swigregister
ChargePair_swigregister(ChargePair)

class LJatom(atomid):
    """Proxy of C++ LJatom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJatom_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJatom_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.LJatom_epsilon_get, _sim2d.LJatom_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2d.LJatom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJatom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LJatom_sigma_get, _sim2d.LJatom_sigma_set)

    def __init__(self, *args):
        """
        __init__(LJatom self) -> LJatom
        __init__(LJatom self, flt epsilon, flt sigma, atomid a) -> LJatom
        __init__(LJatom self, atomid a, LJatom other) -> LJatom
        """
        this = _sim2d.new_LJatom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxsize(self) -> "flt":
        """maxsize(LJatom self) -> flt"""
        return _sim2d.LJatom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LJatom
    __del__ = lambda self: None
LJatom_swigregister = _sim2d.LJatom_swigregister
LJatom_swigregister(LJatom)

class LJpair(_object):
    """Proxy of C++ LJpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJpair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJpair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJpair_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.LJpair_epsilon_get, _sim2d.LJpair_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2d.LJpair_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJpair_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LJpair_sigma_get, _sim2d.LJpair_sigma_set)
    __swig_setmethods__["atom1"] = _sim2d.LJpair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJpair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJpair_atom1_get, _sim2d.LJpair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJpair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJpair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJpair_atom2_get, _sim2d.LJpair_atom2_set)

    def __init__(self, LJ1: 'LJatom', LJ2: 'LJatom'):
        """__init__(LJpair self, LJatom LJ1, LJatom LJ2) -> LJpair"""
        this = _sim2d.new_LJpair(LJ1, LJ2)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJpair self, Box box) -> flt"""
        return _sim2d.LJpair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJpair self, Box box) -> Vec"""
        return _sim2d.LJpair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJpair
    __del__ = lambda self: None
LJpair_swigregister = _sim2d.LJpair_swigregister
LJpair_swigregister(LJpair)

class LJatomcut(LJatom):
    """Proxy of C++ LJatomcut class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatomcut, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatomcut, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sigcut"] = _sim2d.LJatomcut_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJatomcut_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LJatomcut_sigcut_get, _sim2d.LJatomcut_sigcut_set)

    def __init__(self, *args):
        """
        __init__(LJatomcut self) -> LJatomcut
        __init__(LJatomcut self, flt epsilon, flt sigma, atomid a, flt cut) -> LJatomcut
        __init__(LJatomcut self, atomid a, LJatomcut other) -> LJatomcut
        """
        this = _sim2d.new_LJatomcut(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxsize(self) -> "flt":
        """maxsize(LJatomcut self) -> flt"""
        return _sim2d.LJatomcut_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LJatomcut
    __del__ = lambda self: None
LJatomcut_swigregister = _sim2d.LJatomcut_swigregister
LJatomcut_swigregister(LJatomcut)

class LJAtomIndexed(atomid):
    """Proxy of C++ LJAtomIndexed class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAtomIndexed, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAtomIndexed, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJAtomIndexed_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJAtomIndexed_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.LJAtomIndexed_epsilons_get, _sim2d.LJAtomIndexed_epsilons_set)
    __swig_setmethods__["sigmas"] = _sim2d.LJAtomIndexed_sigmas_set
    __swig_getmethods__["sigmas"] = _sim2d.LJAtomIndexed_sigmas_get
    if _newclass:
        sigmas = _swig_property(_sim2d.LJAtomIndexed_sigmas_get, _sim2d.LJAtomIndexed_sigmas_set)
    __swig_setmethods__["indx"] = _sim2d.LJAtomIndexed_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJAtomIndexed_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.LJAtomIndexed_indx_get, _sim2d.LJAtomIndexed_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJAtomIndexed_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJAtomIndexed_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LJAtomIndexed_sigcut_get, _sim2d.LJAtomIndexed_sigcut_set)

    def __init__(self, *args):
        """
        __init__(LJAtomIndexed self) -> LJAtomIndexed
        __init__(LJAtomIndexed self, dvector epsilons, dvector sigmas, uint indx, atomid a, flt cut) -> LJAtomIndexed
        __init__(LJAtomIndexed self, atomid a, LJAtomIndexed other) -> LJAtomIndexed
        """
        this = _sim2d.new_LJAtomIndexed(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getEpsilon(self, other: 'LJAtomIndexed') -> "flt":
        """getEpsilon(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim2d.LJAtomIndexed_getEpsilon(self, other)


    def getSigma(self, other: 'LJAtomIndexed') -> "flt":
        """getSigma(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim2d.LJAtomIndexed_getSigma(self, other)


    def maxsize(self) -> "flt":
        """maxsize(LJAtomIndexed self) -> flt"""
        return _sim2d.LJAtomIndexed_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LJAtomIndexed
    __del__ = lambda self: None
LJAtomIndexed_swigregister = _sim2d.LJAtomIndexed_swigregister
LJAtomIndexed_swigregister(LJAtomIndexed)

class LJCutPair(_object):
    """Proxy of C++ LJCutPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJCutPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJCutPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.LJCutPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.LJCutPair_inter_get
    if _newclass:
        inter = _swig_property(_sim2d.LJCutPair_inter_get, _sim2d.LJCutPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.LJCutPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJCutPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJCutPair_atom1_get, _sim2d.LJCutPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJCutPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJCutPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJCutPair_atom2_get, _sim2d.LJCutPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LJCutPair self, LJatomcut a1, LJatomcut a2) -> LJCutPair
        __init__(LJCutPair self, LJAtomIndexed a1, LJAtomIndexed a2) -> LJCutPair
        """
        this = _sim2d.new_LJCutPair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJCutPair self, Box box) -> flt"""
        return _sim2d.LJCutPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJCutPair self, Box box) -> Vec"""
        return _sim2d.LJCutPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJCutPair
    __del__ = lambda self: None
LJCutPair_swigregister = _sim2d.LJCutPair_swigregister
LJCutPair_swigregister(LJCutPair)

class LJAttractPair(_object):
    """Proxy of C++ LJAttractPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.LJAttractPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.LJAttractPair_inter_get
    if _newclass:
        inter = _swig_property(_sim2d.LJAttractPair_inter_get, _sim2d.LJAttractPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJAttractPair_atom1_get, _sim2d.LJAttractPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJAttractPair_atom2_get, _sim2d.LJAttractPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LJAttractPair self, LJatomcut a1, LJatomcut a2) -> LJAttractPair
        __init__(LJAttractPair self, LJAtomIndexed a1, LJAtomIndexed a2) -> LJAttractPair
        """
        this = _sim2d.new_LJAttractPair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJAttractPair self, Box box) -> flt"""
        return _sim2d.LJAttractPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJAttractPair self, Box box) -> Vec"""
        return _sim2d.LJAttractPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJAttractPair
    __del__ = lambda self: None
LJAttractPair_swigregister = _sim2d.LJAttractPair_swigregister
LJAttractPair_swigregister(LJAttractPair)

class HydroAtom(atomid):
    """Proxy of C++ HydroAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HydroAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.HydroAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.HydroAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.HydroAtom_epsilons_get, _sim2d.HydroAtom_epsilons_set)
    __swig_setmethods__["indx"] = _sim2d.HydroAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.HydroAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.HydroAtom_indx_get, _sim2d.HydroAtom_indx_set)
    __swig_setmethods__["sigma"] = _sim2d.HydroAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.HydroAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.HydroAtom_sigma_get, _sim2d.HydroAtom_sigma_set)
    __swig_setmethods__["sigcut"] = _sim2d.HydroAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.HydroAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.HydroAtom_sigcut_get, _sim2d.HydroAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(HydroAtom self) -> HydroAtom
        __init__(HydroAtom self, dvector epsilons, uint indx, flt sigma, atomid a, flt cut) -> HydroAtom
        __init__(HydroAtom self, atomid a, HydroAtom other) -> HydroAtom
        """
        this = _sim2d.new_HydroAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getEpsilon(self, other: 'HydroAtom') -> "flt":
        """getEpsilon(HydroAtom self, HydroAtom other) -> flt"""
        return _sim2d.HydroAtom_getEpsilon(self, other)


    def maxsize(self) -> "flt":
        """maxsize(HydroAtom self) -> flt"""
        return _sim2d.HydroAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_HydroAtom
    __del__ = lambda self: None
HydroAtom_swigregister = _sim2d.HydroAtom_swigregister
HydroAtom_swigregister(HydroAtom)

class HydroPair(_object):
    """Proxy of C++ HydroPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HydroPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.HydroPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.HydroPair_inter_get
    if _newclass:
        inter = _swig_property(_sim2d.HydroPair_inter_get, _sim2d.HydroPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.HydroPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.HydroPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.HydroPair_atom1_get, _sim2d.HydroPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.HydroPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.HydroPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.HydroPair_atom2_get, _sim2d.HydroPair_atom2_set)

    def __init__(self, a1: 'HydroAtom', a2: 'HydroAtom'):
        """__init__(HydroPair self, HydroAtom a1, HydroAtom a2) -> HydroPair"""
        this = _sim2d.new_HydroPair(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(HydroPair self, Box box) -> flt"""
        return _sim2d.HydroPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(HydroPair self, Box box) -> Vec"""
        return _sim2d.HydroPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_HydroPair
    __del__ = lambda self: None
HydroPair_swigregister = _sim2d.HydroPair_swigregister
HydroPair_swigregister(HydroPair)

class LJishAtom(atomid):
    """Proxy of C++ LJishAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJishAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJishAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJishAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.LJishAtom_epsilons_get, _sim2d.LJishAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2d.LJishAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJishAtom_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.LJishAtom_repeps_get, _sim2d.LJishAtom_repeps_set)
    __swig_setmethods__["sigma"] = _sim2d.LJishAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJishAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LJishAtom_sigma_get, _sim2d.LJishAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.LJishAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.LJishAtom_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.LJishAtom_exponent_get, _sim2d.LJishAtom_exponent_set)
    __swig_setmethods__["indx"] = _sim2d.LJishAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJishAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.LJishAtom_indx_get, _sim2d.LJishAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJishAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJishAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LJishAtom_sigcut_get, _sim2d.LJishAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(LJishAtom self) -> LJishAtom
        __init__(LJishAtom self, atomid a, dvector epsilons, flt repeps, flt sigma, flt n, uint indx, flt cut) -> LJishAtom
        __init__(LJishAtom self, atomid a, LJishAtom other) -> LJishAtom
        """
        this = _sim2d.new_LJishAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getEpsilon(self, other: 'LJishAtom') -> "flt":
        """getEpsilon(LJishAtom self, LJishAtom other) -> flt"""
        return _sim2d.LJishAtom_getEpsilon(self, other)


    def getSigma(self, other: 'LJishAtom') -> "flt":
        """getSigma(LJishAtom self, LJishAtom other) -> flt"""
        return _sim2d.LJishAtom_getSigma(self, other)


    def maxsize(self) -> "flt":
        """maxsize(LJishAtom self) -> flt"""
        return _sim2d.LJishAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LJishAtom
    __del__ = lambda self: None
LJishAtom_swigregister = _sim2d.LJishAtom_swigregister
LJishAtom_swigregister(LJishAtom)

class LJishPair(_object):
    """Proxy of C++ LJishPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJishPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJishPair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJishPair_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.LJishPair_epsilon_get, _sim2d.LJishPair_epsilon_set)
    __swig_setmethods__["repeps"] = _sim2d.LJishPair_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJishPair_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.LJishPair_repeps_get, _sim2d.LJishPair_repeps_set)
    __swig_setmethods__["sigma"] = _sim2d.LJishPair_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJishPair_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LJishPair_sigma_get, _sim2d.LJishPair_sigma_set)
    __swig_setmethods__["n"] = _sim2d.LJishPair_n_set
    __swig_getmethods__["n"] = _sim2d.LJishPair_n_get
    if _newclass:
        n = _swig_property(_sim2d.LJishPair_n_get, _sim2d.LJishPair_n_set)
    __swig_setmethods__["cutR"] = _sim2d.LJishPair_cutR_set
    __swig_getmethods__["cutR"] = _sim2d.LJishPair_cutR_get
    if _newclass:
        cutR = _swig_property(_sim2d.LJishPair_cutR_get, _sim2d.LJishPair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2d.LJishPair_cutE_set
    __swig_getmethods__["cutE"] = _sim2d.LJishPair_cutE_get
    if _newclass:
        cutE = _swig_property(_sim2d.LJishPair_cutE_get, _sim2d.LJishPair_cutE_set)
    __swig_setmethods__["atom1"] = _sim2d.LJishPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJishPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJishPair_atom1_get, _sim2d.LJishPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJishPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJishPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJishPair_atom2_get, _sim2d.LJishPair_atom2_set)

    def __init__(self, LJ1: 'LJishAtom', LJ2: 'LJishAtom'):
        """__init__(LJishPair self, LJishAtom LJ1, LJishAtom LJ2) -> LJishPair"""
        this = _sim2d.new_LJishPair(LJ1, LJ2)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJishPair self, Box box) -> flt"""
        return _sim2d.LJishPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJishPair self, Box box) -> Vec"""
        return _sim2d.LJishPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJishPair
    __del__ = lambda self: None
LJishPair_swigregister = _sim2d.LJishPair_swigregister
LJishPair_swigregister(LJishPair)

class LJAttractRepulseAtom(atomid):
    """Proxy of C++ LJAttractRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJAttractRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJAttractRepulseAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.LJAttractRepulseAtom_epsilons_get, _sim2d.LJAttractRepulseAtom_epsilons_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractRepulseAtom_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LJAttractRepulseAtom_sig_get, _sim2d.LJAttractRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim2d.LJAttractRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJAttractRepulseAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.LJAttractRepulseAtom_indx_get, _sim2d.LJAttractRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJAttractRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJAttractRepulseAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LJAttractRepulseAtom_sigcut_get, _sim2d.LJAttractRepulseAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(LJAttractRepulseAtom self) -> LJAttractRepulseAtom
        __init__(LJAttractRepulseAtom self, atomid a, dvector epsilons, flt sigma, uint indx, flt cut) -> LJAttractRepulseAtom
        __init__(LJAttractRepulseAtom self, atomid a, LJAttractRepulseAtom other) -> LJAttractRepulseAtom
        """
        this = _sim2d.new_LJAttractRepulseAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getEpsilon(self, other: 'LJAttractRepulseAtom') -> "flt":
        """getEpsilon(LJAttractRepulseAtom self, LJAttractRepulseAtom other) -> flt"""
        return _sim2d.LJAttractRepulseAtom_getEpsilon(self, other)


    def maxsize(self) -> "flt":
        """maxsize(LJAttractRepulseAtom self) -> flt"""
        return _sim2d.LJAttractRepulseAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulseAtom
    __del__ = lambda self: None
LJAttractRepulseAtom_swigregister = _sim2d.LJAttractRepulseAtom_swigregister
LJAttractRepulseAtom_swigregister(LJAttractRepulseAtom)

class LJAttractRepulsePair(_object):
    """Proxy of C++ LJAttractRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LJAttractRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LJAttractRepulsePair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LJAttractRepulsePair_eps_get, _sim2d.LJAttractRepulsePair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractRepulsePair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LJAttractRepulsePair_sig_get, _sim2d.LJAttractRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2d.LJAttractRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2d.LJAttractRepulsePair_cutR_get
    if _newclass:
        cutR = _swig_property(_sim2d.LJAttractRepulsePair_cutR_get, _sim2d.LJAttractRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2d.LJAttractRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2d.LJAttractRepulsePair_cutE_get
    if _newclass:
        cutE = _swig_property(_sim2d.LJAttractRepulsePair_cutE_get, _sim2d.LJAttractRepulsePair_cutE_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractRepulsePair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJAttractRepulsePair_atom1_get, _sim2d.LJAttractRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractRepulsePair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJAttractRepulsePair_atom2_get, _sim2d.LJAttractRepulsePair_atom2_set)

    def __init__(self, a1: 'LJAttractRepulseAtom', a2: 'LJAttractRepulseAtom'):
        """__init__(LJAttractRepulsePair self, LJAttractRepulseAtom a1, LJAttractRepulseAtom a2) -> LJAttractRepulsePair"""
        this = _sim2d.new_LJAttractRepulsePair(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJAttractRepulsePair self, Box box) -> flt"""
        return _sim2d.LJAttractRepulsePair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJAttractRepulsePair self, Box box) -> Vec"""
        return _sim2d.LJAttractRepulsePair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulsePair
    __del__ = lambda self: None
LJAttractRepulsePair_swigregister = _sim2d.LJAttractRepulsePair_swigregister
LJAttractRepulsePair_swigregister(LJAttractRepulsePair)

class LJAttractFixedRepulseAtom(atomid):
    """Proxy of C++ LJAttractFixedRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJAttractFixedRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJAttractFixedRepulseAtom_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.LJAttractFixedRepulseAtom_epsilons_get, _sim2d.LJAttractFixedRepulseAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2d.LJAttractFixedRepulseAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJAttractFixedRepulseAtom_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.LJAttractFixedRepulseAtom_repeps_get, _sim2d.LJAttractFixedRepulseAtom_repeps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractFixedRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractFixedRepulseAtom_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LJAttractFixedRepulseAtom_sig_get, _sim2d.LJAttractFixedRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim2d.LJAttractFixedRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJAttractFixedRepulseAtom_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.LJAttractFixedRepulseAtom_indx_get, _sim2d.LJAttractFixedRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJAttractFixedRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJAttractFixedRepulseAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LJAttractFixedRepulseAtom_sigcut_get, _sim2d.LJAttractFixedRepulseAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(LJAttractFixedRepulseAtom self) -> LJAttractFixedRepulseAtom
        __init__(LJAttractFixedRepulseAtom self, atomid a, dvector epsilons, flt repeps, flt sigma, uint indx, flt cut) -> LJAttractFixedRepulseAtom
        __init__(LJAttractFixedRepulseAtom self, atomid a, LJAttractFixedRepulseAtom other) -> LJAttractFixedRepulseAtom
        """
        this = _sim2d.new_LJAttractFixedRepulseAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getEpsilon(self, other: 'LJAttractFixedRepulseAtom') -> "flt":
        """getEpsilon(LJAttractFixedRepulseAtom self, LJAttractFixedRepulseAtom other) -> flt"""
        return _sim2d.LJAttractFixedRepulseAtom_getEpsilon(self, other)


    def maxsize(self) -> "flt":
        """maxsize(LJAttractFixedRepulseAtom self) -> flt"""
        return _sim2d.LJAttractFixedRepulseAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulseAtom
    __del__ = lambda self: None
LJAttractFixedRepulseAtom_swigregister = _sim2d.LJAttractFixedRepulseAtom_swigregister
LJAttractFixedRepulseAtom_swigregister(LJAttractFixedRepulseAtom)

class LJAttractFixedRepulsePair(_object):
    """Proxy of C++ LJAttractFixedRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LJAttractFixedRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LJAttractFixedRepulsePair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LJAttractFixedRepulsePair_eps_get, _sim2d.LJAttractFixedRepulsePair_eps_set)
    __swig_setmethods__["repeps"] = _sim2d.LJAttractFixedRepulsePair_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJAttractFixedRepulsePair_repeps_get
    if _newclass:
        repeps = _swig_property(_sim2d.LJAttractFixedRepulsePair_repeps_get, _sim2d.LJAttractFixedRepulsePair_repeps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractFixedRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractFixedRepulsePair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LJAttractFixedRepulsePair_sig_get, _sim2d.LJAttractFixedRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2d.LJAttractFixedRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2d.LJAttractFixedRepulsePair_cutR_get
    if _newclass:
        cutR = _swig_property(_sim2d.LJAttractFixedRepulsePair_cutR_get, _sim2d.LJAttractFixedRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2d.LJAttractFixedRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2d.LJAttractFixedRepulsePair_cutE_get
    if _newclass:
        cutE = _swig_property(_sim2d.LJAttractFixedRepulsePair_cutE_get, _sim2d.LJAttractFixedRepulsePair_cutE_set)
    __swig_setmethods__["attract"] = _sim2d.LJAttractFixedRepulsePair_attract_set
    __swig_getmethods__["attract"] = _sim2d.LJAttractFixedRepulsePair_attract_get
    if _newclass:
        attract = _swig_property(_sim2d.LJAttractFixedRepulsePair_attract_get, _sim2d.LJAttractFixedRepulsePair_attract_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractFixedRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractFixedRepulsePair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LJAttractFixedRepulsePair_atom1_get, _sim2d.LJAttractFixedRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractFixedRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractFixedRepulsePair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LJAttractFixedRepulsePair_atom2_get, _sim2d.LJAttractFixedRepulsePair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LJAttractFixedRepulsePair self) -> LJAttractFixedRepulsePair
        __init__(LJAttractFixedRepulsePair self, LJAttractFixedRepulseAtom a1, LJAttractFixedRepulseAtom a2) -> LJAttractFixedRepulsePair
        """
        this = _sim2d.new_LJAttractFixedRepulsePair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LJAttractFixedRepulsePair self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulsePair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LJAttractFixedRepulsePair self, Box box) -> Vec"""
        return _sim2d.LJAttractFixedRepulsePair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulsePair
    __del__ = lambda self: None
LJAttractFixedRepulsePair_swigregister = _sim2d.LJAttractFixedRepulsePair_swigregister
LJAttractFixedRepulsePair_swigregister(LJAttractFixedRepulsePair)

class LJDoubleAtom(LJatom):
    """Proxy of C++ LJDoubleAtom class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoubleAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoubleAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsrep"] = _sim2d.LJDoubleAtom_epsrep_set
    __swig_getmethods__["epsrep"] = _sim2d.LJDoubleAtom_epsrep_get
    if _newclass:
        epsrep = _swig_property(_sim2d.LJDoubleAtom_epsrep_get, _sim2d.LJDoubleAtom_epsrep_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJDoubleAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJDoubleAtom_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LJDoubleAtom_sigcut_get, _sim2d.LJDoubleAtom_sigcut_set)

    def __init__(self, *args):
        """
        __init__(LJDoubleAtom self) -> LJDoubleAtom
        __init__(LJDoubleAtom self, flt epsilon, flt epsrep, flt sigma, atomid a, flt cut) -> LJDoubleAtom
        __init__(LJDoubleAtom self, atomid a, LJDoubleAtom other) -> LJDoubleAtom
        """
        this = _sim2d.new_LJDoubleAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_LJDoubleAtom
    __del__ = lambda self: None
LJDoubleAtom_swigregister = _sim2d.LJDoubleAtom_swigregister
LJDoubleAtom_swigregister(LJDoubleAtom)

class LJDoublePair(LJAttractFixedRepulsePair):
    """Proxy of C++ LJDoublePair class"""
    __swig_setmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoublePair, name, value)
    __swig_getmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoublePair, name)
    __repr__ = _swig_repr

    def __init__(self, a1: 'LJDoubleAtom', a2: 'LJDoubleAtom'):
        """__init__(LJDoublePair self, LJDoubleAtom a1, LJDoubleAtom a2) -> LJDoublePair"""
        this = _sim2d.new_LJDoublePair(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_LJDoublePair
    __del__ = lambda self: None
LJDoublePair_swigregister = _sim2d.LJDoublePair_swigregister
LJDoublePair_swigregister(LJDoublePair)

class EisMclachlanAtom(atomid):
    """Proxy of C++ EisMclachlanAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dist"] = _sim2d.EisMclachlanAtom_dist_set
    __swig_getmethods__["dist"] = _sim2d.EisMclachlanAtom_dist_get
    if _newclass:
        dist = _swig_property(_sim2d.EisMclachlanAtom_dist_get, _sim2d.EisMclachlanAtom_dist_set)
    __swig_setmethods__["sigmai"] = _sim2d.EisMclachlanAtom_sigmai_set
    __swig_getmethods__["sigmai"] = _sim2d.EisMclachlanAtom_sigmai_get
    if _newclass:
        sigmai = _swig_property(_sim2d.EisMclachlanAtom_sigmai_get, _sim2d.EisMclachlanAtom_sigmai_set)

    def __init__(self, *args):
        """
        __init__(EisMclachlanAtom self) -> EisMclachlanAtom
        __init__(EisMclachlanAtom self, flt dist, flt sigmai, atomid a) -> EisMclachlanAtom
        __init__(EisMclachlanAtom self, atomid a, EisMclachlanAtom other) -> EisMclachlanAtom
        """
        this = _sim2d.new_EisMclachlanAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxsize(self) -> "flt":
        """maxsize(EisMclachlanAtom self) -> flt"""
        return _sim2d.EisMclachlanAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_EisMclachlanAtom
    __del__ = lambda self: None
EisMclachlanAtom_swigregister = _sim2d.EisMclachlanAtom_swigregister
EisMclachlanAtom_swigregister(EisMclachlanAtom)

class EisMclachlanPair(_object):
    """Proxy of C++ EisMclachlanPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["c0"] = _sim2d.EisMclachlanPair_c0_set
    __swig_getmethods__["c0"] = _sim2d.EisMclachlanPair_c0_get
    if _newclass:
        c0 = _swig_property(_sim2d.EisMclachlanPair_c0_get, _sim2d.EisMclachlanPair_c0_set)
    __swig_setmethods__["c1"] = _sim2d.EisMclachlanPair_c1_set
    __swig_getmethods__["c1"] = _sim2d.EisMclachlanPair_c1_get
    if _newclass:
        c1 = _swig_property(_sim2d.EisMclachlanPair_c1_get, _sim2d.EisMclachlanPair_c1_set)
    __swig_setmethods__["c2"] = _sim2d.EisMclachlanPair_c2_set
    __swig_getmethods__["c2"] = _sim2d.EisMclachlanPair_c2_get
    if _newclass:
        c2 = _swig_property(_sim2d.EisMclachlanPair_c2_get, _sim2d.EisMclachlanPair_c2_set)
    __swig_setmethods__["cutoff"] = _sim2d.EisMclachlanPair_cutoff_set
    __swig_getmethods__["cutoff"] = _sim2d.EisMclachlanPair_cutoff_get
    if _newclass:
        cutoff = _swig_property(_sim2d.EisMclachlanPair_cutoff_get, _sim2d.EisMclachlanPair_cutoff_set)
    __swig_setmethods__["atom1"] = _sim2d.EisMclachlanPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.EisMclachlanPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.EisMclachlanPair_atom1_get, _sim2d.EisMclachlanPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.EisMclachlanPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.EisMclachlanPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.EisMclachlanPair_atom2_get, _sim2d.EisMclachlanPair_atom2_set)

    def __init__(self, a1: 'EisMclachlanAtom', a2: 'EisMclachlanAtom'):
        """__init__(EisMclachlanPair self, EisMclachlanAtom a1, EisMclachlanAtom a2) -> EisMclachlanPair"""
        this = _sim2d.new_EisMclachlanPair(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(EisMclachlanPair self, Box box) -> flt"""
        return _sim2d.EisMclachlanPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(EisMclachlanPair self, Box box) -> Vec"""
        return _sim2d.EisMclachlanPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_EisMclachlanPair
    __del__ = lambda self: None
EisMclachlanPair_swigregister = _sim2d.EisMclachlanPair_swigregister
EisMclachlanPair_swigregister(EisMclachlanPair)

class HertzianAtom(atomid):
    """Proxy of C++ HertzianAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.HertzianAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.HertzianAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.HertzianAtom_eps_get, _sim2d.HertzianAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.HertzianAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.HertzianAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.HertzianAtom_sigma_get, _sim2d.HertzianAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.HertzianAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.HertzianAtom_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.HertzianAtom_exponent_get, _sim2d.HertzianAtom_exponent_set)

    def __init__(self, *args):
        """
        __init__(HertzianAtom self) -> HertzianAtom
        __init__(HertzianAtom self, atomid a, flt eps, flt sigma, flt exponent=2.5) -> HertzianAtom
        __init__(HertzianAtom self, atomid a, flt eps, flt sigma) -> HertzianAtom
        __init__(HertzianAtom self, atomid a, HertzianAtom other) -> HertzianAtom
        """
        this = _sim2d.new_HertzianAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxsize(self) -> "flt":
        """maxsize(HertzianAtom self) -> flt"""
        return _sim2d.HertzianAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_HertzianAtom
    __del__ = lambda self: None
HertzianAtom_swigregister = _sim2d.HertzianAtom_swigregister
HertzianAtom_swigregister(HertzianAtom)


def hertzd(a: 'atomid', eps: 'double', sigma: 'double', exponent: 'double'=2.5) -> "HertzianAtom":
    """
    hertzd(atomid a, double eps, double sigma, double exponent=2.5) -> HertzianAtom
    hertzd(atomid a, double eps, double sigma) -> HertzianAtom
    """
    return _sim2d.hertzd(a, eps, sigma, exponent)
class EnergyForce(_object):
    """Proxy of C++ EnergyForce class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyForce, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyForce, name)
    __repr__ = _swig_repr
    __swig_setmethods__["f"] = _sim2d.EnergyForce_f_set
    __swig_getmethods__["f"] = _sim2d.EnergyForce_f_get
    if _newclass:
        f = _swig_property(_sim2d.EnergyForce_f_get, _sim2d.EnergyForce_f_set)
    __swig_setmethods__["E"] = _sim2d.EnergyForce_E_set
    __swig_getmethods__["E"] = _sim2d.EnergyForce_E_get
    if _newclass:
        E = _swig_property(_sim2d.EnergyForce_E_get, _sim2d.EnergyForce_E_set)

    def __init__(self, f: 'Vec', E: 'flt'):
        """__init__(EnergyForce self, Vec f, flt E) -> EnergyForce"""
        this = _sim2d.new_EnergyForce(f, E)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_EnergyForce
    __del__ = lambda self: None
EnergyForce_swigregister = _sim2d.EnergyForce_swigregister
EnergyForce_swigregister(EnergyForce)

class HertzianAtomIndexed(atomid):
    """Proxy of C++ HertzianAtomIndexed class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianAtomIndexed, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianAtomIndexed, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.HertzianAtomIndexed_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.HertzianAtomIndexed_epsilons_get
    if _newclass:
        epsilons = _swig_property(_sim2d.HertzianAtomIndexed_epsilons_get, _sim2d.HertzianAtomIndexed_epsilons_set)
    __swig_setmethods__["sigmas"] = _sim2d.HertzianAtomIndexed_sigmas_set
    __swig_getmethods__["sigmas"] = _sim2d.HertzianAtomIndexed_sigmas_get
    if _newclass:
        sigmas = _swig_property(_sim2d.HertzianAtomIndexed_sigmas_get, _sim2d.HertzianAtomIndexed_sigmas_set)
    __swig_setmethods__["exponent"] = _sim2d.HertzianAtomIndexed_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.HertzianAtomIndexed_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.HertzianAtomIndexed_exponent_get, _sim2d.HertzianAtomIndexed_exponent_set)
    __swig_setmethods__["indx"] = _sim2d.HertzianAtomIndexed_indx_set
    __swig_getmethods__["indx"] = _sim2d.HertzianAtomIndexed_indx_get
    if _newclass:
        indx = _swig_property(_sim2d.HertzianAtomIndexed_indx_get, _sim2d.HertzianAtomIndexed_indx_set)

    def __init__(self, *args):
        """
        __init__(HertzianAtomIndexed self) -> HertzianAtomIndexed
        __init__(HertzianAtomIndexed self, atomid a, dvector epsilons, dvector sigmas, uint indx, flt exponent=2.5) -> HertzianAtomIndexed
        __init__(HertzianAtomIndexed self, atomid a, dvector epsilons, dvector sigmas, uint indx) -> HertzianAtomIndexed
        __init__(HertzianAtomIndexed self, atomid a, LJAtomIndexed other) -> HertzianAtomIndexed
        """
        this = _sim2d.new_HertzianAtomIndexed(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getEpsilon(self, other: 'HertzianAtomIndexed') -> "flt":
        """getEpsilon(HertzianAtomIndexed self, HertzianAtomIndexed other) -> flt"""
        return _sim2d.HertzianAtomIndexed_getEpsilon(self, other)


    def getSigma(self, other: 'HertzianAtomIndexed') -> "flt":
        """getSigma(HertzianAtomIndexed self, HertzianAtomIndexed other) -> flt"""
        return _sim2d.HertzianAtomIndexed_getSigma(self, other)


    def maxsize(self) -> "flt":
        """maxsize(HertzianAtomIndexed self) -> flt"""
        return _sim2d.HertzianAtomIndexed_maxsize(self)

    __swig_destroy__ = _sim2d.delete_HertzianAtomIndexed
    __del__ = lambda self: None
HertzianAtomIndexed_swigregister = _sim2d.HertzianAtomIndexed_swigregister
HertzianAtomIndexed_swigregister(HertzianAtomIndexed)

class HertzianPair(_object):
    """Proxy of C++ HertzianPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.HertzianPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.HertzianPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.HertzianPair_eps_get, _sim2d.HertzianPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.HertzianPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.HertzianPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.HertzianPair_sig_get, _sim2d.HertzianPair_sig_set)
    __swig_setmethods__["exponent"] = _sim2d.HertzianPair_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.HertzianPair_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.HertzianPair_exponent_get, _sim2d.HertzianPair_exponent_set)
    __swig_setmethods__["atom1"] = _sim2d.HertzianPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.HertzianPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.HertzianPair_atom1_get, _sim2d.HertzianPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.HertzianPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.HertzianPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.HertzianPair_atom2_get, _sim2d.HertzianPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(HertzianPair self, HertzianAtom a1, HertzianAtom a2) -> HertzianPair
        __init__(HertzianPair self, HertzianAtomIndexed a1, HertzianAtomIndexed a2) -> HertzianPair
        """
        this = _sim2d.new_HertzianPair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(HertzianPair self, Box box) -> flt"""
        return _sim2d.HertzianPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(HertzianPair self, Box box) -> Vec"""
        return _sim2d.HertzianPair_forces(self, box)


    def EnergyForces(self, box: 'Box') -> "EnergyForce":
        """EnergyForces(HertzianPair self, Box box) -> EnergyForce"""
        return _sim2d.HertzianPair_EnergyForces(self, box)


    def fill(self, box: 'Box', fpair: 'forcepairx') -> "void":
        """fill(HertzianPair self, Box box, forcepairx fpair)"""
        return _sim2d.HertzianPair_fill(self, box, fpair)

    __swig_destroy__ = _sim2d.delete_HertzianPair
    __del__ = lambda self: None
HertzianPair_swigregister = _sim2d.HertzianPair_swigregister
HertzianPair_swigregister(HertzianPair)

class HertzianDragAtom(atomid):
    """Proxy of C++ HertzianDragAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianDragAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianDragAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.HertzianDragAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.HertzianDragAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.HertzianDragAtom_eps_get, _sim2d.HertzianDragAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.HertzianDragAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.HertzianDragAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.HertzianDragAtom_sigma_get, _sim2d.HertzianDragAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.HertzianDragAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.HertzianDragAtom_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.HertzianDragAtom_exponent_get, _sim2d.HertzianDragAtom_exponent_set)
    __swig_setmethods__["gamma"] = _sim2d.HertzianDragAtom_gamma_set
    __swig_getmethods__["gamma"] = _sim2d.HertzianDragAtom_gamma_get
    if _newclass:
        gamma = _swig_property(_sim2d.HertzianDragAtom_gamma_get, _sim2d.HertzianDragAtom_gamma_set)

    def __init__(self, *args):
        """
        __init__(HertzianDragAtom self) -> HertzianDragAtom
        __init__(HertzianDragAtom self, atomid a, flt eps, flt sigma, flt gamma, flt exponent=2.5) -> HertzianDragAtom
        __init__(HertzianDragAtom self, atomid a, flt eps, flt sigma, flt gamma) -> HertzianDragAtom
        __init__(HertzianDragAtom self, atomid a, HertzianDragAtom other) -> HertzianDragAtom
        """
        this = _sim2d.new_HertzianDragAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxsize(self) -> "flt":
        """maxsize(HertzianDragAtom self) -> flt"""
        return _sim2d.HertzianDragAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_HertzianDragAtom
    __del__ = lambda self: None
HertzianDragAtom_swigregister = _sim2d.HertzianDragAtom_swigregister
HertzianDragAtom_swigregister(HertzianDragAtom)

class HertzianDragPair(_object):
    """Proxy of C++ HertzianDragPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianDragPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianDragPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.HertzianDragPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.HertzianDragPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.HertzianDragPair_eps_get, _sim2d.HertzianDragPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.HertzianDragPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.HertzianDragPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.HertzianDragPair_sig_get, _sim2d.HertzianDragPair_sig_set)
    __swig_setmethods__["exponent"] = _sim2d.HertzianDragPair_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.HertzianDragPair_exponent_get
    if _newclass:
        exponent = _swig_property(_sim2d.HertzianDragPair_exponent_get, _sim2d.HertzianDragPair_exponent_set)
    __swig_setmethods__["gamma"] = _sim2d.HertzianDragPair_gamma_set
    __swig_getmethods__["gamma"] = _sim2d.HertzianDragPair_gamma_get
    if _newclass:
        gamma = _swig_property(_sim2d.HertzianDragPair_gamma_get, _sim2d.HertzianDragPair_gamma_set)
    __swig_setmethods__["atom1"] = _sim2d.HertzianDragPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.HertzianDragPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.HertzianDragPair_atom1_get, _sim2d.HertzianDragPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.HertzianDragPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.HertzianDragPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.HertzianDragPair_atom2_get, _sim2d.HertzianDragPair_atom2_set)

    def __init__(self, a1: 'HertzianDragAtom', a2: 'HertzianDragAtom'):
        """__init__(HertzianDragPair self, HertzianDragAtom a1, HertzianDragAtom a2) -> HertzianDragPair"""
        this = _sim2d.new_HertzianDragPair(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(HertzianDragPair self, Box box) -> flt"""
        return _sim2d.HertzianDragPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(HertzianDragPair self, Box box) -> Vec"""
        return _sim2d.HertzianDragPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_HertzianDragPair
    __del__ = lambda self: None
HertzianDragPair_swigregister = _sim2d.HertzianDragPair_swigregister
HertzianDragPair_swigregister(HertzianDragPair)

class LoisOhernAtom(atomid):
    """Proxy of C++ LoisOhernAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisOhernAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisOhernAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisOhernAtom_eps_get, _sim2d.LoisOhernAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.LoisOhernAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LoisOhernAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LoisOhernAtom_sigma_get, _sim2d.LoisOhernAtom_sigma_set)
    __swig_setmethods__["C"] = _sim2d.LoisOhernAtom_C_set
    __swig_getmethods__["C"] = _sim2d.LoisOhernAtom_C_get
    if _newclass:
        C = _swig_property(_sim2d.LoisOhernAtom_C_get, _sim2d.LoisOhernAtom_C_set)
    __swig_setmethods__["l"] = _sim2d.LoisOhernAtom_l_set
    __swig_getmethods__["l"] = _sim2d.LoisOhernAtom_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisOhernAtom_l_get, _sim2d.LoisOhernAtom_l_set)

    def __init__(self, *args):
        """
        __init__(LoisOhernAtom self) -> LoisOhernAtom
        __init__(LoisOhernAtom self, atomid a, flt eps, flt sigma, flt C, flt l) -> LoisOhernAtom
        __init__(LoisOhernAtom self, atomid a, LoisOhernAtom other) -> LoisOhernAtom
        """
        this = _sim2d.new_LoisOhernAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxsize(self) -> "flt":
        """maxsize(LoisOhernAtom self) -> flt"""
        return _sim2d.LoisOhernAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LoisOhernAtom
    __del__ = lambda self: None
LoisOhernAtom_swigregister = _sim2d.LoisOhernAtom_swigregister
LoisOhernAtom_swigregister(LoisOhernAtom)

class LoisOhernPair(_object):
    """Proxy of C++ LoisOhernPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisOhernPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisOhernPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisOhernPair_eps_get, _sim2d.LoisOhernPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.LoisOhernPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LoisOhernPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LoisOhernPair_sig_get, _sim2d.LoisOhernPair_sig_set)
    __swig_setmethods__["C"] = _sim2d.LoisOhernPair_C_set
    __swig_getmethods__["C"] = _sim2d.LoisOhernPair_C_get
    if _newclass:
        C = _swig_property(_sim2d.LoisOhernPair_C_get, _sim2d.LoisOhernPair_C_set)
    __swig_setmethods__["l"] = _sim2d.LoisOhernPair_l_set
    __swig_getmethods__["l"] = _sim2d.LoisOhernPair_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisOhernPair_l_get, _sim2d.LoisOhernPair_l_set)
    __swig_setmethods__["sigcut"] = _sim2d.LoisOhernPair_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LoisOhernPair_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LoisOhernPair_sigcut_get, _sim2d.LoisOhernPair_sigcut_set)
    __swig_setmethods__["atom1"] = _sim2d.LoisOhernPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LoisOhernPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LoisOhernPair_atom1_get, _sim2d.LoisOhernPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LoisOhernPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LoisOhernPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LoisOhernPair_atom2_get, _sim2d.LoisOhernPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LoisOhernPair self, LoisOhernAtom a1, LoisOhernAtom a2) -> LoisOhernPair
        __init__(LoisOhernPair self, LoisOhernAtom a1, LoisOhernAtom a2, flt eps, flt sig, flt C, flt l) -> LoisOhernPair
        """
        this = _sim2d.new_LoisOhernPair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LoisOhernPair self, Box box) -> flt"""
        return _sim2d.LoisOhernPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LoisOhernPair self, Box box) -> Vec"""
        return _sim2d.LoisOhernPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LoisOhernPair
    __del__ = lambda self: None
LoisOhernPair_swigregister = _sim2d.LoisOhernPair_swigregister
LoisOhernPair_swigregister(LoisOhernPair)

class LoisOhernPairMinCLs(LoisOhernPair):
    """Proxy of C++ LoisOhernPairMinCLs class"""
    __swig_setmethods__ = {}
    for _s in [LoisOhernPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernPairMinCLs, name, value)
    __swig_getmethods__ = {}
    for _s in [LoisOhernPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernPairMinCLs, name)
    __repr__ = _swig_repr

    def __init__(self, a1: 'LoisOhernAtom', a2: 'LoisOhernAtom'):
        """__init__(LoisOhernPairMinCLs self, LoisOhernAtom a1, LoisOhernAtom a2) -> LoisOhernPairMinCLs"""
        this = _sim2d.new_LoisOhernPairMinCLs(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_LoisOhernPairMinCLs
    __del__ = lambda self: None
LoisOhernPairMinCLs_swigregister = _sim2d.LoisOhernPairMinCLs_swigregister
LoisOhernPairMinCLs_swigregister(LoisOhernPairMinCLs)

class LoisLinAtom(atomid):
    """Proxy of C++ LoisLinAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisLinAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisLinAtom_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisLinAtom_eps_get, _sim2d.LoisLinAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.LoisLinAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LoisLinAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.LoisLinAtom_sigma_get, _sim2d.LoisLinAtom_sigma_set)
    __swig_setmethods__["f"] = _sim2d.LoisLinAtom_f_set
    __swig_getmethods__["f"] = _sim2d.LoisLinAtom_f_get
    if _newclass:
        f = _swig_property(_sim2d.LoisLinAtom_f_get, _sim2d.LoisLinAtom_f_set)
    __swig_setmethods__["l"] = _sim2d.LoisLinAtom_l_set
    __swig_getmethods__["l"] = _sim2d.LoisLinAtom_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisLinAtom_l_get, _sim2d.LoisLinAtom_l_set)

    def __init__(self, *args):
        """
        __init__(LoisLinAtom self) -> LoisLinAtom
        __init__(LoisLinAtom self, atomid a, flt eps, flt sigma, flt depth, flt width) -> LoisLinAtom
        __init__(LoisLinAtom self, atomid a, LoisLinAtom other) -> LoisLinAtom
        """
        this = _sim2d.new_LoisLinAtom(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxsize(self) -> "flt":
        """maxsize(LoisLinAtom self) -> flt"""
        return _sim2d.LoisLinAtom_maxsize(self)

    __swig_destroy__ = _sim2d.delete_LoisLinAtom
    __del__ = lambda self: None
LoisLinAtom_swigregister = _sim2d.LoisLinAtom_swigregister
LoisLinAtom_swigregister(LoisLinAtom)

class LoisLinPair(_object):
    """Proxy of C++ LoisLinPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LoisLinPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LoisLinPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.LoisLinPair_eps_get, _sim2d.LoisLinPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.LoisLinPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LoisLinPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.LoisLinPair_sig_get, _sim2d.LoisLinPair_sig_set)
    __swig_setmethods__["f"] = _sim2d.LoisLinPair_f_set
    __swig_getmethods__["f"] = _sim2d.LoisLinPair_f_get
    if _newclass:
        f = _swig_property(_sim2d.LoisLinPair_f_get, _sim2d.LoisLinPair_f_set)
    __swig_setmethods__["l"] = _sim2d.LoisLinPair_l_set
    __swig_getmethods__["l"] = _sim2d.LoisLinPair_l_get
    if _newclass:
        l = _swig_property(_sim2d.LoisLinPair_l_get, _sim2d.LoisLinPair_l_set)
    __swig_setmethods__["sigcut"] = _sim2d.LoisLinPair_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LoisLinPair_sigcut_get
    if _newclass:
        sigcut = _swig_property(_sim2d.LoisLinPair_sigcut_get, _sim2d.LoisLinPair_sigcut_set)
    __swig_setmethods__["atom1"] = _sim2d.LoisLinPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LoisLinPair_atom1_get
    if _newclass:
        atom1 = _swig_property(_sim2d.LoisLinPair_atom1_get, _sim2d.LoisLinPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LoisLinPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LoisLinPair_atom2_get
    if _newclass:
        atom2 = _swig_property(_sim2d.LoisLinPair_atom2_get, _sim2d.LoisLinPair_atom2_set)

    def __init__(self, *args):
        """
        __init__(LoisLinPair self, LoisLinAtom a1, LoisLinAtom a2) -> LoisLinPair
        __init__(LoisLinPair self, LoisLinAtom a1, LoisLinAtom a2, flt eps, flt sig, flt f, flt l) -> LoisLinPair
        """
        this = _sim2d.new_LoisLinPair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(LoisLinPair self, Box box) -> flt"""
        return _sim2d.LoisLinPair_energy(self, box)


    def forces(self, box: 'Box') -> "Vec":
        """forces(LoisLinPair self, Box box) -> Vec"""
        return _sim2d.LoisLinPair_forces(self, box)

    __swig_destroy__ = _sim2d.delete_LoisLinPair
    __del__ = lambda self: None
LoisLinPair_swigregister = _sim2d.LoisLinPair_swigregister
LoisLinPair_swigregister(LoisLinPair)

class LoisLinPairMin(LoisLinPair):
    """Proxy of C++ LoisLinPairMin class"""
    __swig_setmethods__ = {}
    for _s in [LoisLinPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinPairMin, name, value)
    __swig_getmethods__ = {}
    for _s in [LoisLinPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinPairMin, name)
    __repr__ = _swig_repr

    def __init__(self, a1: 'LoisLinAtom', a2: 'LoisLinAtom'):
        """__init__(LoisLinPairMin self, LoisLinAtom a1, LoisLinAtom a2) -> LoisLinPairMin"""
        this = _sim2d.new_LoisLinPairMin(a1, a2)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_LoisLinPairMin
    __del__ = lambda self: None
LoisLinPairMin_swigregister = _sim2d.LoisLinPairMin_swigregister
LoisLinPairMin_swigregister(LoisLinPairMin)

class LJsimple(interaction):
    """Proxy of C++ LJsimple class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJsimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJsimple, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LJsimple self, flt cutoffdist, std::vector< LJatom > atms) -> LJsimple
        __init__(LJsimple self, flt cutoffdist) -> LJsimple
        """
        this = _sim2d.new_LJsimple(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(LJsimple self, LJatom a)
        add(LJsimple self, atomid a, flt epsilon, flt sigma)
        """
        return _sim2d.LJsimple_add(self, *args)


    def ignore(self, *args) -> "void":
        """
        ignore(LJsimple self, atomid a, atomid b)
        ignore(LJsimple self, atom a, atom b)
        """
        return _sim2d.LJsimple_ignore(self, *args)


    def ignore_size(self) -> "uint":
        """ignore_size(LJsimple self) -> uint"""
        return _sim2d.LJsimple_ignore_size(self)


    def atoms_size(self) -> "uint":
        """atoms_size(LJsimple self) -> uint"""
        return _sim2d.LJsimple_atoms_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(LJsimple self, Box box) -> flt"""
        return _sim2d.LJsimple_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJsimple self, Box box) -> flt"""
        return _sim2d.LJsimple_pressure(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJsimple self, Box box)"""
        return _sim2d.LJsimple_setForces(self, box)

    __swig_destroy__ = _sim2d.delete_LJsimple
    __del__ = lambda self: None
LJsimple_swigregister = _sim2d.LJsimple_swigregister
LJsimple_swigregister(LJsimple)

class Charges(interaction):
    """Proxy of C++ Charges class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charges, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charges, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Charges self, flt screenlength, flt k=1, std::vector< Charged > atms) -> Charges
        __init__(Charges self, flt screenlength, flt k=1) -> Charges
        __init__(Charges self, flt screenlength) -> Charges
        """
        this = _sim2d.new_Charges(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, *args) -> "void":
        """
        add(Charges self, Charged a)
        add(Charges self, atomid a, flt q)
        """
        return _sim2d.Charges_add(self, *args)


    def ignore(self, *args) -> "void":
        """
        ignore(Charges self, atomid a, atomid b)
        ignore(Charges self, atom a, atom b)
        """
        return _sim2d.Charges_ignore(self, *args)


    def ignore_size(self) -> "uint":
        """ignore_size(Charges self) -> uint"""
        return _sim2d.Charges_ignore_size(self)


    def size(self) -> "uint":
        """size(Charges self) -> uint"""
        return _sim2d.Charges_size(self)


    def energy(self, box: 'Box') -> "flt":
        """energy(Charges self, Box box) -> flt"""
        return _sim2d.Charges_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(Charges self, Box box) -> flt"""
        return _sim2d.Charges_pressure(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(Charges self, Box box)"""
        return _sim2d.Charges_setForces(self, box)

    __swig_destroy__ = _sim2d.delete_Charges
    __del__ = lambda self: None
Charges_swigregister = _sim2d.Charges_swigregister
Charges_swigregister(Charges)

class WallAtom(atomref):
    """Proxy of C++ WallAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomref]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WallAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomref]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WallAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sigma"] = _sim2d.WallAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.WallAtom_sigma_get
    if _newclass:
        sigma = _swig_property(_sim2d.WallAtom_sigma_get, _sim2d.WallAtom_sigma_set)
    __swig_setmethods__["epsilon"] = _sim2d.WallAtom_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.WallAtom_epsilon_get
    if _newclass:
        epsilon = _swig_property(_sim2d.WallAtom_epsilon_get, _sim2d.WallAtom_epsilon_set)

    def __init__(self, a: 'atomid', sigma: 'flt', epsilon: 'flt'=1.0):
        """
        __init__(WallAtom self, atomid a, flt sigma, flt epsilon=1.0) -> WallAtom
        __init__(WallAtom self, atomid a, flt sigma) -> WallAtom
        """
        this = _sim2d.new_WallAtom(a, sigma, epsilon)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_WallAtom
    __del__ = lambda self: None
WallAtom_swigregister = _sim2d.WallAtom_swigregister
WallAtom_swigregister(WallAtom)

class SoftWall(interaction):
    """Proxy of C++ SoftWall class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftWall, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SoftWall, name)
    __repr__ = _swig_repr

    def __init__(self, loc: 'Vec', norm: 'Vec', expt: 'flt'=2.0):
        """
        __init__(SoftWall self, Vec loc, Vec norm, flt expt=2.0) -> SoftWall
        __init__(SoftWall self, Vec loc, Vec norm) -> SoftWall
        """
        this = _sim2d.new_SoftWall(loc, norm, expt)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, a: 'WallAtom') -> "void":
        """add(SoftWall self, WallAtom a)"""
        return _sim2d.SoftWall_add(self, a)


    def energy(self, box: 'Box') -> "flt":
        """energy(SoftWall self, Box box) -> flt"""
        return _sim2d.SoftWall_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(SoftWall self, Box box)"""
        return _sim2d.SoftWall_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(SoftWall self, Box box) -> flt"""
        return _sim2d.SoftWall_setForcesGetPressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(SoftWall self, Box box) -> flt"""
        return _sim2d.SoftWall_pressure(self, box)


    def setLoc(self, newloc: 'Vec') -> "void":
        """setLoc(SoftWall self, Vec newloc)"""
        return _sim2d.SoftWall_setLoc(self, newloc)


    def getLoc(self) -> "Vec":
        """getLoc(SoftWall self) -> Vec"""
        return _sim2d.SoftWall_getLoc(self)


    def setNorm(self, newNorm: 'Vec') -> "void":
        """setNorm(SoftWall self, Vec newNorm)"""
        return _sim2d.SoftWall_setNorm(self, newNorm)


    def getNorm(self) -> "Vec":
        """getNorm(SoftWall self) -> Vec"""
        return _sim2d.SoftWall_getNorm(self)


    def get_last_f(self) -> "flt":
        """get_last_f(SoftWall self) -> flt"""
        return _sim2d.SoftWall_get_last_f(self)

    __swig_destroy__ = _sim2d.delete_SoftWall
    __del__ = lambda self: None
SoftWall_swigregister = _sim2d.SoftWall_swigregister
SoftWall_swigregister(SoftWall)

class SoftWallCylinder(interaction):
    """Proxy of C++ SoftWallCylinder class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftWallCylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SoftWallCylinder, name)
    __repr__ = _swig_repr

    def __init__(self, loc: 'Vec', axis: 'Vec', radius: 'flt', expt: 'flt'=2.0):
        """
        __init__(SoftWallCylinder self, Vec loc, Vec axis, flt radius, flt expt=2.0) -> SoftWallCylinder
        __init__(SoftWallCylinder self, Vec loc, Vec axis, flt radius) -> SoftWallCylinder
        """
        this = _sim2d.new_SoftWallCylinder(loc, axis, radius, expt)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, a: 'WallAtom') -> "void":
        """add(SoftWallCylinder self, WallAtom a)"""
        return _sim2d.SoftWallCylinder_add(self, a)


    def energy(self, box: 'Box') -> "flt":
        """energy(SoftWallCylinder self, Box box) -> flt"""
        return _sim2d.SoftWallCylinder_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(SoftWallCylinder self, Box box)"""
        return _sim2d.SoftWallCylinder_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(SoftWallCylinder self, Box box) -> flt"""
        return _sim2d.SoftWallCylinder_setForcesGetPressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(SoftWallCylinder self, Box box) -> flt"""
        return _sim2d.SoftWallCylinder_pressure(self, box)


    def setLoc(self, new_loc: 'Vec') -> "void":
        """setLoc(SoftWallCylinder self, Vec new_loc)"""
        return _sim2d.SoftWallCylinder_setLoc(self, new_loc)


    def getLoc(self) -> "Vec":
        """getLoc(SoftWallCylinder self) -> Vec"""
        return _sim2d.SoftWallCylinder_getLoc(self)


    def setAxis(self, new_axis: 'Vec') -> "void":
        """setAxis(SoftWallCylinder self, Vec new_axis)"""
        return _sim2d.SoftWallCylinder_setAxis(self, new_axis)


    def getAxis(self) -> "Vec":
        """getAxis(SoftWallCylinder self) -> Vec"""
        return _sim2d.SoftWallCylinder_getAxis(self)


    def get_last_f(self) -> "flt":
        """get_last_f(SoftWallCylinder self) -> flt"""
        return _sim2d.SoftWallCylinder_get_last_f(self)

    __swig_destroy__ = _sim2d.delete_SoftWallCylinder
    __del__ = lambda self: None
SoftWallCylinder_swigregister = _sim2d.SoftWallCylinder_swigregister
SoftWallCylinder_swigregister(SoftWallCylinder)

class WalledBox2D(OriginBox):
    """Proxy of C++ WalledBox2D class"""
    __swig_setmethods__ = {}
    for _s in [OriginBox]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WalledBox2D, name, value)
    __swig_getmethods__ = {}
    for _s in [OriginBox]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WalledBox2D, name)
    __repr__ = _swig_repr

    def __init__(self, size: 'Vec', xwalled: 'bool', ywalled: 'bool', expt: 'flt'=2.0):
        """
        __init__(WalledBox2D self, Vec size, bool xwalled, bool ywalled, flt expt=2.0) -> WalledBox2D
        __init__(WalledBox2D self, Vec size, bool xwalled, bool ywalled) -> WalledBox2D
        """
        this = _sim2d.new_WalledBox2D(size, xwalled, ywalled, expt)
        try:
            self.this.append(this)
        except:
            self.this = this

    def diff(self, *args) -> "Vec":
        """
        diff(WalledBox2D self, Vec r1, Vec r2) -> Vec
        diff(WalledBox2D self, Vec r1, Vec r2, array< int,2 > boxes) -> Vec
        """
        return _sim2d.WalledBox2D_diff(self, *args)


    def V(self) -> "flt":
        """V(WalledBox2D self) -> flt"""
        return _sim2d.WalledBox2D_V(self)


    def L(self) -> "flt":
        """L(WalledBox2D self) -> flt"""
        return _sim2d.WalledBox2D_L(self)


    def resize(self, factor: 'flt') -> "flt":
        """resize(WalledBox2D self, flt factor) -> flt"""
        return _sim2d.WalledBox2D_resize(self, factor)


    def resizeV(self, newV: 'flt') -> "flt":
        """resizeV(WalledBox2D self, flt newV) -> flt"""
        return _sim2d.WalledBox2D_resizeV(self, newV)


    def randLoc(self, walldist: 'flt') -> "Vec":
        """randLoc(WalledBox2D self, flt walldist) -> Vec"""
        return _sim2d.WalledBox2D_randLoc(self, walldist)


    def getWalls(self) -> "std::vector< SoftWall * >":
        """getWalls(WalledBox2D self) -> std::vector< SoftWall * >"""
        return _sim2d.WalledBox2D_getWalls(self)

    __swig_destroy__ = _sim2d.delete_WalledBox2D
    __del__ = lambda self: None
WalledBox2D_swigregister = _sim2d.WalledBox2D_swigregister
WalledBox2D_swigregister(WalledBox2D)


def confineRange(minimum: 'flt', val: 'flt', maximum: 'flt') -> "flt":
    """confineRange(flt minimum, flt val, flt maximum) -> flt"""
    return _sim2d.confineRange(minimum, val, maximum)
class SCatomvec(atomgroup):
    """Proxy of C++ SCatomvec class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCatomvec, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCatomvec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SCatomvec self, dvector masses) -> SCatomvec
        __init__(SCatomvec self, uint N, flt mass) -> SCatomvec
        """
        this = _sim2d.new_SCatomvec(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def vec(self) -> "atomvec &":
        """vec(SCatomvec self) -> atomvec"""
        return _sim2d.SCatomvec_vec(self)


    def get_id(self, n: 'cuint') -> "atomid":
        """get_id(SCatomvec self, cuint n) -> atomid"""
        return _sim2d.SCatomvec_get_id(self, n)


    def pair(self, n: 'cuint') -> "idpair":
        """pair(SCatomvec self, cuint n) -> idpair"""
        return _sim2d.SCatomvec_pair(self, n)


    def size(self) -> "uint":
        """size(SCatomvec self) -> uint"""
        return _sim2d.SCatomvec_size(self)


    def pairs(self) -> "uint":
        """pairs(SCatomvec self) -> uint"""
        return _sim2d.SCatomvec_pairs(self)

    __swig_destroy__ = _sim2d.delete_SCatomvec
    __del__ = lambda self: None

    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def all_pairs(self):
        for i in range(self.pairs()):
            yield self.pair(i)

    def __len__(self):
        return self.size()

    def __getitem__(self, obj):
        return self.get_id(obj)

SCatomvec_swigregister = _sim2d.SCatomvec_swigregister
SCatomvec_swigregister(SCatomvec)

class SpheroCylinderDiff(_object):
    """Proxy of C++ SpheroCylinderDiff class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpheroCylinderDiff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpheroCylinderDiff, name)
    __repr__ = _swig_repr
    __swig_setmethods__["delta"] = _sim2d.SpheroCylinderDiff_delta_set
    __swig_getmethods__["delta"] = _sim2d.SpheroCylinderDiff_delta_get
    if _newclass:
        delta = _swig_property(_sim2d.SpheroCylinderDiff_delta_get, _sim2d.SpheroCylinderDiff_delta_set)
    __swig_setmethods__["r"] = _sim2d.SpheroCylinderDiff_r_set
    __swig_getmethods__["r"] = _sim2d.SpheroCylinderDiff_r_get
    if _newclass:
        r = _swig_property(_sim2d.SpheroCylinderDiff_r_get, _sim2d.SpheroCylinderDiff_r_set)
    __swig_setmethods__["lambda1"] = _sim2d.SpheroCylinderDiff_lambda1_set
    __swig_getmethods__["lambda1"] = _sim2d.SpheroCylinderDiff_lambda1_get
    if _newclass:
        lambda1 = _swig_property(_sim2d.SpheroCylinderDiff_lambda1_get, _sim2d.SpheroCylinderDiff_lambda1_set)
    __swig_setmethods__["lambda2"] = _sim2d.SpheroCylinderDiff_lambda2_set
    __swig_getmethods__["lambda2"] = _sim2d.SpheroCylinderDiff_lambda2_get
    if _newclass:
        lambda2 = _swig_property(_sim2d.SpheroCylinderDiff_lambda2_get, _sim2d.SpheroCylinderDiff_lambda2_set)

    def __init__(self):
        """__init__(SpheroCylinderDiff self) -> SpheroCylinderDiff"""
        this = _sim2d.new_SpheroCylinderDiff()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_SpheroCylinderDiff
    __del__ = lambda self: None
SpheroCylinderDiff_swigregister = _sim2d.SpheroCylinderDiff_swigregister
SpheroCylinderDiff_swigregister(SpheroCylinderDiff)

class SCPair(_object):
    """Proxy of C++ SCPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SCPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["p1"] = _sim2d.SCPair_p1_set
    __swig_getmethods__["p1"] = _sim2d.SCPair_p1_get
    if _newclass:
        p1 = _swig_property(_sim2d.SCPair_p1_get, _sim2d.SCPair_p1_set)
    __swig_setmethods__["p2"] = _sim2d.SCPair_p2_set
    __swig_getmethods__["p2"] = _sim2d.SCPair_p2_get
    if _newclass:
        p2 = _swig_property(_sim2d.SCPair_p2_get, _sim2d.SCPair_p2_set)
    __swig_setmethods__["l1"] = _sim2d.SCPair_l1_set
    __swig_getmethods__["l1"] = _sim2d.SCPair_l1_get
    if _newclass:
        l1 = _swig_property(_sim2d.SCPair_l1_get, _sim2d.SCPair_l1_set)
    __swig_setmethods__["l2"] = _sim2d.SCPair_l2_set
    __swig_getmethods__["l2"] = _sim2d.SCPair_l2_get
    if _newclass:
        l2 = _swig_property(_sim2d.SCPair_l2_get, _sim2d.SCPair_l2_set)

    def __init__(self, *args):
        """
        __init__(SCPair self, idpair p1, idpair p2, flt l1, flt l2) -> SCPair
        __init__(SCPair self, idpair p1, idpair p2, flt l) -> SCPair
        __init__(SCPair self, SCPair other) -> SCPair
        """
        this = _sim2d.new_SCPair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def NearestLoc(self, box: 'Box') -> "SpheroCylinderDiff":
        """NearestLoc(SCPair self, Box box) -> SpheroCylinderDiff"""
        return _sim2d.SCPair_NearestLoc(self, box)


    def applyForce(self, *args) -> "void":
        """
        applyForce(SCPair self, Box box, Vec f, SpheroCylinderDiff diff, flt I1, flt I2)
        applyForce(SCPair self, Box box, Vec f, SpheroCylinderDiff diff, flt I)
        """
        return _sim2d.SCPair_applyForce(self, *args)

    __swig_destroy__ = _sim2d.delete_SCPair
    __del__ = lambda self: None
SCPair_swigregister = _sim2d.SCPair_swigregister
SCPair_swigregister(SCPair)

class SCSpringPair(SCPair):
    """Proxy of C++ SCSpringPair class"""
    __swig_setmethods__ = {}
    for _s in [SCPair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCSpringPair, name, value)
    __swig_getmethods__ = {}
    for _s in [SCPair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCSpringPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.SCSpringPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.SCSpringPair_eps_get
    if _newclass:
        eps = _swig_property(_sim2d.SCSpringPair_eps_get, _sim2d.SCSpringPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.SCSpringPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.SCSpringPair_sig_get
    if _newclass:
        sig = _swig_property(_sim2d.SCSpringPair_sig_get, _sim2d.SCSpringPair_sig_set)

    def __init__(self, *args):
        """
        __init__(SCSpringPair self, idpair p1, idpair p2, flt eps, flt sig, flt l1, flt l2) -> SCSpringPair
        __init__(SCSpringPair self, idpair p1, idpair p2, flt eps, flt sig, flt l) -> SCSpringPair
        """
        this = _sim2d.new_SCSpringPair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def maxdist(self) -> "flt":
        """maxdist(SCSpringPair self) -> flt"""
        return _sim2d.SCSpringPair_maxdist(self)


    def maxdelta(self) -> "flt":
        """maxdelta(SCSpringPair self) -> flt"""
        return _sim2d.SCSpringPair_maxdelta(self)


    def energy(self, box: 'Box', diff: 'SpheroCylinderDiff') -> "flt":
        """energy(SCSpringPair self, Box box, SpheroCylinderDiff diff) -> flt"""
        return _sim2d.SCSpringPair_energy(self, box, diff)


    def forces(self, box: 'Box', diff: 'SpheroCylinderDiff') -> "Vec":
        """forces(SCSpringPair self, Box box, SpheroCylinderDiff diff) -> Vec"""
        return _sim2d.SCSpringPair_forces(self, box, diff)

    __swig_destroy__ = _sim2d.delete_SCSpringPair
    __del__ = lambda self: None
SCSpringPair_swigregister = _sim2d.SCSpringPair_swigregister
SCSpringPair_swigregister(SCSpringPair)

class SCSpringList(interaction):
    """Proxy of C++ SCSpringList class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCSpringList, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SCSpringList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SCSpringList self, SCatomvec scs, flt eps, flt sig, flt l) -> SCSpringList
        __init__(SCSpringList self, SCatomvec scs, flt eps, flt sig, dvector ls) -> SCSpringList
        """
        this = _sim2d.new_SCSpringList(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def energy(self, box: 'Box') -> "flt":
        """energy(SCSpringList self, Box box) -> flt"""
        return _sim2d.SCSpringList_energy(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(SCSpringList self, Box box)"""
        return _sim2d.SCSpringList_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(SCSpringList self, Box box) -> flt"""
        return _sim2d.SCSpringList_setForcesGetPressure(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(SCSpringList self, Box box) -> flt"""
        return _sim2d.SCSpringList_pressure(self, box)


    def ignore(self, *args) -> "void":
        """
        ignore(SCSpringList self, uint n1, uint n2)
        ignore(SCSpringList self, atomid a1, atomid a2)
        """
        return _sim2d.SCSpringList_ignore(self, *args)

    __swig_destroy__ = _sim2d.delete_SCSpringList
    __del__ = lambda self: None
SCSpringList_swigregister = _sim2d.SCSpringList_swigregister
SCSpringList_swigregister(SCSpringList)

class constraint(_object):
    """Proxy of C++ constraint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraint, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def apply(self, box: 'Box') -> "void":
        """apply(constraint self, Box box)"""
        return _sim2d.constraint_apply(self, box)


    def ndof(self) -> "int":
        """ndof(constraint self) -> int"""
        return _sim2d.constraint_ndof(self)

    __swig_destroy__ = _sim2d.delete_constraint
    __del__ = lambda self: None
constraint_swigregister = _sim2d.constraint_swigregister
constraint_swigregister(constraint)

class coordConstraint(constraint):
    """Proxy of C++ coordConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz, Vec loc) -> coordConstraint
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz) -> coordConstraint
        __init__(coordConstraint self, atom atm) -> coordConstraint
        """
        this = _sim2d.new_coordConstraint(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def ndof(self) -> "int":
        """ndof(coordConstraint self) -> int"""
        return _sim2d.coordConstraint_ndof(self)


    def apply(self, box: 'Box') -> "void":
        """apply(coordConstraint self, Box box)"""
        return _sim2d.coordConstraint_apply(self, box)

    __swig_destroy__ = _sim2d.delete_coordConstraint
    __del__ = lambda self: None
coordConstraint_swigregister = _sim2d.coordConstraint_swigregister
coordConstraint_swigregister(coordConstraint)

class coordCOMConstraint(constraint):
    """Proxy of C++ coordCOMConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordCOMConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordCOMConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(coordCOMConstraint self, boost::shared_ptr< atomgroup > atm, bool fixx, bool fixy, bool fixz, Vec loc) -> coordCOMConstraint
        __init__(coordCOMConstraint self, boost::shared_ptr< atomgroup > atm, bool fixx, bool fixy, bool fixz) -> coordCOMConstraint
        __init__(coordCOMConstraint self, boost::shared_ptr< atomgroup > atm) -> coordCOMConstraint
        """
        this = _sim2d.new_coordCOMConstraint(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def ndof(self) -> "int":
        """ndof(coordCOMConstraint self) -> int"""
        return _sim2d.coordCOMConstraint_ndof(self)


    def apply(self, box: 'Box') -> "void":
        """apply(coordCOMConstraint self, Box box)"""
        return _sim2d.coordCOMConstraint_apply(self, box)

    __swig_destroy__ = _sim2d.delete_coordCOMConstraint
    __del__ = lambda self: None
coordCOMConstraint_swigregister = _sim2d.coordCOMConstraint_swigregister
coordCOMConstraint_swigregister(coordCOMConstraint)

class relativeConstraint(constraint):
    """Proxy of C++ relativeConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, relativeConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, relativeConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz, Vec loc) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2) -> relativeConstraint
        """
        this = _sim2d.new_relativeConstraint(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def ndof(self) -> "int":
        """ndof(relativeConstraint self) -> int"""
        return _sim2d.relativeConstraint_ndof(self)


    def apply(self, box: 'Box') -> "void":
        """apply(relativeConstraint self, Box box)"""
        return _sim2d.relativeConstraint_apply(self, box)

    __swig_destroy__ = _sim2d.delete_relativeConstraint
    __del__ = lambda self: None
relativeConstraint_swigregister = _sim2d.relativeConstraint_swigregister
relativeConstraint_swigregister(relativeConstraint)

class distConstraint(constraint):
    """Proxy of C++ distConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, distConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, distConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(distConstraint self, atomid atm1, atomid atm2, flt dist) -> distConstraint
        __init__(distConstraint self, atomid atm1, atomid atm2) -> distConstraint
        """
        this = _sim2d.new_distConstraint(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def ndof(self) -> "int":
        """ndof(distConstraint self) -> int"""
        return _sim2d.distConstraint_ndof(self)


    def apply(self, box: 'Box') -> "void":
        """apply(distConstraint self, Box box)"""
        return _sim2d.distConstraint_apply(self, box)

    __swig_destroy__ = _sim2d.delete_distConstraint
    __del__ = lambda self: None
distConstraint_swigregister = _sim2d.distConstraint_swigregister
distConstraint_swigregister(distConstraint)

class linearConstraint(constraint):
    """Proxy of C++ linearConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, linearConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, linearConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, atms: 'boost::shared_ptr< atomgroup >', dist: 'flt'):
        """__init__(linearConstraint self, boost::shared_ptr< atomgroup > atms, flt dist) -> linearConstraint"""
        this = _sim2d.new_linearConstraint(atms, dist)
        try:
            self.this.append(this)
        except:
            self.this = this

    def ndof(self) -> "int":
        """ndof(linearConstraint self) -> int"""
        return _sim2d.linearConstraint_ndof(self)


    def apply(self, box: 'Box') -> "void":
        """apply(linearConstraint self, Box box)"""
        return _sim2d.linearConstraint_apply(self, box)

    __swig_destroy__ = _sim2d.delete_linearConstraint
    __del__ = lambda self: None
linearConstraint_swigregister = _sim2d.linearConstraint_swigregister
linearConstraint_swigregister(linearConstraint)

class ContactTracker(statetracker):
    """Proxy of C++ ContactTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContactTracker, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', atoms: 'boost::shared_ptr< atomgroup >', dists: 'dvector'):
        """__init__(ContactTracker self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, dvector dists) -> ContactTracker"""
        this = _sim2d.new_ContactTracker(box, atoms, dists)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update(self, box: 'Box') -> "void":
        """update(ContactTracker self, Box box)"""
        return _sim2d.ContactTracker_update(self, box)


    def reset(self) -> "void":
        """reset(ContactTracker self)"""
        return _sim2d.ContactTracker_reset(self)


    def broken(self) -> "unsigned long long":
        """broken(ContactTracker self) -> unsigned long long"""
        return _sim2d.ContactTracker_broken(self)


    def formed(self) -> "unsigned long long":
        """formed(ContactTracker self) -> unsigned long long"""
        return _sim2d.ContactTracker_formed(self)


    def number(self) -> "unsigned long long":
        """number(ContactTracker self) -> unsigned long long"""
        return _sim2d.ContactTracker_number(self)

    __swig_destroy__ = _sim2d.delete_ContactTracker
    __del__ = lambda self: None
ContactTracker_swigregister = _sim2d.ContactTracker_swigregister
ContactTracker_swigregister(ContactTracker)


def ContactTrackerD(box: 'boost::shared_ptr< Box >', atoms: 'boost::shared_ptr< atomgroup >', dists: 'dvector') -> "ContactTracker *":
    """ContactTrackerD(boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, dvector dists) -> ContactTracker"""
    return _sim2d.ContactTrackerD(box, atoms, dists)
class EnergyTracker(statetracker):
    """Proxy of C++ EnergyTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyTracker, name)
    __repr__ = _swig_repr

    def __init__(self, atoms: 'boost::shared_ptr< atomgroup >', interactions: 'std::vector< boost::shared_ptr< interaction > >', nskip: 'uint'=1):
        """
        __init__(EnergyTracker self, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions, uint nskip=1) -> EnergyTracker
        __init__(EnergyTracker self, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions) -> EnergyTracker
        """
        this = _sim2d.new_EnergyTracker(atoms, interactions, nskip)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update(self, box: 'Box') -> "void":
        """update(EnergyTracker self, Box box)"""
        return _sim2d.EnergyTracker_update(self, box)


    def reset(self) -> "void":
        """reset(EnergyTracker self)"""
        return _sim2d.EnergyTracker_reset(self)


    def setU0(self, *args) -> "void":
        """
        setU0(EnergyTracker self, flt newU0)
        setU0(EnergyTracker self, Box box)
        """
        return _sim2d.EnergyTracker_setU0(self, *args)


    def getU0(self) -> "flt":
        """getU0(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_getU0(self)


    def E(self) -> "flt":
        """E(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_E(self)


    def U(self) -> "flt":
        """U(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_U(self)


    def K(self) -> "flt":
        """K(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_K(self)


    def Estd(self) -> "flt":
        """Estd(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_Estd(self)


    def Kstd(self) -> "flt":
        """Kstd(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_Kstd(self)


    def Ustd(self) -> "flt":
        """Ustd(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_Ustd(self)


    def Esqmean(self) -> "flt":
        """Esqmean(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_Esqmean(self)


    def Ksqmean(self) -> "flt":
        """Ksqmean(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_Ksqmean(self)


    def Usqmean(self) -> "flt":
        """Usqmean(EnergyTracker self) -> flt"""
        return _sim2d.EnergyTracker_Usqmean(self)


    def n(self) -> "uint":
        """n(EnergyTracker self) -> uint"""
        return _sim2d.EnergyTracker_n(self)

    __swig_destroy__ = _sim2d.delete_EnergyTracker
    __del__ = lambda self: None
EnergyTracker_swigregister = _sim2d.EnergyTracker_swigregister
EnergyTracker_swigregister(EnergyTracker)

class RsqTracker1(_object):
    """Proxy of C++ RsqTracker1 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RsqTracker1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RsqTracker1, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pastlocs"] = _sim2d.RsqTracker1_pastlocs_set
    __swig_getmethods__["pastlocs"] = _sim2d.RsqTracker1_pastlocs_get
    if _newclass:
        pastlocs = _swig_property(_sim2d.RsqTracker1_pastlocs_get, _sim2d.RsqTracker1_pastlocs_set)
    __swig_setmethods__["xyz2sums"] = _sim2d.RsqTracker1_xyz2sums_set
    __swig_getmethods__["xyz2sums"] = _sim2d.RsqTracker1_xyz2sums_get
    if _newclass:
        xyz2sums = _swig_property(_sim2d.RsqTracker1_xyz2sums_get, _sim2d.RsqTracker1_xyz2sums_set)
    __swig_setmethods__["xyz4sums"] = _sim2d.RsqTracker1_xyz4sums_set
    __swig_getmethods__["xyz4sums"] = _sim2d.RsqTracker1_xyz4sums_get
    if _newclass:
        xyz4sums = _swig_property(_sim2d.RsqTracker1_xyz4sums_get, _sim2d.RsqTracker1_xyz4sums_set)
    __swig_setmethods__["r4sums"] = _sim2d.RsqTracker1_r4sums_set
    __swig_getmethods__["r4sums"] = _sim2d.RsqTracker1_r4sums_get
    if _newclass:
        r4sums = _swig_property(_sim2d.RsqTracker1_r4sums_get, _sim2d.RsqTracker1_r4sums_set)
    __swig_setmethods__["skip"] = _sim2d.RsqTracker1_skip_set
    __swig_getmethods__["skip"] = _sim2d.RsqTracker1_skip_get
    if _newclass:
        skip = _swig_property(_sim2d.RsqTracker1_skip_get, _sim2d.RsqTracker1_skip_set)
    __swig_setmethods__["count"] = _sim2d.RsqTracker1_count_set
    __swig_getmethods__["count"] = _sim2d.RsqTracker1_count_get
    if _newclass:
        count = _swig_property(_sim2d.RsqTracker1_count_get, _sim2d.RsqTracker1_count_set)

    def __init__(self, atoms: 'atomgroup', skip: 'unsigned long', com: 'Vec'):
        """__init__(RsqTracker1 self, atomgroup atoms, unsigned long skip, Vec com) -> RsqTracker1"""
        this = _sim2d.new_RsqTracker1(atoms, skip, com)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self, atoms: 'atomgroup', com: 'Vec') -> "void":
        """reset(RsqTracker1 self, atomgroup atoms, Vec com)"""
        return _sim2d.RsqTracker1_reset(self, atoms, com)


    def update(self, box: 'Box', atoms: 'atomgroup', t: 'unsigned long', com: 'Vec') -> "bool":
        """update(RsqTracker1 self, Box box, atomgroup atoms, unsigned long t, Vec com) -> bool"""
        return _sim2d.RsqTracker1_update(self, box, atoms, t, com)


    def xyz2(self) -> "std::vector< Vec >":
        """xyz2(RsqTracker1 self) -> std::vector< Vec >"""
        return _sim2d.RsqTracker1_xyz2(self)


    def xyz4(self) -> "std::vector< Vec >":
        """xyz4(RsqTracker1 self) -> std::vector< Vec >"""
        return _sim2d.RsqTracker1_xyz4(self)


    def r4(self) -> "std::vector< flt >":
        """r4(RsqTracker1 self) -> dvector"""
        return _sim2d.RsqTracker1_r4(self)


    def get_skip(self) -> "unsigned long":
        """get_skip(RsqTracker1 self) -> unsigned long"""
        return _sim2d.RsqTracker1_get_skip(self)


    def get_count(self) -> "unsigned long":
        """get_count(RsqTracker1 self) -> unsigned long"""
        return _sim2d.RsqTracker1_get_count(self)

    __swig_destroy__ = _sim2d.delete_RsqTracker1
    __del__ = lambda self: None
RsqTracker1_swigregister = _sim2d.RsqTracker1_swigregister
RsqTracker1_swigregister(RsqTracker1)

class RsqTracker(statetracker):
    """Proxy of C++ RsqTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RsqTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RsqTracker, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.RsqTracker_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.RsqTracker_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.RsqTracker_atoms_get, _sim2d.RsqTracker_atoms_set)
    __swig_setmethods__["singles"] = _sim2d.RsqTracker_singles_set
    __swig_getmethods__["singles"] = _sim2d.RsqTracker_singles_get
    if _newclass:
        singles = _swig_property(_sim2d.RsqTracker_singles_get, _sim2d.RsqTracker_singles_set)
    __swig_setmethods__["curt"] = _sim2d.RsqTracker_curt_set
    __swig_getmethods__["curt"] = _sim2d.RsqTracker_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.RsqTracker_curt_get, _sim2d.RsqTracker_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.RsqTracker_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.RsqTracker_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.RsqTracker_usecom_get, _sim2d.RsqTracker_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< atomgroup >', ns: 'ulongvector', usecom: 'bool'=True):
        """
        __init__(RsqTracker self, boost::shared_ptr< atomgroup > atoms, ulongvector ns, bool usecom=True) -> RsqTracker
        __init__(RsqTracker self, boost::shared_ptr< atomgroup > atoms, ulongvector ns) -> RsqTracker
        """
        this = _sim2d.new_RsqTracker(atoms, ns, usecom)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        """reset(RsqTracker self)"""
        return _sim2d.RsqTracker_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(RsqTracker self, Box box)"""
        return _sim2d.RsqTracker_update(self, box)


    def xyz2(self) -> "std::vector< std::vector< Vec > >":
        """xyz2(RsqTracker self) -> std::vector< std::vector< Vec > >"""
        return _sim2d.RsqTracker_xyz2(self)


    def r2(self) -> "std::vector< std::vector< flt > >":
        """r2(RsqTracker self) -> _ddvector"""
        return _sim2d.RsqTracker_r2(self)


    def xyz4(self) -> "std::vector< std::vector< Vec > >":
        """xyz4(RsqTracker self) -> std::vector< std::vector< Vec > >"""
        return _sim2d.RsqTracker_xyz4(self)


    def r4(self) -> "std::vector< std::vector< flt > >":
        """r4(RsqTracker self) -> _ddvector"""
        return _sim2d.RsqTracker_r4(self)


    def counts(self) -> "std::vector< flt >":
        """counts(RsqTracker self) -> dvector"""
        return _sim2d.RsqTracker_counts(self)


    def mean_array(self):
        import numpy as np
        l = self.means()
        l = [[list(v) for v in innerl] for innerl in l]
        return np.array(l)

    def var_array(self):
        import numpy as np
        l = self.vars()
        l = [[list(v) for v in innerl] for innerl in l]
        return np.array(l)

    __swig_destroy__ = _sim2d.delete_RsqTracker
    __del__ = lambda self: None
RsqTracker_swigregister = _sim2d.RsqTracker_swigregister
RsqTracker_swigregister(RsqTracker)

class ISFTracker1(_object):
    """Proxy of C++ ISFTracker1 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISFTracker1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISFTracker1, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pastlocs"] = _sim2d.ISFTracker1_pastlocs_set
    __swig_getmethods__["pastlocs"] = _sim2d.ISFTracker1_pastlocs_get
    if _newclass:
        pastlocs = _swig_property(_sim2d.ISFTracker1_pastlocs_get, _sim2d.ISFTracker1_pastlocs_set)
    __swig_setmethods__["ISFsums"] = _sim2d.ISFTracker1_ISFsums_set
    __swig_getmethods__["ISFsums"] = _sim2d.ISFTracker1_ISFsums_get
    if _newclass:
        ISFsums = _swig_property(_sim2d.ISFTracker1_ISFsums_get, _sim2d.ISFTracker1_ISFsums_set)
    __swig_setmethods__["ks"] = _sim2d.ISFTracker1_ks_set
    __swig_getmethods__["ks"] = _sim2d.ISFTracker1_ks_get
    if _newclass:
        ks = _swig_property(_sim2d.ISFTracker1_ks_get, _sim2d.ISFTracker1_ks_set)
    __swig_setmethods__["skip"] = _sim2d.ISFTracker1_skip_set
    __swig_getmethods__["skip"] = _sim2d.ISFTracker1_skip_get
    if _newclass:
        skip = _swig_property(_sim2d.ISFTracker1_skip_get, _sim2d.ISFTracker1_skip_set)
    __swig_setmethods__["count"] = _sim2d.ISFTracker1_count_set
    __swig_getmethods__["count"] = _sim2d.ISFTracker1_count_get
    if _newclass:
        count = _swig_property(_sim2d.ISFTracker1_count_get, _sim2d.ISFTracker1_count_set)

    def __init__(self, atoms: 'atomgroup', skip: 'unsigned long', ks: 'dvector', com: 'Vec'):
        """__init__(ISFTracker1 self, atomgroup atoms, unsigned long skip, dvector ks, Vec com) -> ISFTracker1"""
        this = _sim2d.new_ISFTracker1(atoms, skip, ks, com)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self, atoms: 'atomgroup', com: 'Vec') -> "void":
        """reset(ISFTracker1 self, atomgroup atoms, Vec com)"""
        return _sim2d.ISFTracker1_reset(self, atoms, com)


    def update(self, box: 'Box', atoms: 'atomgroup', t: 'unsigned long', com: 'Vec') -> "bool":
        """update(ISFTracker1 self, Box box, atomgroup atoms, unsigned long t, Vec com) -> bool"""
        return _sim2d.ISFTracker1_update(self, box, atoms, t, com)


    def ISFs(self) -> "std::vector< std::vector< cmplx > >":
        """ISFs(ISFTracker1 self) -> _ccvector"""
        return _sim2d.ISFTracker1_ISFs(self)


    def ISFxyz(self) -> "std::vector< std::vector< array< cmplx,2 > > >":
        """ISFxyz(ISFTracker1 self) -> std::vector< std::vector< array< cmplx,2 > > >"""
        return _sim2d.ISFTracker1_ISFxyz(self)


    def get_skip(self) -> "unsigned long":
        """get_skip(ISFTracker1 self) -> unsigned long"""
        return _sim2d.ISFTracker1_get_skip(self)


    def get_count(self) -> "unsigned long":
        """get_count(ISFTracker1 self) -> unsigned long"""
        return _sim2d.ISFTracker1_get_count(self)

    __swig_destroy__ = _sim2d.delete_ISFTracker1
    __del__ = lambda self: None
ISFTracker1_swigregister = _sim2d.ISFTracker1_swigregister
ISFTracker1_swigregister(ISFTracker1)

class ISFTracker(statetracker):
    """Proxy of C++ ISFTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISFTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ISFTracker, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.ISFTracker_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.ISFTracker_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.ISFTracker_atoms_get, _sim2d.ISFTracker_atoms_set)
    __swig_setmethods__["singles"] = _sim2d.ISFTracker_singles_set
    __swig_getmethods__["singles"] = _sim2d.ISFTracker_singles_get
    if _newclass:
        singles = _swig_property(_sim2d.ISFTracker_singles_get, _sim2d.ISFTracker_singles_set)
    __swig_setmethods__["curt"] = _sim2d.ISFTracker_curt_set
    __swig_getmethods__["curt"] = _sim2d.ISFTracker_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.ISFTracker_curt_get, _sim2d.ISFTracker_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.ISFTracker_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.ISFTracker_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.ISFTracker_usecom_get, _sim2d.ISFTracker_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< atomgroup >', ks: 'dvector', ns: 'ulongvector', usecom: 'bool'=False):
        """
        __init__(ISFTracker self, boost::shared_ptr< atomgroup > atoms, dvector ks, ulongvector ns, bool usecom=False) -> ISFTracker
        __init__(ISFTracker self, boost::shared_ptr< atomgroup > atoms, dvector ks, ulongvector ns) -> ISFTracker
        """
        this = _sim2d.new_ISFTracker(atoms, ks, ns, usecom)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        """reset(ISFTracker self)"""
        return _sim2d.ISFTracker_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(ISFTracker self, Box box)"""
        return _sim2d.ISFTracker_update(self, box)


    def ISFxyz(self) -> "std::vector< std::vector< std::vector< array< cmplx,2 > > > >":
        """ISFxyz(ISFTracker self) -> std::vector< std::vector< std::vector< array< cmplx,2 > > > >"""
        return _sim2d.ISFTracker_ISFxyz(self)


    def ISFs(self) -> "std::vector< std::vector< std::vector< cmplx > > >":
        """ISFs(ISFTracker self) -> _cccvector"""
        return _sim2d.ISFTracker_ISFs(self)


    def counts(self) -> "std::vector< flt >":
        """counts(ISFTracker self) -> dvector"""
        return _sim2d.ISFTracker_counts(self)

    __swig_destroy__ = _sim2d.delete_ISFTracker
    __del__ = lambda self: None
ISFTracker_swigregister = _sim2d.ISFTracker_swigregister
ISFTracker_swigregister(ISFTracker)

class SmoothLocs(statetracker):
    """Proxy of C++ SmoothLocs class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmoothLocs, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SmoothLocs, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.SmoothLocs_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.SmoothLocs_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.SmoothLocs_atoms_get, _sim2d.SmoothLocs_atoms_set)
    __swig_setmethods__["smoothn"] = _sim2d.SmoothLocs_smoothn_set
    __swig_getmethods__["smoothn"] = _sim2d.SmoothLocs_smoothn_get
    if _newclass:
        smoothn = _swig_property(_sim2d.SmoothLocs_smoothn_get, _sim2d.SmoothLocs_smoothn_set)
    __swig_setmethods__["skipn"] = _sim2d.SmoothLocs_skipn_set
    __swig_getmethods__["skipn"] = _sim2d.SmoothLocs_skipn_get
    if _newclass:
        skipn = _swig_property(_sim2d.SmoothLocs_skipn_get, _sim2d.SmoothLocs_skipn_set)
    __swig_setmethods__["curlocs"] = _sim2d.SmoothLocs_curlocs_set
    __swig_getmethods__["curlocs"] = _sim2d.SmoothLocs_curlocs_get
    if _newclass:
        curlocs = _swig_property(_sim2d.SmoothLocs_curlocs_get, _sim2d.SmoothLocs_curlocs_set)
    __swig_setmethods__["numincur"] = _sim2d.SmoothLocs_numincur_set
    __swig_getmethods__["numincur"] = _sim2d.SmoothLocs_numincur_get
    if _newclass:
        numincur = _swig_property(_sim2d.SmoothLocs_numincur_get, _sim2d.SmoothLocs_numincur_set)
    __swig_setmethods__["locs"] = _sim2d.SmoothLocs_locs_set
    __swig_getmethods__["locs"] = _sim2d.SmoothLocs_locs_get
    if _newclass:
        locs = _swig_property(_sim2d.SmoothLocs_locs_get, _sim2d.SmoothLocs_locs_set)
    __swig_setmethods__["curt"] = _sim2d.SmoothLocs_curt_set
    __swig_getmethods__["curt"] = _sim2d.SmoothLocs_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.SmoothLocs_curt_get, _sim2d.SmoothLocs_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.SmoothLocs_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.SmoothLocs_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.SmoothLocs_usecom_get, _sim2d.SmoothLocs_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< atomgroup >', box: 'Box', smoothn: 'uint', skipn: 'uint'=1, usecom: 'bool'=False):
        """
        __init__(SmoothLocs self, boost::shared_ptr< atomgroup > atoms, Box box, uint smoothn, uint skipn=1, bool usecom=False) -> SmoothLocs
        __init__(SmoothLocs self, boost::shared_ptr< atomgroup > atoms, Box box, uint smoothn, uint skipn=1) -> SmoothLocs
        __init__(SmoothLocs self, boost::shared_ptr< atomgroup > atoms, Box box, uint smoothn) -> SmoothLocs
        """
        this = _sim2d.new_SmoothLocs(atoms, box, smoothn, skipn, usecom)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        """reset(SmoothLocs self)"""
        return _sim2d.SmoothLocs_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(SmoothLocs self, Box box)"""
        return _sim2d.SmoothLocs_update(self, box)


    def smooth_locs(self) -> "std::vector< std::vector< Vec > >":
        """smooth_locs(SmoothLocs self) -> std::vector< std::vector< Vec > >"""
        return _sim2d.SmoothLocs_smooth_locs(self)

    __swig_destroy__ = _sim2d.delete_SmoothLocs
    __del__ = lambda self: None
SmoothLocs_swigregister = _sim2d.SmoothLocs_swigregister
SmoothLocs_swigregister(SmoothLocs)

class RDiffs(statetracker):
    """Proxy of C++ RDiffs class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RDiffs, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RDiffs, name)
    __repr__ = _swig_repr
    __swig_setmethods__["atoms"] = _sim2d.RDiffs_atoms_set
    __swig_getmethods__["atoms"] = _sim2d.RDiffs_atoms_get
    if _newclass:
        atoms = _swig_property(_sim2d.RDiffs_atoms_get, _sim2d.RDiffs_atoms_set)
    __swig_setmethods__["pastlocs"] = _sim2d.RDiffs_pastlocs_set
    __swig_getmethods__["pastlocs"] = _sim2d.RDiffs_pastlocs_get
    if _newclass:
        pastlocs = _swig_property(_sim2d.RDiffs_pastlocs_get, _sim2d.RDiffs_pastlocs_set)
    __swig_setmethods__["dists"] = _sim2d.RDiffs_dists_set
    __swig_getmethods__["dists"] = _sim2d.RDiffs_dists_get
    if _newclass:
        dists = _swig_property(_sim2d.RDiffs_dists_get, _sim2d.RDiffs_dists_set)
    __swig_setmethods__["skip"] = _sim2d.RDiffs_skip_set
    __swig_getmethods__["skip"] = _sim2d.RDiffs_skip_get
    if _newclass:
        skip = _swig_property(_sim2d.RDiffs_skip_get, _sim2d.RDiffs_skip_set)
    __swig_setmethods__["curt"] = _sim2d.RDiffs_curt_set
    __swig_getmethods__["curt"] = _sim2d.RDiffs_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.RDiffs_curt_get, _sim2d.RDiffs_curt_set)
    __swig_setmethods__["usecom"] = _sim2d.RDiffs_usecom_set
    __swig_getmethods__["usecom"] = _sim2d.RDiffs_usecom_get
    if _newclass:
        usecom = _swig_property(_sim2d.RDiffs_usecom_get, _sim2d.RDiffs_usecom_set)

    def __init__(self, atoms: 'boost::shared_ptr< atomgroup >', skip: 'unsigned long', usecom: 'bool'=False):
        """
        __init__(RDiffs self, boost::shared_ptr< atomgroup > atoms, unsigned long skip, bool usecom=False) -> RDiffs
        __init__(RDiffs self, boost::shared_ptr< atomgroup > atoms, unsigned long skip) -> RDiffs
        """
        this = _sim2d.new_RDiffs(atoms, skip, usecom)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        """reset(RDiffs self)"""
        return _sim2d.RDiffs_reset(self)


    def update(self, box: 'Box') -> "void":
        """update(RDiffs self, Box box)"""
        return _sim2d.RDiffs_update(self, box)


    def rdiffs(self) -> "std::vector< std::vector< flt > >":
        """rdiffs(RDiffs self) -> _ddvector"""
        return _sim2d.RDiffs_rdiffs(self)


    def get_skip(self) -> "unsigned long":
        """get_skip(RDiffs self) -> unsigned long"""
        return _sim2d.RDiffs_get_skip(self)

    __swig_destroy__ = _sim2d.delete_RDiffs
    __del__ = lambda self: None
RDiffs_swigregister = _sim2d.RDiffs_swigregister
RDiffs_swigregister(RDiffs)

class jamminglist(_object):
    """Proxy of C++ jamminglist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jamminglist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jamminglist, name)
    __repr__ = _swig_repr
    __swig_setmethods__["assigned"] = _sim2d.jamminglist_assigned_set
    __swig_getmethods__["assigned"] = _sim2d.jamminglist_assigned_get
    if _newclass:
        assigned = _swig_property(_sim2d.jamminglist_assigned_get, _sim2d.jamminglist_assigned_set)
    __swig_setmethods__["distsq"] = _sim2d.jamminglist_distsq_set
    __swig_getmethods__["distsq"] = _sim2d.jamminglist_distsq_get
    if _newclass:
        distsq = _swig_property(_sim2d.jamminglist_distsq_get, _sim2d.jamminglist_distsq_set)

    def __init__(self, *args):
        """
        __init__(jamminglist self) -> jamminglist
        __init__(jamminglist self, jamminglist other) -> jamminglist
        __init__(jamminglist self, jamminglist other, uint expand, flt addeddist) -> jamminglist
        """
        this = _sim2d.new_jamminglist(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def size(self) -> "uint":
        """size(jamminglist self) -> uint"""
        return _sim2d.jamminglist_size(self)


    def __lt__(self, other: 'jamminglist') -> "bool":
        """__lt__(jamminglist self, jamminglist other) -> bool"""
        return _sim2d.jamminglist___lt__(self, other)

    __swig_destroy__ = _sim2d.delete_jamminglist
    __del__ = lambda self: None
jamminglist_swigregister = _sim2d.jamminglist_swigregister
jamminglist_swigregister(jamminglist)

class jammingtree(_object):
    """Proxy of C++ jammingtree class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtree, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', A: 'std::vector< Vec > &', B: 'std::vector< Vec > &'):
        """__init__(jammingtree self, boost::shared_ptr< Box > box, std::vector< Vec > & A, std::vector< Vec > & B) -> jammingtree"""
        this = _sim2d.new_jammingtree(box, A, B)
        try:
            self.this.append(this)
        except:
            self.this = this

    def expand(self, *args) -> "bool":
        """
        expand(jammingtree self) -> bool
        expand(jammingtree self, uint n) -> bool
        """
        return _sim2d.jammingtree_expand(self, *args)


    def mylist(self) -> "std::list< jamminglist > &":
        """mylist(jammingtree self) -> _jamminglist"""
        return _sim2d.jammingtree_mylist(self)


    def copylist(self) -> "std::list< jamminglist >":
        """copylist(jammingtree self) -> _jamminglist"""
        return _sim2d.jammingtree_copylist(self)


    def curbest(self) -> "jamminglist":
        """curbest(jammingtree self) -> jamminglist"""
        return _sim2d.jammingtree_curbest(self)


    def size(self) -> "uint":
        """size(jammingtree self) -> uint"""
        return _sim2d.jammingtree_size(self)

    __swig_destroy__ = _sim2d.delete_jammingtree
    __del__ = lambda self: None
jammingtree_swigregister = _sim2d.jammingtree_swigregister
jammingtree_swigregister(jammingtree)

class jamminglistrot(jamminglist):
    """Proxy of C++ jamminglistrot class"""
    __swig_setmethods__ = {}
    for _s in [jamminglist]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, jamminglistrot, name, value)
    __swig_getmethods__ = {}
    for _s in [jamminglist]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, jamminglistrot, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rotation"] = _sim2d.jamminglistrot_rotation_set
    __swig_getmethods__["rotation"] = _sim2d.jamminglistrot_rotation_get
    if _newclass:
        rotation = _swig_property(_sim2d.jamminglistrot_rotation_get, _sim2d.jamminglistrot_rotation_set)

    def __init__(self, *args):
        """
        __init__(jamminglistrot self) -> jamminglistrot
        __init__(jamminglistrot self, uint rot) -> jamminglistrot
        __init__(jamminglistrot self, jamminglistrot other) -> jamminglistrot
        __init__(jamminglistrot self, jamminglistrot other, uint expand, flt addeddist) -> jamminglistrot
        """
        this = _sim2d.new_jamminglistrot(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __lt__(self, other: 'jamminglistrot') -> "bool":
        """__lt__(jamminglistrot self, jamminglistrot other) -> bool"""
        return _sim2d.jamminglistrot___lt__(self, other)

    __swig_destroy__ = _sim2d.delete_jamminglistrot
    __del__ = lambda self: None
jamminglistrot_swigregister = _sim2d.jamminglistrot_swigregister
jamminglistrot_swigregister(jamminglistrot)

class jammingtree2(_object):
    """Proxy of C++ jammingtree2 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtree2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtree2, name)
    __repr__ = _swig_repr

    def __init__(self, box: 'boost::shared_ptr< Box >', A: 'std::vector< Vec > &', B: 'std::vector< Vec > &'):
        """__init__(jammingtree2 self, boost::shared_ptr< Box > box, std::vector< Vec > & A, std::vector< Vec > & B) -> jammingtree2"""
        this = _sim2d.new_jammingtree2(box, A, B)
        try:
            self.this.append(this)
        except:
            self.this = this

    def distance(self, jlist: 'jamminglistrot') -> "flt":
        """distance(jammingtree2 self, jamminglistrot jlist) -> flt"""
        return _sim2d.jammingtree2_distance(self, jlist)


    def expand(self, *args) -> "bool":
        """
        expand(jammingtree2 self, jamminglistrot curjlist) -> _jamminglistrot
        expand(jammingtree2 self) -> bool
        expand(jammingtree2 self, uint n) -> bool
        """
        return _sim2d.jammingtree2_expand(self, *args)


    def expandto(self, maxdistsq: 'flt') -> "bool":
        """expandto(jammingtree2 self, flt maxdistsq) -> bool"""
        return _sim2d.jammingtree2_expandto(self, maxdistsq)


    def straight_diff(bx: 'Box', A: 'std::vector< Vec > &', B: 'std::vector< Vec > &') -> "Vec":
        """straight_diff(Box bx, std::vector< Vec > & A, std::vector< Vec > & B) -> Vec"""
        return _sim2d.jammingtree2_straight_diff(bx, A, B)

    if _newclass:
        straight_diff = staticmethod(straight_diff)
    __swig_getmethods__["straight_diff"] = lambda x: straight_diff

    def straight_distsq(bx: 'Box', A: 'std::vector< Vec > &', B: 'std::vector< Vec > &') -> "flt":
        """straight_distsq(Box bx, std::vector< Vec > & A, std::vector< Vec > & B) -> flt"""
        return _sim2d.jammingtree2_straight_distsq(bx, A, B)

    if _newclass:
        straight_distsq = staticmethod(straight_distsq)
    __swig_getmethods__["straight_distsq"] = lambda x: straight_distsq

    def mylist(self) -> "std::list< jamminglistrot > &":
        """mylist(jammingtree2 self) -> _jamminglistrot"""
        return _sim2d.jammingtree2_mylist(self)


    def copylist(self, *args) -> "std::list< jamminglistrot >":
        """
        copylist(jammingtree2 self) -> _jamminglistrot
        copylist(jammingtree2 self, uint n) -> _jamminglistrot
        """
        return _sim2d.jammingtree2_copylist(self, *args)


    def curbest(self) -> "jamminglistrot":
        """curbest(jammingtree2 self) -> jamminglistrot"""
        return _sim2d.jammingtree2_curbest(self)


    def size(self) -> "uint":
        """size(jammingtree2 self) -> uint"""
        return _sim2d.jammingtree2_size(self)


    def locationsB(self, *args) -> "std::vector< Vec >":
        """
        locationsB(jammingtree2 self, jamminglistrot jlist) -> std::vector< Vec >
        locationsB(jammingtree2 self) -> std::vector< Vec >
        """
        return _sim2d.jammingtree2_locationsB(self, *args)


    def locationsA(self, *args) -> "std::vector< Vec >":
        """
        locationsA(jammingtree2 self, jamminglistrot jlist) -> std::vector< Vec >
        locationsA(jammingtree2 self) -> std::vector< Vec >
        """
        return _sim2d.jammingtree2_locationsA(self, *args)

    __swig_destroy__ = _sim2d.delete_jammingtree2
    __del__ = lambda self: None
jammingtree2_swigregister = _sim2d.jammingtree2_swigregister
jammingtree2_swigregister(jammingtree2)

def jammingtree2_straight_diff(bx: 'Box', A: 'std::vector< Vec > &', B: 'std::vector< Vec > &') -> "Vec":
    """jammingtree2_straight_diff(Box bx, std::vector< Vec > & A, std::vector< Vec > & B) -> Vec"""
    return _sim2d.jammingtree2_straight_diff(bx, A, B)

def jammingtree2_straight_distsq(bx: 'Box', A: 'std::vector< Vec > &', B: 'std::vector< Vec > &') -> "flt":
    """jammingtree2_straight_distsq(Box bx, std::vector< Vec > & A, std::vector< Vec > & B) -> flt"""
    return _sim2d.jammingtree2_straight_distsq(bx, A, B)

class jammingtreeBD(jammingtree2):
    """Proxy of C++ jammingtreeBD class"""
    __swig_setmethods__ = {}
    for _s in [jammingtree2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtreeBD, name, value)
    __swig_getmethods__ = {}
    for _s in [jammingtree2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtreeBD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(jammingtreeBD self, boost::shared_ptr< Box > box, std::vector< Vec > & A, std::vector< Vec > & B, uint cutoff) -> jammingtreeBD
        __init__(jammingtreeBD self, boost::shared_ptr< Box > box, std::vector< Vec > & A, std::vector< Vec > & B, uint cutoffA, uint cutoffB) -> jammingtreeBD
        """
        this = _sim2d.new_jammingtreeBD(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def expand(self, *args) -> "bool":
        """
        expand(jammingtreeBD self, jamminglistrot curjlist) -> _jamminglistrot
        expand(jammingtreeBD self) -> bool
        expand(jammingtreeBD self, uint n) -> bool
        """
        return _sim2d.jammingtreeBD_expand(self, *args)

    __swig_destroy__ = _sim2d.delete_jammingtreeBD
    __del__ = lambda self: None
jammingtreeBD_swigregister = _sim2d.jammingtreeBD_swigregister
jammingtreeBD_swigregister(jammingtreeBD)

class CNode(_object):
    """Proxy of C++ CNode class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNode, name)
    __repr__ = _swig_repr
    __swig_setmethods__["n"] = _sim2d.CNode_n_set
    __swig_getmethods__["n"] = _sim2d.CNode_n_get
    if _newclass:
        n = _swig_property(_sim2d.CNode_n_get, _sim2d.CNode_n_set)
    __swig_setmethods__["x"] = _sim2d.CNode_x_set
    __swig_getmethods__["x"] = _sim2d.CNode_x_get
    if _newclass:
        x = _swig_property(_sim2d.CNode_x_get, _sim2d.CNode_x_set)

    def __init__(self, *args):
        """
        __init__(CNode self) -> CNode
        __init__(CNode self, int n, Vec x) -> CNode
        """
        this = _sim2d.new_CNode(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __ne__(self, other: 'CNode') -> "bool":
        """__ne__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___ne__(self, other)


    def __eq__(self, other: 'CNode') -> "bool":
        """__eq__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___eq__(self, other)


    def __lt__(self, other: 'CNode') -> "bool":
        """__lt__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___lt__(self, other)


    def __gt__(self, other: 'CNode') -> "bool":
        """__gt__(CNode self, CNode other) -> bool"""
        return _sim2d.CNode___gt__(self, other)

    __swig_destroy__ = _sim2d.delete_CNode
    __del__ = lambda self: None
CNode_swigregister = _sim2d.CNode_swigregister
CNode_swigregister(CNode)

class CNodePath(_object):
    """Proxy of C++ CNodePath class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNodePath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNodePath, name)
    __repr__ = _swig_repr
    __swig_setmethods__["distance"] = _sim2d.CNodePath_distance_set
    __swig_getmethods__["distance"] = _sim2d.CNodePath_distance_get
    if _newclass:
        distance = _swig_property(_sim2d.CNodePath_distance_get, _sim2d.CNodePath_distance_set)
    __swig_setmethods__["nodes"] = _sim2d.CNodePath_nodes_set
    __swig_getmethods__["nodes"] = _sim2d.CNodePath_nodes_get
    if _newclass:
        nodes = _swig_property(_sim2d.CNodePath_nodes_get, _sim2d.CNodePath_nodes_set)

    def __init__(self, *args):
        """
        __init__(CNodePath self) -> CNodePath
        __init__(CNodePath self, CNode node) -> CNodePath
        __init__(CNodePath self, CNodePath other, CNode node, OriginBox box) -> CNodePath
        """
        this = _sim2d.new_CNodePath(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, node: 'CNode', box: 'OriginBox') -> "void":
        """add(CNodePath self, CNode node, OriginBox box)"""
        return _sim2d.CNodePath_add(self, node, box)


    def size(self) -> "uint":
        """size(CNodePath self) -> uint"""
        return _sim2d.CNodePath_size(self)

    __swig_destroy__ = _sim2d.delete_CNodePath
    __del__ = lambda self: None
CNodePath_swigregister = _sim2d.CNodePath_swigregister
CNodePath_swigregister(CNodePath)

class Connectivity(_object):
    """Proxy of C++ Connectivity class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Connectivity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Connectivity, name)
    __repr__ = _swig_repr
    __swig_setmethods__["box"] = _sim2d.Connectivity_box_set
    __swig_getmethods__["box"] = _sim2d.Connectivity_box_get
    if _newclass:
        box = _swig_property(_sim2d.Connectivity_box_get, _sim2d.Connectivity_box_set)
    __swig_setmethods__["nodes"] = _sim2d.Connectivity_nodes_set
    __swig_getmethods__["nodes"] = _sim2d.Connectivity_nodes_get
    if _newclass:
        nodes = _swig_property(_sim2d.Connectivity_nodes_get, _sim2d.Connectivity_nodes_set)
    __swig_setmethods__["neighbors"] = _sim2d.Connectivity_neighbors_set
    __swig_getmethods__["neighbors"] = _sim2d.Connectivity_neighbors_get
    if _newclass:
        neighbors = _swig_property(_sim2d.Connectivity_neighbors_get, _sim2d.Connectivity_neighbors_set)

    def nonzero(self, diff_vec: 'Vec') -> "array< bool,2 >":
        """nonzero(Connectivity self, Vec diff_vec) -> array< bool,2 >"""
        return _sim2d.Connectivity_nonzero(self, diff_vec)


    def make_cycle(self, forward: 'CNodePath', backward: 'CNodePath') -> "CNodePath":
        """make_cycle(Connectivity self, CNodePath forward, CNodePath backward) -> CNodePath"""
        return _sim2d.Connectivity_make_cycle(self, forward, backward)


    def circular_from(self, node: 'CNode', visited: 'std::set< uint > &', check_all: 'bool') -> "std::map< uint,CNodePath >":
        """circular_from(Connectivity self, CNode node, std::set< uint > & visited, bool check_all) -> map_uint_CNodePath"""
        return _sim2d.Connectivity_circular_from(self, node, visited, check_all)


    def __init__(self, box: 'boost::shared_ptr< OriginBox >'):
        """__init__(Connectivity self, boost::shared_ptr< OriginBox > box) -> Connectivity"""
        this = _sim2d.new_Connectivity(box)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add_edge(self, node1: 'CNode', node2: 'CNode') -> "void":
        """add_edge(Connectivity self, CNode node1, CNode node2)"""
        return _sim2d.Connectivity_add_edge(self, node1, node2)


    def add(self, locs: 'std::vector< Vec >', diameters: 'dvector') -> "void":
        """add(Connectivity self, std::vector< Vec > locs, dvector diameters)"""
        return _sim2d.Connectivity_add(self, locs, diameters)


    def find_percolation(self, check_all_dims: 'bool'=True) -> "std::map< uint,CNodePath >":
        """
        find_percolation(Connectivity self, bool check_all_dims=True) -> map_uint_CNodePath
        find_percolation(Connectivity self) -> map_uint_CNodePath
        """
        return _sim2d.Connectivity_find_percolation(self, check_all_dims)

    __swig_destroy__ = _sim2d.delete_Connectivity
    __del__ = lambda self: None
Connectivity_swigregister = _sim2d.Connectivity_swigregister
Connectivity_swigregister(Connectivity)

class LJgroup(interaction):
    """Proxy of C++ NListed<(LJatom,LJpair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJgroup, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJgroup, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LJatom') -> "void":
        """add(LJgroup self, LJatom atm)"""
        return _sim2d.LJgroup_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LJatom,LJpair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LJgroup
        __init__(NListed<(LJatom,LJpair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LJgroup
        """
        this = _sim2d.new_LJgroup(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJgroup self)"""
        return _sim2d.LJgroup_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LJpair":
        """getpair(LJgroup self, idpair pair) -> LJpair"""
        return _sim2d.LJgroup_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LJatom &":
        """getatom(LJgroup self, uint n) -> LJatom"""
        return _sim2d.LJgroup_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJgroup self, Box box, idpair pair) -> flt
        energy(LJgroup self, Box box) -> flt
        """
        return _sim2d.LJgroup_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJgroup self, Box box) -> unsigned long long"""
        return _sim2d.LJgroup_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJgroup self, Box box) -> unsigned long long"""
        return _sim2d.LJgroup_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJgroup self, Box box) -> flt"""
        return _sim2d.LJgroup_pressure(self, box)


    def pairiter(self) -> "std::vector< LJpair > &":
        """pairiter(LJgroup self) -> std::vector< LJpair > &"""
        return _sim2d.LJgroup_pairiter(self)


    def size(self) -> "uint":
        """size(LJgroup self) -> uint"""
        return _sim2d.LJgroup_size(self)


    def energy_pair(self, pair: 'LJpair', box: 'Box') -> "flt":
        """energy_pair(LJgroup self, LJpair pair, Box box) -> flt"""
        return _sim2d.LJgroup_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJgroup self, Box box)"""
        return _sim2d.LJgroup_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LJgroup self, Box box) -> flt"""
        return _sim2d.LJgroup_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LJpair', box: 'Box') -> "Vec":
        """forces_pair(LJgroup self, LJpair pair, Box box) -> Vec"""
        return _sim2d.LJgroup_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LJatom > &":
        """atom_list(LJgroup self) -> std::vector< LJatom > &"""
        return _sim2d.LJgroup_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LJgroup self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LJgroup_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJgroup
    __del__ = lambda self: None

    def add_atom(self, epsilon, sigma, a):
        self.add(LJatom(epsilon, sigma, a))

LJgroup_swigregister = _sim2d.LJgroup_swigregister
LJgroup_swigregister(LJgroup)

class Hydrophobicity(interaction):
    """Proxy of C++ NListed<(HydroAtom,HydroPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hydrophobicity, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hydrophobicity, name)
    __repr__ = _swig_repr

    def add(self, atm: 'HydroAtom') -> "void":
        """add(Hydrophobicity self, HydroAtom atm)"""
        return _sim2d.Hydrophobicity_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(HydroAtom,HydroPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> Hydrophobicity
        __init__(NListed<(HydroAtom,HydroPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> Hydrophobicity
        """
        this = _sim2d.new_Hydrophobicity(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(Hydrophobicity self)"""
        return _sim2d.Hydrophobicity_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "HydroPair":
        """getpair(Hydrophobicity self, idpair pair) -> HydroPair"""
        return _sim2d.Hydrophobicity_getpair(self, pair)


    def getatom(self, n: 'uint') -> "HydroAtom &":
        """getatom(Hydrophobicity self, uint n) -> HydroAtom"""
        return _sim2d.Hydrophobicity_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(Hydrophobicity self, Box box, idpair pair) -> flt
        energy(Hydrophobicity self, Box box) -> flt
        """
        return _sim2d.Hydrophobicity_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(Hydrophobicity self, Box box) -> unsigned long long"""
        return _sim2d.Hydrophobicity_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(Hydrophobicity self, Box box) -> unsigned long long"""
        return _sim2d.Hydrophobicity_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(Hydrophobicity self, Box box) -> flt"""
        return _sim2d.Hydrophobicity_pressure(self, box)


    def pairiter(self) -> "std::vector< HydroPair > &":
        """pairiter(Hydrophobicity self) -> std::vector< HydroPair > &"""
        return _sim2d.Hydrophobicity_pairiter(self)


    def size(self) -> "uint":
        """size(Hydrophobicity self) -> uint"""
        return _sim2d.Hydrophobicity_size(self)


    def energy_pair(self, pair: 'HydroPair', box: 'Box') -> "flt":
        """energy_pair(Hydrophobicity self, HydroPair pair, Box box) -> flt"""
        return _sim2d.Hydrophobicity_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(Hydrophobicity self, Box box)"""
        return _sim2d.Hydrophobicity_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(Hydrophobicity self, Box box) -> flt"""
        return _sim2d.Hydrophobicity_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'HydroPair', box: 'Box') -> "Vec":
        """forces_pair(Hydrophobicity self, HydroPair pair, Box box) -> Vec"""
        return _sim2d.Hydrophobicity_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< HydroAtom > &":
        """atom_list(Hydrophobicity self) -> std::vector< HydroAtom > &"""
        return _sim2d.Hydrophobicity_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(Hydrophobicity self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.Hydrophobicity_nlist(self)

    __swig_destroy__ = _sim2d.delete_Hydrophobicity
    __del__ = lambda self: None
Hydrophobicity_swigregister = _sim2d.Hydrophobicity_swigregister
Hydrophobicity_swigregister(Hydrophobicity)

class LJattractix(interaction):
    """Proxy of C++ NListed<(LJAtomIndexed,LJAttractPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattractix, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJattractix, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LJAtomIndexed') -> "void":
        """add(LJattractix self, LJAtomIndexed atm)"""
        return _sim2d.LJattractix_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LJAtomIndexed,LJAttractPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LJattractix
        __init__(NListed<(LJAtomIndexed,LJAttractPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LJattractix
        """
        this = _sim2d.new_LJattractix(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJattractix self)"""
        return _sim2d.LJattractix_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LJAttractPair":
        """getpair(LJattractix self, idpair pair) -> LJAttractPair"""
        return _sim2d.LJattractix_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LJAtomIndexed &":
        """getatom(LJattractix self, uint n) -> LJAtomIndexed"""
        return _sim2d.LJattractix_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJattractix self, Box box, idpair pair) -> flt
        energy(LJattractix self, Box box) -> flt
        """
        return _sim2d.LJattractix_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJattractix self, Box box) -> unsigned long long"""
        return _sim2d.LJattractix_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJattractix self, Box box) -> unsigned long long"""
        return _sim2d.LJattractix_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJattractix self, Box box) -> flt"""
        return _sim2d.LJattractix_pressure(self, box)


    def pairiter(self) -> "std::vector< LJAttractPair > &":
        """pairiter(LJattractix self) -> std::vector< LJAttractPair > &"""
        return _sim2d.LJattractix_pairiter(self)


    def size(self) -> "uint":
        """size(LJattractix self) -> uint"""
        return _sim2d.LJattractix_size(self)


    def energy_pair(self, pair: 'LJAttractPair', box: 'Box') -> "flt":
        """energy_pair(LJattractix self, LJAttractPair pair, Box box) -> flt"""
        return _sim2d.LJattractix_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJattractix self, Box box)"""
        return _sim2d.LJattractix_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LJattractix self, Box box) -> flt"""
        return _sim2d.LJattractix_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LJAttractPair', box: 'Box') -> "Vec":
        """forces_pair(LJattractix self, LJAttractPair pair, Box box) -> Vec"""
        return _sim2d.LJattractix_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LJAtomIndexed > &":
        """atom_list(LJattractix self) -> std::vector< LJAtomIndexed > &"""
        return _sim2d.LJattractix_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LJattractix self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LJattractix_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJattractix
    __del__ = lambda self: None
LJattractix_swigregister = _sim2d.LJattractix_swigregister
LJattractix_swigregister(LJattractix)

class LJfullix(interaction):
    """Proxy of C++ NListed<(LJAtomIndexed,LJCutPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJfullix, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJfullix, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LJAtomIndexed') -> "void":
        """add(LJfullix self, LJAtomIndexed atm)"""
        return _sim2d.LJfullix_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LJAtomIndexed,LJCutPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LJfullix
        __init__(NListed<(LJAtomIndexed,LJCutPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LJfullix
        """
        this = _sim2d.new_LJfullix(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJfullix self)"""
        return _sim2d.LJfullix_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LJCutPair":
        """getpair(LJfullix self, idpair pair) -> LJCutPair"""
        return _sim2d.LJfullix_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LJAtomIndexed &":
        """getatom(LJfullix self, uint n) -> LJAtomIndexed"""
        return _sim2d.LJfullix_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJfullix self, Box box, idpair pair) -> flt
        energy(LJfullix self, Box box) -> flt
        """
        return _sim2d.LJfullix_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJfullix self, Box box) -> unsigned long long"""
        return _sim2d.LJfullix_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJfullix self, Box box) -> unsigned long long"""
        return _sim2d.LJfullix_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJfullix self, Box box) -> flt"""
        return _sim2d.LJfullix_pressure(self, box)


    def pairiter(self) -> "std::vector< LJCutPair > &":
        """pairiter(LJfullix self) -> std::vector< LJCutPair > &"""
        return _sim2d.LJfullix_pairiter(self)


    def size(self) -> "uint":
        """size(LJfullix self) -> uint"""
        return _sim2d.LJfullix_size(self)


    def energy_pair(self, pair: 'LJCutPair', box: 'Box') -> "flt":
        """energy_pair(LJfullix self, LJCutPair pair, Box box) -> flt"""
        return _sim2d.LJfullix_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJfullix self, Box box)"""
        return _sim2d.LJfullix_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LJfullix self, Box box) -> flt"""
        return _sim2d.LJfullix_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LJCutPair', box: 'Box') -> "Vec":
        """forces_pair(LJfullix self, LJCutPair pair, Box box) -> Vec"""
        return _sim2d.LJfullix_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LJAtomIndexed > &":
        """atom_list(LJfullix self) -> std::vector< LJAtomIndexed > &"""
        return _sim2d.LJfullix_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LJfullix self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LJfullix_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJfullix
    __del__ = lambda self: None
LJfullix_swigregister = _sim2d.LJfullix_swigregister
LJfullix_swigregister(LJfullix)

class LJAttractRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulse, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LJAttractRepulseAtom') -> "void":
        """add(LJAttractRepulse self, LJAttractRepulseAtom atm)"""
        return _sim2d.LJAttractRepulse_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LJAttractRepulse
        __init__(NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LJAttractRepulse
        """
        this = _sim2d.new_LJAttractRepulse(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJAttractRepulse self)"""
        return _sim2d.LJAttractRepulse_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LJAttractRepulsePair":
        """getpair(LJAttractRepulse self, idpair pair) -> LJAttractRepulsePair"""
        return _sim2d.LJAttractRepulse_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LJAttractRepulseAtom &":
        """getatom(LJAttractRepulse self, uint n) -> LJAttractRepulseAtom"""
        return _sim2d.LJAttractRepulse_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJAttractRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractRepulse self, Box box) -> flt
        """
        return _sim2d.LJAttractRepulse_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJAttractRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractRepulse_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJAttractRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractRepulse_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_pressure(self, box)


    def pairiter(self) -> "std::vector< LJAttractRepulsePair > &":
        """pairiter(LJAttractRepulse self) -> std::vector< LJAttractRepulsePair > &"""
        return _sim2d.LJAttractRepulse_pairiter(self)


    def size(self) -> "uint":
        """size(LJAttractRepulse self) -> uint"""
        return _sim2d.LJAttractRepulse_size(self)


    def energy_pair(self, pair: 'LJAttractRepulsePair', box: 'Box') -> "flt":
        """energy_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJAttractRepulse self, Box box)"""
        return _sim2d.LJAttractRepulse_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LJAttractRepulsePair', box: 'Box') -> "Vec":
        """forces_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> Vec"""
        return _sim2d.LJAttractRepulse_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LJAttractRepulseAtom > &":
        """atom_list(LJAttractRepulse self) -> std::vector< LJAttractRepulseAtom > &"""
        return _sim2d.LJAttractRepulse_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LJAttractRepulse self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LJAttractRepulse_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulse
    __del__ = lambda self: None
LJAttractRepulse_swigregister = _sim2d.LJAttractRepulse_swigregister
LJAttractRepulse_swigregister(LJAttractRepulse)

class LJAttractFixedRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulse, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LJAttractFixedRepulseAtom') -> "void":
        """add(LJAttractFixedRepulse self, LJAttractFixedRepulseAtom atm)"""
        return _sim2d.LJAttractFixedRepulse_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LJAttractFixedRepulse
        __init__(NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LJAttractFixedRepulse
        """
        this = _sim2d.new_LJAttractFixedRepulse(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJAttractFixedRepulse self)"""
        return _sim2d.LJAttractFixedRepulse_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LJAttractFixedRepulsePair":
        """getpair(LJAttractFixedRepulse self, idpair pair) -> LJAttractFixedRepulsePair"""
        return _sim2d.LJAttractFixedRepulse_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LJAttractFixedRepulseAtom &":
        """getatom(LJAttractFixedRepulse self, uint n) -> LJAttractFixedRepulseAtom"""
        return _sim2d.LJAttractFixedRepulse_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJAttractFixedRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractFixedRepulse self, Box box) -> flt
        """
        return _sim2d.LJAttractFixedRepulse_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJAttractFixedRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractFixedRepulse_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJAttractFixedRepulse self, Box box) -> unsigned long long"""
        return _sim2d.LJAttractFixedRepulse_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_pressure(self, box)


    def pairiter(self) -> "std::vector< LJAttractFixedRepulsePair > &":
        """pairiter(LJAttractFixedRepulse self) -> std::vector< LJAttractFixedRepulsePair > &"""
        return _sim2d.LJAttractFixedRepulse_pairiter(self)


    def size(self) -> "uint":
        """size(LJAttractFixedRepulse self) -> uint"""
        return _sim2d.LJAttractFixedRepulse_size(self)


    def energy_pair(self, pair: 'LJAttractFixedRepulsePair', box: 'Box') -> "flt":
        """energy_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJAttractFixedRepulse self, Box box)"""
        return _sim2d.LJAttractFixedRepulse_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LJAttractFixedRepulsePair', box: 'Box') -> "Vec":
        """forces_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> Vec"""
        return _sim2d.LJAttractFixedRepulse_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LJAttractFixedRepulseAtom > &":
        """atom_list(LJAttractFixedRepulse self) -> std::vector< LJAttractFixedRepulseAtom > &"""
        return _sim2d.LJAttractFixedRepulse_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LJAttractFixedRepulse self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LJAttractFixedRepulse_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulse
    __del__ = lambda self: None
LJAttractFixedRepulse_swigregister = _sim2d.LJAttractFixedRepulse_swigregister
LJAttractFixedRepulse_swigregister(LJAttractFixedRepulse)

class LJDouble(interaction):
    """Proxy of C++ NListed<(LJDoubleAtom,LJDoublePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDouble, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDouble, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LJDoubleAtom') -> "void":
        """add(LJDouble self, LJDoubleAtom atm)"""
        return _sim2d.LJDouble_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LJDoubleAtom,LJDoublePair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LJDouble
        __init__(NListed<(LJDoubleAtom,LJDoublePair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LJDouble
        """
        this = _sim2d.new_LJDouble(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJDouble self)"""
        return _sim2d.LJDouble_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LJDoublePair":
        """getpair(LJDouble self, idpair pair) -> LJDoublePair"""
        return _sim2d.LJDouble_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LJDoubleAtom &":
        """getatom(LJDouble self, uint n) -> LJDoubleAtom"""
        return _sim2d.LJDouble_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJDouble self, Box box, idpair pair) -> flt
        energy(LJDouble self, Box box) -> flt
        """
        return _sim2d.LJDouble_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJDouble self, Box box) -> unsigned long long"""
        return _sim2d.LJDouble_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJDouble self, Box box) -> unsigned long long"""
        return _sim2d.LJDouble_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJDouble self, Box box) -> flt"""
        return _sim2d.LJDouble_pressure(self, box)


    def pairiter(self) -> "std::vector< LJDoublePair > &":
        """pairiter(LJDouble self) -> std::vector< LJDoublePair > &"""
        return _sim2d.LJDouble_pairiter(self)


    def size(self) -> "uint":
        """size(LJDouble self) -> uint"""
        return _sim2d.LJDouble_size(self)


    def energy_pair(self, pair: 'LJDoublePair', box: 'Box') -> "flt":
        """energy_pair(LJDouble self, LJDoublePair pair, Box box) -> flt"""
        return _sim2d.LJDouble_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJDouble self, Box box)"""
        return _sim2d.LJDouble_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LJDouble self, Box box) -> flt"""
        return _sim2d.LJDouble_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LJDoublePair', box: 'Box') -> "Vec":
        """forces_pair(LJDouble self, LJDoublePair pair, Box box) -> Vec"""
        return _sim2d.LJDouble_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LJDoubleAtom > &":
        """atom_list(LJDouble self) -> std::vector< LJDoubleAtom > &"""
        return _sim2d.LJDouble_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LJDouble self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LJDouble_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJDouble
    __del__ = lambda self: None
LJDouble_swigregister = _sim2d.LJDouble_swigregister
LJDouble_swigregister(LJDouble)

class EisMclachlan(interaction):
    """Proxy of C++ NListed<(EisMclachlanAtom,EisMclachlanPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlan, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlan, name)
    __repr__ = _swig_repr

    def add(self, atm: 'EisMclachlanAtom') -> "void":
        """add(EisMclachlan self, EisMclachlanAtom atm)"""
        return _sim2d.EisMclachlan_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(EisMclachlanAtom,EisMclachlanPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> EisMclachlan
        __init__(NListed<(EisMclachlanAtom,EisMclachlanPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> EisMclachlan
        """
        this = _sim2d.new_EisMclachlan(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(EisMclachlan self)"""
        return _sim2d.EisMclachlan_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "EisMclachlanPair":
        """getpair(EisMclachlan self, idpair pair) -> EisMclachlanPair"""
        return _sim2d.EisMclachlan_getpair(self, pair)


    def getatom(self, n: 'uint') -> "EisMclachlanAtom &":
        """getatom(EisMclachlan self, uint n) -> EisMclachlanAtom"""
        return _sim2d.EisMclachlan_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(EisMclachlan self, Box box, idpair pair) -> flt
        energy(EisMclachlan self, Box box) -> flt
        """
        return _sim2d.EisMclachlan_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(EisMclachlan self, Box box) -> unsigned long long"""
        return _sim2d.EisMclachlan_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(EisMclachlan self, Box box) -> unsigned long long"""
        return _sim2d.EisMclachlan_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(EisMclachlan self, Box box) -> flt"""
        return _sim2d.EisMclachlan_pressure(self, box)


    def pairiter(self) -> "std::vector< EisMclachlanPair > &":
        """pairiter(EisMclachlan self) -> std::vector< EisMclachlanPair > &"""
        return _sim2d.EisMclachlan_pairiter(self)


    def size(self) -> "uint":
        """size(EisMclachlan self) -> uint"""
        return _sim2d.EisMclachlan_size(self)


    def energy_pair(self, pair: 'EisMclachlanPair', box: 'Box') -> "flt":
        """energy_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> flt"""
        return _sim2d.EisMclachlan_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(EisMclachlan self, Box box)"""
        return _sim2d.EisMclachlan_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(EisMclachlan self, Box box) -> flt"""
        return _sim2d.EisMclachlan_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'EisMclachlanPair', box: 'Box') -> "Vec":
        """forces_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> Vec"""
        return _sim2d.EisMclachlan_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< EisMclachlanAtom > &":
        """atom_list(EisMclachlan self) -> std::vector< EisMclachlanAtom > &"""
        return _sim2d.EisMclachlan_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(EisMclachlan self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.EisMclachlan_nlist(self)

    __swig_destroy__ = _sim2d.delete_EisMclachlan
    __del__ = lambda self: None
EisMclachlan_swigregister = _sim2d.EisMclachlan_swigregister
EisMclachlan_swigregister(EisMclachlan)

class LJish(interaction):
    """Proxy of C++ NListed<(LJishAtom,LJishPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJish, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJish, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LJishAtom') -> "void":
        """add(LJish self, LJishAtom atm)"""
        return _sim2d.LJish_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LJishAtom,LJishPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LJish
        __init__(NListed<(LJishAtom,LJishPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LJish
        """
        this = _sim2d.new_LJish(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LJish self)"""
        return _sim2d.LJish_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LJishPair":
        """getpair(LJish self, idpair pair) -> LJishPair"""
        return _sim2d.LJish_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LJishAtom &":
        """getatom(LJish self, uint n) -> LJishAtom"""
        return _sim2d.LJish_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LJish self, Box box, idpair pair) -> flt
        energy(LJish self, Box box) -> flt
        """
        return _sim2d.LJish_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LJish self, Box box) -> unsigned long long"""
        return _sim2d.LJish_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LJish self, Box box) -> unsigned long long"""
        return _sim2d.LJish_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LJish self, Box box) -> flt"""
        return _sim2d.LJish_pressure(self, box)


    def pairiter(self) -> "std::vector< LJishPair > &":
        """pairiter(LJish self) -> std::vector< LJishPair > &"""
        return _sim2d.LJish_pairiter(self)


    def size(self) -> "uint":
        """size(LJish self) -> uint"""
        return _sim2d.LJish_size(self)


    def energy_pair(self, pair: 'LJishPair', box: 'Box') -> "flt":
        """energy_pair(LJish self, LJishPair pair, Box box) -> flt"""
        return _sim2d.LJish_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LJish self, Box box)"""
        return _sim2d.LJish_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LJish self, Box box) -> flt"""
        return _sim2d.LJish_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LJishPair', box: 'Box') -> "Vec":
        """forces_pair(LJish self, LJishPair pair, Box box) -> Vec"""
        return _sim2d.LJish_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LJishAtom > &":
        """atom_list(LJish self) -> std::vector< LJishAtom > &"""
        return _sim2d.LJish_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LJish self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LJish_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJish
    __del__ = lambda self: None
LJish_swigregister = _sim2d.LJish_swigregister
LJish_swigregister(LJish)

class HertzianSimple(interaction):
    """Proxy of C++ SimpleListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianSimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianSimple, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(SimpleListed<(HertzianAtom,HertzianPair)> self) -> HertzianSimple"""
        this = _sim2d.new_HertzianSimple()
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, atm: 'HertzianAtom') -> "void":
        """add(HertzianSimple self, HertzianAtom atm)"""
        return _sim2d.HertzianSimple_add(self, atm)


    def energy(self, box: 'Box') -> "flt":
        """energy(HertzianSimple self, Box box) -> flt"""
        return _sim2d.HertzianSimple_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianSimple self, Box box) -> flt"""
        return _sim2d.HertzianSimple_pressure(self, box)


    def size(self) -> "uint":
        """size(HertzianSimple self) -> uint"""
        return _sim2d.HertzianSimple_size(self)


    def setForces(self, box: 'Box') -> "void":
        """setForces(HertzianSimple self, Box box)"""
        return _sim2d.HertzianSimple_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(HertzianSimple self, Box box) -> flt"""
        return _sim2d.HertzianSimple_setForcesGetPressure(self, box)


    def atom_list(self) -> "std::vector< HertzianAtom > &":
        """atom_list(HertzianSimple self) -> std::vector< HertzianAtom > &"""
        return _sim2d.HertzianSimple_atom_list(self)

    __swig_destroy__ = _sim2d.delete_HertzianSimple
    __del__ = lambda self: None
HertzianSimple_swigregister = _sim2d.HertzianSimple_swigregister
HertzianSimple_swigregister(HertzianSimple)

class Hertzian(interaction):
    """Proxy of C++ NListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hertzian, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hertzian, name)
    __repr__ = _swig_repr

    def add(self, atm: 'HertzianAtom') -> "void":
        """add(Hertzian self, HertzianAtom atm)"""
        return _sim2d.Hertzian_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(HertzianAtom,HertzianPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> Hertzian
        __init__(NListed<(HertzianAtom,HertzianPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> Hertzian
        """
        this = _sim2d.new_Hertzian(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(Hertzian self)"""
        return _sim2d.Hertzian_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "HertzianPair":
        """getpair(Hertzian self, idpair pair) -> HertzianPair"""
        return _sim2d.Hertzian_getpair(self, pair)


    def getatom(self, n: 'uint') -> "HertzianAtom &":
        """getatom(Hertzian self, uint n) -> HertzianAtom"""
        return _sim2d.Hertzian_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(Hertzian self, Box box, idpair pair) -> flt
        energy(Hertzian self, Box box) -> flt
        """
        return _sim2d.Hertzian_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(Hertzian self, Box box) -> unsigned long long"""
        return _sim2d.Hertzian_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(Hertzian self, Box box) -> unsigned long long"""
        return _sim2d.Hertzian_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(Hertzian self, Box box) -> flt"""
        return _sim2d.Hertzian_pressure(self, box)


    def pairiter(self) -> "std::vector< HertzianPair > &":
        """pairiter(Hertzian self) -> std::vector< HertzianPair > &"""
        return _sim2d.Hertzian_pairiter(self)


    def size(self) -> "uint":
        """size(Hertzian self) -> uint"""
        return _sim2d.Hertzian_size(self)


    def energy_pair(self, pair: 'HertzianPair', box: 'Box') -> "flt":
        """energy_pair(Hertzian self, HertzianPair pair, Box box) -> flt"""
        return _sim2d.Hertzian_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(Hertzian self, Box box)"""
        return _sim2d.Hertzian_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(Hertzian self, Box box) -> flt"""
        return _sim2d.Hertzian_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'HertzianPair', box: 'Box') -> "Vec":
        """forces_pair(Hertzian self, HertzianPair pair, Box box) -> Vec"""
        return _sim2d.Hertzian_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< HertzianAtom > &":
        """atom_list(Hertzian self) -> std::vector< HertzianAtom > &"""
        return _sim2d.Hertzian_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(Hertzian self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.Hertzian_nlist(self)

    __swig_destroy__ = _sim2d.delete_Hertzian
    __del__ = lambda self: None
Hertzian_swigregister = _sim2d.Hertzian_swigregister
Hertzian_swigregister(Hertzian)

class HertzianIdx(interaction):
    """Proxy of C++ NListed<(HertzianAtomIndexed,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianIdx, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianIdx, name)
    __repr__ = _swig_repr

    def add(self, atm: 'HertzianAtomIndexed') -> "void":
        """add(HertzianIdx self, HertzianAtomIndexed atm)"""
        return _sim2d.HertzianIdx_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(HertzianAtomIndexed,HertzianPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> HertzianIdx
        __init__(NListed<(HertzianAtomIndexed,HertzianPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> HertzianIdx
        """
        this = _sim2d.new_HertzianIdx(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(HertzianIdx self)"""
        return _sim2d.HertzianIdx_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "HertzianPair":
        """getpair(HertzianIdx self, idpair pair) -> HertzianPair"""
        return _sim2d.HertzianIdx_getpair(self, pair)


    def getatom(self, n: 'uint') -> "HertzianAtomIndexed &":
        """getatom(HertzianIdx self, uint n) -> HertzianAtomIndexed"""
        return _sim2d.HertzianIdx_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(HertzianIdx self, Box box, idpair pair) -> flt
        energy(HertzianIdx self, Box box) -> flt
        """
        return _sim2d.HertzianIdx_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(HertzianIdx self, Box box) -> unsigned long long"""
        return _sim2d.HertzianIdx_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(HertzianIdx self, Box box) -> unsigned long long"""
        return _sim2d.HertzianIdx_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianIdx self, Box box) -> flt"""
        return _sim2d.HertzianIdx_pressure(self, box)


    def pairiter(self) -> "std::vector< HertzianPair > &":
        """pairiter(HertzianIdx self) -> std::vector< HertzianPair > &"""
        return _sim2d.HertzianIdx_pairiter(self)


    def size(self) -> "uint":
        """size(HertzianIdx self) -> uint"""
        return _sim2d.HertzianIdx_size(self)


    def energy_pair(self, pair: 'HertzianPair', box: 'Box') -> "flt":
        """energy_pair(HertzianIdx self, HertzianPair pair, Box box) -> flt"""
        return _sim2d.HertzianIdx_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(HertzianIdx self, Box box)"""
        return _sim2d.HertzianIdx_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(HertzianIdx self, Box box) -> flt"""
        return _sim2d.HertzianIdx_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'HertzianPair', box: 'Box') -> "Vec":
        """forces_pair(HertzianIdx self, HertzianPair pair, Box box) -> Vec"""
        return _sim2d.HertzianIdx_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< HertzianAtomIndexed > &":
        """atom_list(HertzianIdx self) -> std::vector< HertzianAtomIndexed > &"""
        return _sim2d.HertzianIdx_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(HertzianIdx self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.HertzianIdx_nlist(self)

    __swig_destroy__ = _sim2d.delete_HertzianIdx
    __del__ = lambda self: None
HertzianIdx_swigregister = _sim2d.HertzianIdx_swigregister
HertzianIdx_swigregister(HertzianIdx)

class HertzianDrag(interaction):
    """Proxy of C++ NListed<(HertzianDragAtom,HertzianDragPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianDrag, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianDrag, name)
    __repr__ = _swig_repr

    def add(self, atm: 'HertzianDragAtom') -> "void":
        """add(HertzianDrag self, HertzianDragAtom atm)"""
        return _sim2d.HertzianDrag_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(HertzianDragAtom,HertzianDragPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> HertzianDrag
        __init__(NListed<(HertzianDragAtom,HertzianDragPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> HertzianDrag
        """
        this = _sim2d.new_HertzianDrag(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(HertzianDrag self)"""
        return _sim2d.HertzianDrag_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "HertzianDragPair":
        """getpair(HertzianDrag self, idpair pair) -> HertzianDragPair"""
        return _sim2d.HertzianDrag_getpair(self, pair)


    def getatom(self, n: 'uint') -> "HertzianDragAtom &":
        """getatom(HertzianDrag self, uint n) -> HertzianDragAtom"""
        return _sim2d.HertzianDrag_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(HertzianDrag self, Box box, idpair pair) -> flt
        energy(HertzianDrag self, Box box) -> flt
        """
        return _sim2d.HertzianDrag_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(HertzianDrag self, Box box) -> unsigned long long"""
        return _sim2d.HertzianDrag_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(HertzianDrag self, Box box) -> unsigned long long"""
        return _sim2d.HertzianDrag_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianDrag self, Box box) -> flt"""
        return _sim2d.HertzianDrag_pressure(self, box)


    def pairiter(self) -> "std::vector< HertzianDragPair > &":
        """pairiter(HertzianDrag self) -> std::vector< HertzianDragPair > &"""
        return _sim2d.HertzianDrag_pairiter(self)


    def size(self) -> "uint":
        """size(HertzianDrag self) -> uint"""
        return _sim2d.HertzianDrag_size(self)


    def energy_pair(self, pair: 'HertzianDragPair', box: 'Box') -> "flt":
        """energy_pair(HertzianDrag self, HertzianDragPair pair, Box box) -> flt"""
        return _sim2d.HertzianDrag_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(HertzianDrag self, Box box)"""
        return _sim2d.HertzianDrag_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(HertzianDrag self, Box box) -> flt"""
        return _sim2d.HertzianDrag_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'HertzianDragPair', box: 'Box') -> "Vec":
        """forces_pair(HertzianDrag self, HertzianDragPair pair, Box box) -> Vec"""
        return _sim2d.HertzianDrag_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< HertzianDragAtom > &":
        """atom_list(HertzianDrag self) -> std::vector< HertzianDragAtom > &"""
        return _sim2d.HertzianDrag_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(HertzianDrag self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.HertzianDrag_nlist(self)

    __swig_destroy__ = _sim2d.delete_HertzianDrag
    __del__ = lambda self: None
HertzianDrag_swigregister = _sim2d.HertzianDrag_swigregister
HertzianDrag_swigregister(HertzianDrag)

class HertzianSC(interaction):
    """Proxy of C++ SCboxed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianSC, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianSC, name)
    __repr__ = _swig_repr

    def __init__(self, atomv: 'boost::shared_ptr< atomvec >', box: 'boost::shared_ptr< SCbox >'):
        """__init__(SCboxed<(HertzianAtom,HertzianPair)> self, boost::shared_ptr< atomvec > atomv, boost::shared_ptr< SCbox > box) -> HertzianSC"""
        this = _sim2d.new_HertzianSC(atomv, box)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, atm: 'HertzianAtom') -> "void":
        """add(HertzianSC self, HertzianAtom atm)"""
        return _sim2d.HertzianSC_add(self, atm)


    def energy(self, box: 'Box') -> "flt":
        """energy(HertzianSC self, Box box) -> flt"""
        return _sim2d.HertzianSC_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianSC self, Box box) -> flt"""
        return _sim2d.HertzianSC_pressure(self, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(HertzianSC self, Box box)"""
        return _sim2d.HertzianSC_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(HertzianSC self, Box box) -> flt"""
        return _sim2d.HertzianSC_setForcesGetPressure(self, box)


    def atom_list(self) -> "std::vector< HertzianAtom > &":
        """atom_list(HertzianSC self) -> std::vector< HertzianAtom > &"""
        return _sim2d.HertzianSC_atom_list(self)

    __swig_destroy__ = _sim2d.delete_HertzianSC
    __del__ = lambda self: None
HertzianSC_swigregister = _sim2d.HertzianSC_swigregister
HertzianSC_swigregister(HertzianSC)

class HertzianVirial(interactionpairsx):
    """Proxy of C++ NListedVirial<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interactionpairsx]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianVirial, name, value)
    __swig_getmethods__ = {}
    for _s in [interactionpairsx]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianVirial, name)
    __repr__ = _swig_repr

    def __init__(self, vec: 'boost::shared_ptr< atomvec >', neighbors: 'boost::shared_ptr< neighborlist >'):
        """__init__(NListedVirial<(HertzianAtom,HertzianPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> HertzianVirial"""
        this = _sim2d.new_HertzianVirial(vec, neighbors)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setForces(self, *args) -> "void":
        """
        setForces(HertzianVirial self, Box box)
        setForces(HertzianVirial self, Box box, fpairxFunct arg3)
        """
        return _sim2d.HertzianVirial_setForces(self, *args)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_setForcesGetPressure(self, box)


    def setForcesGetEnergy(self, box: 'Box') -> "flt":
        """setForcesGetEnergy(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_setForcesGetEnergy(self, box)


    def energy(self, box: 'Box') -> "flt":
        """energy(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_energy(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(HertzianVirial self, Box box) -> flt"""
        return _sim2d.HertzianVirial_pressure(self, box)


    def add(self, atm: 'HertzianAtom') -> "void":
        """add(HertzianVirial self, HertzianAtom atm)"""
        return _sim2d.HertzianVirial_add(self, atm)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(HertzianVirial self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.HertzianVirial_nlist(self)

    __swig_destroy__ = _sim2d.delete_HertzianVirial
    __del__ = lambda self: None
HertzianVirial_swigregister = _sim2d.HertzianVirial_swigregister
HertzianVirial_swigregister(HertzianVirial)

class LoisOhern(interaction):
    """Proxy of C++ NListed<(LoisOhernAtom,LoisOhernPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhern, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhern, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisOhernAtom') -> "void":
        """add(LoisOhern self, LoisOhernAtom atm)"""
        return _sim2d.LoisOhern_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisOhernAtom,LoisOhernPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LoisOhern
        __init__(NListed<(LoisOhernAtom,LoisOhernPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LoisOhern
        """
        this = _sim2d.new_LoisOhern(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisOhern self)"""
        return _sim2d.LoisOhern_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LoisOhernPair":
        """getpair(LoisOhern self, idpair pair) -> LoisOhernPair"""
        return _sim2d.LoisOhern_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LoisOhernAtom &":
        """getatom(LoisOhern self, uint n) -> LoisOhernAtom"""
        return _sim2d.LoisOhern_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisOhern self, Box box, idpair pair) -> flt
        energy(LoisOhern self, Box box) -> flt
        """
        return _sim2d.LoisOhern_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisOhern self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhern_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisOhern self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhern_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisOhern self, Box box) -> flt"""
        return _sim2d.LoisOhern_pressure(self, box)


    def pairiter(self) -> "std::vector< LoisOhernPair > &":
        """pairiter(LoisOhern self) -> std::vector< LoisOhernPair > &"""
        return _sim2d.LoisOhern_pairiter(self)


    def size(self) -> "uint":
        """size(LoisOhern self) -> uint"""
        return _sim2d.LoisOhern_size(self)


    def energy_pair(self, pair: 'LoisOhernPair', box: 'Box') -> "flt":
        """energy_pair(LoisOhern self, LoisOhernPair pair, Box box) -> flt"""
        return _sim2d.LoisOhern_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LoisOhern self, Box box)"""
        return _sim2d.LoisOhern_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LoisOhern self, Box box) -> flt"""
        return _sim2d.LoisOhern_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LoisOhernPair', box: 'Box') -> "Vec":
        """forces_pair(LoisOhern self, LoisOhernPair pair, Box box) -> Vec"""
        return _sim2d.LoisOhern_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisOhernAtom > &":
        """atom_list(LoisOhern self) -> std::vector< LoisOhernAtom > &"""
        return _sim2d.LoisOhern_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LoisOhern self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LoisOhern_nlist(self)

    __swig_destroy__ = _sim2d.delete_LoisOhern
    __del__ = lambda self: None
LoisOhern_swigregister = _sim2d.LoisOhern_swigregister
LoisOhern_swigregister(LoisOhern)

class LoisLin(interaction):
    """Proxy of C++ NListed<(LoisLinAtom,LoisLinPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLin, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLin, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisLinAtom') -> "void":
        """add(LoisLin self, LoisLinAtom atm)"""
        return _sim2d.LoisLin_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisLinAtom,LoisLinPair)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LoisLin
        __init__(NListed<(LoisLinAtom,LoisLinPair)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LoisLin
        """
        this = _sim2d.new_LoisLin(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisLin self)"""
        return _sim2d.LoisLin_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LoisLinPair":
        """getpair(LoisLin self, idpair pair) -> LoisLinPair"""
        return _sim2d.LoisLin_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LoisLinAtom &":
        """getatom(LoisLin self, uint n) -> LoisLinAtom"""
        return _sim2d.LoisLin_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisLin self, Box box, idpair pair) -> flt
        energy(LoisLin self, Box box) -> flt
        """
        return _sim2d.LoisLin_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisLin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLin_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisLin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLin_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisLin self, Box box) -> flt"""
        return _sim2d.LoisLin_pressure(self, box)


    def pairiter(self) -> "std::vector< LoisLinPair > &":
        """pairiter(LoisLin self) -> std::vector< LoisLinPair > &"""
        return _sim2d.LoisLin_pairiter(self)


    def size(self) -> "uint":
        """size(LoisLin self) -> uint"""
        return _sim2d.LoisLin_size(self)


    def energy_pair(self, pair: 'LoisLinPair', box: 'Box') -> "flt":
        """energy_pair(LoisLin self, LoisLinPair pair, Box box) -> flt"""
        return _sim2d.LoisLin_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LoisLin self, Box box)"""
        return _sim2d.LoisLin_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LoisLin self, Box box) -> flt"""
        return _sim2d.LoisLin_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LoisLinPair', box: 'Box') -> "Vec":
        """forces_pair(LoisLin self, LoisLinPair pair, Box box) -> Vec"""
        return _sim2d.LoisLin_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisLinAtom > &":
        """atom_list(LoisLin self) -> std::vector< LoisLinAtom > &"""
        return _sim2d.LoisLin_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LoisLin self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LoisLin_nlist(self)

    __swig_destroy__ = _sim2d.delete_LoisLin
    __del__ = lambda self: None
LoisLin_swigregister = _sim2d.LoisLin_swigregister
LoisLin_swigregister(LoisLin)

class LoisLinMin(interaction):
    """Proxy of C++ NListed<(LoisLinAtom,LoisLinPairMin)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisLinMin, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisLinMin, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisLinAtom') -> "void":
        """add(LoisLinMin self, LoisLinAtom atm)"""
        return _sim2d.LoisLinMin_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisLinAtom,LoisLinPairMin)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LoisLinMin
        __init__(NListed<(LoisLinAtom,LoisLinPairMin)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LoisLinMin
        """
        this = _sim2d.new_LoisLinMin(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisLinMin self)"""
        return _sim2d.LoisLinMin_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LoisLinPairMin":
        """getpair(LoisLinMin self, idpair pair) -> LoisLinPairMin"""
        return _sim2d.LoisLinMin_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LoisLinAtom &":
        """getatom(LoisLinMin self, uint n) -> LoisLinAtom"""
        return _sim2d.LoisLinMin_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisLinMin self, Box box, idpair pair) -> flt
        energy(LoisLinMin self, Box box) -> flt
        """
        return _sim2d.LoisLinMin_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisLinMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLinMin_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisLinMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisLinMin_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisLinMin self, Box box) -> flt"""
        return _sim2d.LoisLinMin_pressure(self, box)


    def pairiter(self) -> "std::vector< LoisLinPairMin > &":
        """pairiter(LoisLinMin self) -> std::vector< LoisLinPairMin > &"""
        return _sim2d.LoisLinMin_pairiter(self)


    def size(self) -> "uint":
        """size(LoisLinMin self) -> uint"""
        return _sim2d.LoisLinMin_size(self)


    def energy_pair(self, pair: 'LoisLinPairMin', box: 'Box') -> "flt":
        """energy_pair(LoisLinMin self, LoisLinPairMin pair, Box box) -> flt"""
        return _sim2d.LoisLinMin_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LoisLinMin self, Box box)"""
        return _sim2d.LoisLinMin_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LoisLinMin self, Box box) -> flt"""
        return _sim2d.LoisLinMin_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LoisLinPairMin', box: 'Box') -> "Vec":
        """forces_pair(LoisLinMin self, LoisLinPairMin pair, Box box) -> Vec"""
        return _sim2d.LoisLinMin_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisLinAtom > &":
        """atom_list(LoisLinMin self) -> std::vector< LoisLinAtom > &"""
        return _sim2d.LoisLinMin_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LoisLinMin self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LoisLinMin_nlist(self)

    __swig_destroy__ = _sim2d.delete_LoisLinMin
    __del__ = lambda self: None
LoisLinMin_swigregister = _sim2d.LoisLinMin_swigregister
LoisLinMin_swigregister(LoisLinMin)

class LoisOhernMin(interaction):
    """Proxy of C++ NListed<(LoisOhernAtom,LoisOhernPairMinCLs)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernMin, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernMin, name)
    __repr__ = _swig_repr

    def add(self, atm: 'LoisOhernAtom') -> "void":
        """add(LoisOhernMin self, LoisOhernAtom atm)"""
        return _sim2d.LoisOhernMin_add(self, atm)


    def __init__(self, *args):
        """
        __init__(NListed<(LoisOhernAtom,LoisOhernPairMinCLs)> self, boost::shared_ptr< atomvec > vec, boost::shared_ptr< neighborlist > neighbors) -> LoisOhernMin
        __init__(NListed<(LoisOhernAtom,LoisOhernPairMinCLs)> self, boost::shared_ptr< Box > box, boost::shared_ptr< atomvec > atomv, flt const skin) -> LoisOhernMin
        """
        this = _sim2d.new_LoisOhernMin(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_pairs(self) -> "void":
        """update_pairs(LoisOhernMin self)"""
        return _sim2d.LoisOhernMin_update_pairs(self)


    def getpair(self, pair: 'idpair') -> "LoisOhernPairMinCLs":
        """getpair(LoisOhernMin self, idpair pair) -> LoisOhernPairMinCLs"""
        return _sim2d.LoisOhernMin_getpair(self, pair)


    def getatom(self, n: 'uint') -> "LoisOhernAtom &":
        """getatom(LoisOhernMin self, uint n) -> LoisOhernAtom"""
        return _sim2d.LoisOhernMin_getatom(self, n)


    def energy(self, *args) -> "flt":
        """
        energy(LoisOhernMin self, Box box, idpair pair) -> flt
        energy(LoisOhernMin self, Box box) -> flt
        """
        return _sim2d.LoisOhernMin_energy(self, *args)


    def contacts(self, box: 'Box') -> "unsigned long long":
        """contacts(LoisOhernMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhernMin_contacts(self, box)


    def overlaps(self, box: 'Box') -> "unsigned long long":
        """overlaps(LoisOhernMin self, Box box) -> unsigned long long"""
        return _sim2d.LoisOhernMin_overlaps(self, box)


    def pressure(self, box: 'Box') -> "flt":
        """pressure(LoisOhernMin self, Box box) -> flt"""
        return _sim2d.LoisOhernMin_pressure(self, box)


    def pairiter(self) -> "std::vector< LoisOhernPairMinCLs > &":
        """pairiter(LoisOhernMin self) -> std::vector< LoisOhernPairMinCLs > &"""
        return _sim2d.LoisOhernMin_pairiter(self)


    def size(self) -> "uint":
        """size(LoisOhernMin self) -> uint"""
        return _sim2d.LoisOhernMin_size(self)


    def energy_pair(self, pair: 'LoisOhernPairMinCLs', box: 'Box') -> "flt":
        """energy_pair(LoisOhernMin self, LoisOhernPairMinCLs pair, Box box) -> flt"""
        return _sim2d.LoisOhernMin_energy_pair(self, pair, box)


    def setForces(self, box: 'Box') -> "void":
        """setForces(LoisOhernMin self, Box box)"""
        return _sim2d.LoisOhernMin_setForces(self, box)


    def setForcesGetPressure(self, box: 'Box') -> "flt":
        """setForcesGetPressure(LoisOhernMin self, Box box) -> flt"""
        return _sim2d.LoisOhernMin_setForcesGetPressure(self, box)


    def forces_pair(self, pair: 'LoisOhernPairMinCLs', box: 'Box') -> "Vec":
        """forces_pair(LoisOhernMin self, LoisOhernPairMinCLs pair, Box box) -> Vec"""
        return _sim2d.LoisOhernMin_forces_pair(self, pair, box)


    def atom_list(self) -> "std::vector< LoisOhernAtom > &":
        """atom_list(LoisOhernMin self) -> std::vector< LoisOhernAtom > &"""
        return _sim2d.LoisOhernMin_atom_list(self)


    def nlist(self) -> "boost::shared_ptr< neighborlist >":
        """nlist(LoisOhernMin self) -> boost::shared_ptr< neighborlist >"""
        return _sim2d.LoisOhernMin_nlist(self)

    __swig_destroy__ = _sim2d.delete_LoisOhernMin
    __del__ = lambda self: None
LoisOhernMin_swigregister = _sim2d.LoisOhernMin_swigregister
LoisOhernMin_swigregister(LoisOhernMin)

class collection(_object):
    """Proxy of C++ collection class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, collection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, collection, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def initialize(self) -> "void":
        """initialize(collection self)"""
        return _sim2d.collection_initialize(self)


    def setForces(self, seta: 'bool'=True) -> "void":
        """
        setForces(collection self, bool seta=True)
        setForces(collection self)
        """
        return _sim2d.collection_setForces(self, seta)


    def timestep(self) -> "void":
        """timestep(collection self)"""
        return _sim2d.collection_timestep(self)


    def dof(self) -> "flt":
        """dof(collection self) -> flt"""
        return _sim2d.collection_dof(self)


    def potentialenergy(self) -> "flt":
        """potentialenergy(collection self) -> flt"""
        return _sim2d.collection_potentialenergy(self)


    def energy(self) -> "flt":
        """energy(collection self) -> flt"""
        return _sim2d.collection_energy(self)


    def temp(self, minuscomv: 'bool'=True) -> "flt":
        """
        temp(collection self, bool minuscomv=True) -> flt
        temp(collection self) -> flt
        """
        return _sim2d.collection_temp(self, minuscomv)


    def kinetic(self) -> "flt":
        """kinetic(collection self) -> flt"""
        return _sim2d.collection_kinetic(self)


    def virial(self) -> "flt":
        """virial(collection self) -> flt"""
        return _sim2d.collection_virial(self)


    def pressure(self) -> "flt":
        """pressure(collection self) -> flt"""
        return _sim2d.collection_pressure(self)


    def getbox(self) -> "boost::shared_ptr< Box >":
        """getbox(collection self) -> boost::shared_ptr< Box >"""
        return _sim2d.collection_getbox(self)


    def com(self) -> "Vec":
        """com(collection self) -> Vec"""
        return _sim2d.collection_com(self)


    def comv(self) -> "Vec":
        """comv(collection self) -> Vec"""
        return _sim2d.collection_comv(self)


    def angmomentum(self, *args) -> "flt":
        """
        angmomentum(collection self, Vec const & loc) -> flt
        angmomentum(collection self) -> flt
        """
        return _sim2d.collection_angmomentum(self, *args)


    def gyradius(self) -> "flt":
        """gyradius(collection self) -> flt"""
        return _sim2d.collection_gyradius(self)

    __swig_destroy__ = _sim2d.delete_collection
    __del__ = lambda self: None

    def resetcomv(self) -> "void":
        """resetcomv(collection self)"""
        return _sim2d.collection_resetcomv(self)


    def resetL(self) -> "void":
        """resetL(collection self)"""
        return _sim2d.collection_resetL(self)


    def scaleVs(self, scaleby: 'flt') -> "void":
        """scaleVs(collection self, flt scaleby)"""
        return _sim2d.collection_scaleVs(self, scaleby)


    def scaleVelocitiesT(self, T: 'flt', minuscomv: 'bool'=True) -> "void":
        """
        scaleVelocitiesT(collection self, flt T, bool minuscomv=True)
        scaleVelocitiesT(collection self, flt T)
        """
        return _sim2d.collection_scaleVelocitiesT(self, T, minuscomv)


    def scaleVelocitiesE(self, E: 'flt') -> "void":
        """scaleVelocitiesE(collection self, flt E)"""
        return _sim2d.collection_scaleVelocitiesE(self, E)


    def addInteraction(self, inter: 'boost::shared_ptr< interaction >') -> "void":
        """addInteraction(collection self, boost::shared_ptr< interaction > inter)"""
        return _sim2d.collection_addInteraction(self, inter)


    def addTracker(self, track: 'boost::shared_ptr< statetracker >') -> "void":
        """addTracker(collection self, boost::shared_ptr< statetracker > track)"""
        return _sim2d.collection_addTracker(self, track)


    def addConstraint(self, c: 'boost::shared_ptr< constraint >') -> "void":
        """addConstraint(collection self, boost::shared_ptr< constraint > c)"""
        return _sim2d.collection_addConstraint(self, c)


    def add(self, *args) -> "void":
        """
        add(collection self, boost::shared_ptr< interaction > a)
        add(collection self, boost::shared_ptr< statetracker > a)
        add(collection self, boost::shared_ptr< constraint > a)
        """
        return _sim2d.collection_add(self, *args)


    def getInteractions(self) -> "std::vector< boost::shared_ptr< interaction > >":
        """getInteractions(collection self) -> std::vector< boost::shared_ptr< interaction > >"""
        return _sim2d.collection_getInteractions(self)


    def numInteraction(self) -> "uint":
        """numInteraction(collection self) -> uint"""
        return _sim2d.collection_numInteraction(self)

collection_swigregister = _sim2d.collection_swigregister
collection_swigregister(collection)

class StaticCollec(collection):
    """Proxy of C++ StaticCollec class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StaticCollec, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StaticCollec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> StaticCollec
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> StaticCollec
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions) -> StaticCollec
        __init__(StaticCollec self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms) -> StaticCollec
        """
        this = _sim2d.new_StaticCollec(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(StaticCollec self)"""
        return _sim2d.StaticCollec_timestep(self)


    def update(self) -> "void":
        """update(StaticCollec self)"""
        return _sim2d.StaticCollec_update(self)

    __swig_destroy__ = _sim2d.delete_StaticCollec
    __del__ = lambda self: None
StaticCollec_swigregister = _sim2d.StaticCollec_swigregister
StaticCollec_swigregister(StaticCollec)

class collectionSol(collection):
    """Proxy of C++ collectionSol class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSol, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSol, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionSol
        __init__(collectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionSol
        __init__(collectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionSol
        __init__(collectionSol self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT) -> collectionSol
        """
        this = _sim2d.new_collectionSol(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def changeT(self, damp: 'flt const', desiredT: 'flt const') -> "void":
        """changeT(collectionSol self, flt const damp, flt const desiredT)"""
        return _sim2d.collectionSol_changeT(self, damp, desiredT)


    def changeMag(self, damp: 'flt const', fmag: 'flt const', desiredT: 'flt const') -> "void":
        """changeMag(collectionSol self, flt const damp, flt const fmag, flt const desiredT)"""
        return _sim2d.collectionSol_changeMag(self, damp, fmag, desiredT)


    def setdt(self, newdt: 'flt const') -> "void":
        """setdt(collectionSol self, flt const newdt)"""
        return _sim2d.collectionSol_setdt(self, newdt)


    def timestep(self) -> "void":
        """timestep(collectionSol self)"""
        return _sim2d.collectionSol_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionSol
    __del__ = lambda self: None
collectionSol_swigregister = _sim2d.collectionSol_swigregister
collectionSol_swigregister(collectionSol)

class collectionDamped(collection):
    """Proxy of C++ collectionDamped class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionDamped, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionDamped, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionDamped
        __init__(collectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionDamped
        __init__(collectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionDamped
        __init__(collectionDamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping) -> collectionDamped
        """
        this = _sim2d.new_collectionDamped(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def changeDamp(self, damp: 'flt const') -> "void":
        """changeDamp(collectionDamped self, flt const damp)"""
        return _sim2d.collectionDamped_changeDamp(self, damp)


    def setdt(self, newdt: 'flt const') -> "void":
        """setdt(collectionDamped self, flt const newdt)"""
        return _sim2d.collectionDamped_setdt(self, newdt)


    def timestep(self) -> "void":
        """timestep(collectionDamped self)"""
        return _sim2d.collectionDamped_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionDamped
    __del__ = lambda self: None
collectionDamped_swigregister = _sim2d.collectionDamped_swigregister
collectionDamped_swigregister(collectionDamped)

class collectionSolHT(collection):
    """Proxy of C++ collectionSolHT class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSolHT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSolHT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionSolHT
        __init__(collectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionSolHT
        __init__(collectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionSolHT
        __init__(collectionSolHT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const damping, flt const desiredT) -> collectionSolHT
        """
        this = _sim2d.new_collectionSolHT(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def changeT(self, newdt: 'flt const', damp: 'flt const', desiredT: 'flt const') -> "void":
        """changeT(collectionSolHT self, flt const newdt, flt const damp, flt const desiredT)"""
        return _sim2d.collectionSolHT_changeT(self, newdt, damp, desiredT)


    def timestep(self) -> "void":
        """timestep(collectionSolHT self)"""
        return _sim2d.collectionSolHT_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionSolHT
    __del__ = lambda self: None
collectionSolHT_swigregister = _sim2d.collectionSolHT_swigregister
collectionSolHT_swigregister(collectionSolHT)

class collectionVerlet(collection):
    """Proxy of C++ collectionVerlet class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerlet, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerlet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionVerlet
        __init__(collectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionVerlet
        __init__(collectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionVerlet
        __init__(collectionVerlet self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt) -> collectionVerlet
        """
        this = _sim2d.new_collectionVerlet(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionVerlet self)"""
        return _sim2d.collectionVerlet_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionVerlet self, flt newdt)"""
        return _sim2d.collectionVerlet_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionVerlet
    __del__ = lambda self: None
collectionVerlet_swigregister = _sim2d.collectionVerlet_swigregister
collectionVerlet_swigregister(collectionVerlet)

class collectionOverdamped(collection):
    """Proxy of C++ collectionOverdamped class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionOverdamped, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionOverdamped, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const gamma=1.0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionOverdamped
        __init__(collectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const gamma=1.0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionOverdamped
        __init__(collectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const gamma=1.0, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionOverdamped
        __init__(collectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const gamma=1.0) -> collectionOverdamped
        __init__(collectionOverdamped self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt) -> collectionOverdamped
        """
        this = _sim2d.new_collectionOverdamped(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionOverdamped self)"""
        return _sim2d.collectionOverdamped_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionOverdamped self, flt newdt)"""
        return _sim2d.collectionOverdamped_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionOverdamped
    __del__ = lambda self: None
collectionOverdamped_swigregister = _sim2d.collectionOverdamped_swigregister
collectionOverdamped_swigregister(collectionOverdamped)

class collectionConjGradient(collection):
    """Proxy of C++ collectionConjGradient class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradient, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradient, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionConjGradient self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionConjGradient
        __init__(collectionConjGradient self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionConjGradient
        __init__(collectionConjGradient self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionConjGradient
        __init__(collectionConjGradient self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt) -> collectionConjGradient
        """
        this = _sim2d.new_collectionConjGradient(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionConjGradient self)"""
        return _sim2d.collectionConjGradient_timestep(self)


    def timestepNewton(self) -> "void":
        """timestepNewton(collectionConjGradient self)"""
        return _sim2d.collectionConjGradient_timestepNewton(self)


    def reset(self) -> "void":
        """reset(collectionConjGradient self)"""
        return _sim2d.collectionConjGradient_reset(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionConjGradient self, flt newdt)"""
        return _sim2d.collectionConjGradient_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionConjGradient
    __del__ = lambda self: None
collectionConjGradient_swigregister = _sim2d.collectionConjGradient_swigregister
collectionConjGradient_swigregister(collectionConjGradient)

class collectionConjGradientBox(collection):
    """Proxy of C++ collectionConjGradientBox class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradientBox, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradientBox, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionConjGradientBox self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, flt const kappaV=1.0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, flt const kappaV=1.0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, flt const kappaV=1.0, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, flt const kappaV=1.0) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0) -> collectionConjGradientBox
        """
        this = _sim2d.new_collectionConjGradientBox(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def kinetic(self) -> "flt":
        """kinetic(collectionConjGradientBox self) -> flt"""
        return _sim2d.collectionConjGradientBox_kinetic(self)


    def timestep(self) -> "void":
        """timestep(collectionConjGradientBox self)"""
        return _sim2d.collectionConjGradientBox_timestep(self)


    def timestepBox(self) -> "void":
        """timestepBox(collectionConjGradientBox self)"""
        return _sim2d.collectionConjGradientBox_timestepBox(self)


    def timestepAtoms(self) -> "void":
        """timestepAtoms(collectionConjGradientBox self)"""
        return _sim2d.collectionConjGradientBox_timestepAtoms(self)


    def reset(self) -> "void":
        """reset(collectionConjGradientBox self)"""
        return _sim2d.collectionConjGradientBox_reset(self)


    def resize(self, V: 'flt') -> "void":
        """resize(collectionConjGradientBox self, flt V)"""
        return _sim2d.collectionConjGradientBox_resize(self, V)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionConjGradientBox self, flt newdt)"""
        return _sim2d.collectionConjGradientBox_setdt(self, newdt)


    def setP(self, P: 'flt') -> "void":
        """setP(collectionConjGradientBox self, flt P)"""
        return _sim2d.collectionConjGradientBox_setP(self, P)


    def setMaxdV(self, diff: 'flt') -> "void":
        """setMaxdV(collectionConjGradientBox self, flt diff)"""
        return _sim2d.collectionConjGradientBox_setMaxdV(self, diff)

    __swig_destroy__ = _sim2d.delete_collectionConjGradientBox
    __del__ = lambda self: None
collectionConjGradientBox_swigregister = _sim2d.collectionConjGradientBox_swigregister
collectionConjGradientBox_swigregister(collectionConjGradientBox)

class collectionNLCG(collection):
    """Proxy of C++ collectionNLCG class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNLCG, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNLCG, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.collectionNLCG_dt_set
    __swig_getmethods__["dt"] = _sim2d.collectionNLCG_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.collectionNLCG_dt_get, _sim2d.collectionNLCG_dt_set)
    __swig_setmethods__["seceps"] = _sim2d.collectionNLCG_seceps_set
    __swig_getmethods__["seceps"] = _sim2d.collectionNLCG_seceps_get
    if _newclass:
        seceps = _swig_property(_sim2d.collectionNLCG_seceps_get, _sim2d.collectionNLCG_seceps_set)
    __swig_setmethods__["secmax"] = _sim2d.collectionNLCG_secmax_set
    __swig_getmethods__["secmax"] = _sim2d.collectionNLCG_secmax_get
    if _newclass:
        secmax = _swig_property(_sim2d.collectionNLCG_secmax_get, _sim2d.collectionNLCG_secmax_set)
    __swig_setmethods__["kappa"] = _sim2d.collectionNLCG_kappa_set
    __swig_getmethods__["kappa"] = _sim2d.collectionNLCG_kappa_get
    if _newclass:
        kappa = _swig_property(_sim2d.collectionNLCG_kappa_get, _sim2d.collectionNLCG_kappa_set)
    __swig_setmethods__["alphamax"] = _sim2d.collectionNLCG_alphamax_set
    __swig_getmethods__["alphamax"] = _sim2d.collectionNLCG_alphamax_get
    if _newclass:
        alphamax = _swig_property(_sim2d.collectionNLCG_alphamax_get, _sim2d.collectionNLCG_alphamax_set)
    __swig_setmethods__["afrac"] = _sim2d.collectionNLCG_afrac_set
    __swig_getmethods__["afrac"] = _sim2d.collectionNLCG_afrac_get
    if _newclass:
        afrac = _swig_property(_sim2d.collectionNLCG_afrac_get, _sim2d.collectionNLCG_afrac_set)
    __swig_setmethods__["dxmax"] = _sim2d.collectionNLCG_dxmax_set
    __swig_getmethods__["dxmax"] = _sim2d.collectionNLCG_dxmax_get
    if _newclass:
        dxmax = _swig_property(_sim2d.collectionNLCG_dxmax_get, _sim2d.collectionNLCG_dxmax_set)
    __swig_setmethods__["stepmax"] = _sim2d.collectionNLCG_stepmax_set
    __swig_getmethods__["stepmax"] = _sim2d.collectionNLCG_stepmax_get
    if _newclass:
        stepmax = _swig_property(_sim2d.collectionNLCG_stepmax_get, _sim2d.collectionNLCG_stepmax_set)
    __swig_setmethods__["kmax"] = _sim2d.collectionNLCG_kmax_set
    __swig_getmethods__["kmax"] = _sim2d.collectionNLCG_kmax_get
    if _newclass:
        kmax = _swig_property(_sim2d.collectionNLCG_kmax_get, _sim2d.collectionNLCG_kmax_set)
    __swig_setmethods__["P0"] = _sim2d.collectionNLCG_P0_set
    __swig_getmethods__["P0"] = _sim2d.collectionNLCG_P0_get
    if _newclass:
        P0 = _swig_property(_sim2d.collectionNLCG_P0_get, _sim2d.collectionNLCG_P0_set)
    __swig_setmethods__["Knew"] = _sim2d.collectionNLCG_Knew_set
    __swig_getmethods__["Knew"] = _sim2d.collectionNLCG_Knew_get
    if _newclass:
        Knew = _swig_property(_sim2d.collectionNLCG_Knew_get, _sim2d.collectionNLCG_Knew_set)
    __swig_setmethods__["k"] = _sim2d.collectionNLCG_k_set
    __swig_getmethods__["k"] = _sim2d.collectionNLCG_k_get
    if _newclass:
        k = _swig_property(_sim2d.collectionNLCG_k_get, _sim2d.collectionNLCG_k_set)
    __swig_setmethods__["vl"] = _sim2d.collectionNLCG_vl_set
    __swig_getmethods__["vl"] = _sim2d.collectionNLCG_vl_get
    if _newclass:
        vl = _swig_property(_sim2d.collectionNLCG_vl_get, _sim2d.collectionNLCG_vl_set)
    __swig_setmethods__["fl"] = _sim2d.collectionNLCG_fl_set
    __swig_getmethods__["fl"] = _sim2d.collectionNLCG_fl_get
    if _newclass:
        fl = _swig_property(_sim2d.collectionNLCG_fl_get, _sim2d.collectionNLCG_fl_set)
    __swig_setmethods__["al"] = _sim2d.collectionNLCG_al_set
    __swig_getmethods__["al"] = _sim2d.collectionNLCG_al_get
    if _newclass:
        al = _swig_property(_sim2d.collectionNLCG_al_get, _sim2d.collectionNLCG_al_set)
    __swig_setmethods__["alpha"] = _sim2d.collectionNLCG_alpha_set
    __swig_getmethods__["alpha"] = _sim2d.collectionNLCG_alpha_get
    if _newclass:
        alpha = _swig_property(_sim2d.collectionNLCG_alpha_get, _sim2d.collectionNLCG_alpha_set)
    __swig_setmethods__["beta"] = _sim2d.collectionNLCG_beta_set
    __swig_getmethods__["beta"] = _sim2d.collectionNLCG_beta_get
    if _newclass:
        beta = _swig_property(_sim2d.collectionNLCG_beta_get, _sim2d.collectionNLCG_beta_set)
    __swig_setmethods__["betaused"] = _sim2d.collectionNLCG_betaused_set
    __swig_getmethods__["betaused"] = _sim2d.collectionNLCG_betaused_get
    if _newclass:
        betaused = _swig_property(_sim2d.collectionNLCG_betaused_get, _sim2d.collectionNLCG_betaused_set)
    __swig_setmethods__["dxsum"] = _sim2d.collectionNLCG_dxsum_set
    __swig_getmethods__["dxsum"] = _sim2d.collectionNLCG_dxsum_get
    if _newclass:
        dxsum = _swig_property(_sim2d.collectionNLCG_dxsum_get, _sim2d.collectionNLCG_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim2d.collectionNLCG_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim2d.collectionNLCG_alphavmax_get
    if _newclass:
        alphavmax = _swig_property(_sim2d.collectionNLCG_alphavmax_get, _sim2d.collectionNLCG_alphavmax_set)
    __swig_setmethods__["maxdV"] = _sim2d.collectionNLCG_maxdV_set
    __swig_getmethods__["maxdV"] = _sim2d.collectionNLCG_maxdV_get
    if _newclass:
        maxdV = _swig_property(_sim2d.collectionNLCG_maxdV_get, _sim2d.collectionNLCG_maxdV_set)
    __swig_setmethods__["sec"] = _sim2d.collectionNLCG_sec_set
    __swig_getmethods__["sec"] = _sim2d.collectionNLCG_sec_get
    if _newclass:
        sec = _swig_property(_sim2d.collectionNLCG_sec_get, _sim2d.collectionNLCG_sec_set)

    def stepx(self, dx: 'flt') -> "void":
        """stepx(collectionNLCG self, flt dx)"""
        return _sim2d.collectionNLCG_stepx(self, dx)


    def getLsq(self) -> "flt":
        """getLsq(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_getLsq(self)


    def fdota(self) -> "flt":
        """fdota(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_fdota(self)


    def fdotf(self) -> "flt":
        """fdotf(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_fdotf(self)


    def fdotv(self) -> "flt":
        """fdotv(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_fdotv(self)


    def vdotv(self) -> "flt":
        """vdotv(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_vdotv(self)


    def __init__(self, *args):
        """
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints, flt const kappa=10.0, flt const kmax=1000, uint const secmax=40, flt const seceps=1e-20) -> collectionNLCG
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints, flt const kappa=10.0, flt const kmax=1000, uint const secmax=40) -> collectionNLCG
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints, flt const kappa=10.0, flt const kmax=1000) -> collectionNLCG
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints, flt const kappa=10.0) -> collectionNLCG
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionNLCG
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionNLCG
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionNLCG
        __init__(collectionNLCG self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P0) -> collectionNLCG
        """
        this = _sim2d.new_collectionNLCG(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def kinetic(self) -> "flt":
        """kinetic(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_kinetic(self)


    def pressure(self) -> "flt":
        """pressure(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_pressure(self)


    def Hamiltonian(self) -> "flt":
        """Hamiltonian(collectionNLCG self) -> flt"""
        return _sim2d.collectionNLCG_Hamiltonian(self)


    def setForces(self, *args) -> "void":
        """
        setForces(collectionNLCG self, bool seta=True)
        setForces(collectionNLCG self)
        setForces(collectionNLCG self, bool seta, bool setV)
        """
        return _sim2d.collectionNLCG_setForces(self, *args)


    def timestep(self) -> "void":
        """timestep(collectionNLCG self)"""
        return _sim2d.collectionNLCG_timestep(self)


    def descend(self) -> "void":
        """descend(collectionNLCG self)"""
        return _sim2d.collectionNLCG_descend(self)


    def reset(self) -> "void":
        """reset(collectionNLCG self)"""
        return _sim2d.collectionNLCG_reset(self)


    def resize(self, V: 'flt') -> "void":
        """resize(collectionNLCG self, flt V)"""
        return _sim2d.collectionNLCG_resize(self, V)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionNLCG self, flt newdt)"""
        return _sim2d.collectionNLCG_setdt(self, newdt)


    def setP(self, P: 'flt') -> "void":
        """setP(collectionNLCG self, flt P)"""
        return _sim2d.collectionNLCG_setP(self, P)


    def setkappa(self, k: 'flt') -> "void":
        """setkappa(collectionNLCG self, flt k)"""
        return _sim2d.collectionNLCG_setkappa(self, k)


    def setamax(self, a: 'flt') -> "void":
        """setamax(collectionNLCG self, flt a)"""
        return _sim2d.collectionNLCG_setamax(self, a)


    def setafrac(self, a: 'flt') -> "void":
        """setafrac(collectionNLCG self, flt a)"""
        return _sim2d.collectionNLCG_setafrac(self, a)


    def setdxmax(self, d: 'flt') -> "void":
        """setdxmax(collectionNLCG self, flt d)"""
        return _sim2d.collectionNLCG_setdxmax(self, d)


    def setstepmax(self, m: 'flt') -> "void":
        """setstepmax(collectionNLCG self, flt m)"""
        return _sim2d.collectionNLCG_setstepmax(self, m)

    __swig_destroy__ = _sim2d.delete_collectionNLCG
    __del__ = lambda self: None
collectionNLCG_swigregister = _sim2d.collectionNLCG_swigregister
collectionNLCG_swigregister(collectionNLCG)

class collectionNLCGV(collection):
    """Proxy of C++ collectionNLCGV class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNLCGV, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNLCGV, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.collectionNLCGV_dt_set
    __swig_getmethods__["dt"] = _sim2d.collectionNLCGV_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.collectionNLCGV_dt_get, _sim2d.collectionNLCGV_dt_set)
    __swig_setmethods__["seceps"] = _sim2d.collectionNLCGV_seceps_set
    __swig_getmethods__["seceps"] = _sim2d.collectionNLCGV_seceps_get
    if _newclass:
        seceps = _swig_property(_sim2d.collectionNLCGV_seceps_get, _sim2d.collectionNLCGV_seceps_set)
    __swig_setmethods__["secmax"] = _sim2d.collectionNLCGV_secmax_set
    __swig_getmethods__["secmax"] = _sim2d.collectionNLCGV_secmax_get
    if _newclass:
        secmax = _swig_property(_sim2d.collectionNLCGV_secmax_get, _sim2d.collectionNLCGV_secmax_set)
    __swig_setmethods__["alphamax"] = _sim2d.collectionNLCGV_alphamax_set
    __swig_getmethods__["alphamax"] = _sim2d.collectionNLCGV_alphamax_get
    if _newclass:
        alphamax = _swig_property(_sim2d.collectionNLCGV_alphamax_get, _sim2d.collectionNLCGV_alphamax_set)
    __swig_setmethods__["afrac"] = _sim2d.collectionNLCGV_afrac_set
    __swig_getmethods__["afrac"] = _sim2d.collectionNLCGV_afrac_get
    if _newclass:
        afrac = _swig_property(_sim2d.collectionNLCGV_afrac_get, _sim2d.collectionNLCGV_afrac_set)
    __swig_setmethods__["dxmax"] = _sim2d.collectionNLCGV_dxmax_set
    __swig_getmethods__["dxmax"] = _sim2d.collectionNLCGV_dxmax_get
    if _newclass:
        dxmax = _swig_property(_sim2d.collectionNLCGV_dxmax_get, _sim2d.collectionNLCGV_dxmax_set)
    __swig_setmethods__["stepmax"] = _sim2d.collectionNLCGV_stepmax_set
    __swig_getmethods__["stepmax"] = _sim2d.collectionNLCGV_stepmax_get
    if _newclass:
        stepmax = _swig_property(_sim2d.collectionNLCGV_stepmax_get, _sim2d.collectionNLCGV_stepmax_set)
    __swig_setmethods__["kmax"] = _sim2d.collectionNLCGV_kmax_set
    __swig_getmethods__["kmax"] = _sim2d.collectionNLCGV_kmax_get
    if _newclass:
        kmax = _swig_property(_sim2d.collectionNLCGV_kmax_get, _sim2d.collectionNLCGV_kmax_set)
    __swig_setmethods__["Knew"] = _sim2d.collectionNLCGV_Knew_set
    __swig_getmethods__["Knew"] = _sim2d.collectionNLCGV_Knew_get
    if _newclass:
        Knew = _swig_property(_sim2d.collectionNLCGV_Knew_get, _sim2d.collectionNLCGV_Knew_set)
    __swig_setmethods__["k"] = _sim2d.collectionNLCGV_k_set
    __swig_getmethods__["k"] = _sim2d.collectionNLCGV_k_get
    if _newclass:
        k = _swig_property(_sim2d.collectionNLCGV_k_get, _sim2d.collectionNLCGV_k_set)
    __swig_setmethods__["vl"] = _sim2d.collectionNLCGV_vl_set
    __swig_getmethods__["vl"] = _sim2d.collectionNLCGV_vl_get
    if _newclass:
        vl = _swig_property(_sim2d.collectionNLCGV_vl_get, _sim2d.collectionNLCGV_vl_set)
    __swig_setmethods__["fl"] = _sim2d.collectionNLCGV_fl_set
    __swig_getmethods__["fl"] = _sim2d.collectionNLCGV_fl_get
    if _newclass:
        fl = _swig_property(_sim2d.collectionNLCGV_fl_get, _sim2d.collectionNLCGV_fl_set)
    __swig_setmethods__["al"] = _sim2d.collectionNLCGV_al_set
    __swig_getmethods__["al"] = _sim2d.collectionNLCGV_al_get
    if _newclass:
        al = _swig_property(_sim2d.collectionNLCGV_al_get, _sim2d.collectionNLCGV_al_set)
    __swig_setmethods__["alpha"] = _sim2d.collectionNLCGV_alpha_set
    __swig_getmethods__["alpha"] = _sim2d.collectionNLCGV_alpha_get
    if _newclass:
        alpha = _swig_property(_sim2d.collectionNLCGV_alpha_get, _sim2d.collectionNLCGV_alpha_set)
    __swig_setmethods__["beta"] = _sim2d.collectionNLCGV_beta_set
    __swig_getmethods__["beta"] = _sim2d.collectionNLCGV_beta_get
    if _newclass:
        beta = _swig_property(_sim2d.collectionNLCGV_beta_get, _sim2d.collectionNLCGV_beta_set)
    __swig_setmethods__["betaused"] = _sim2d.collectionNLCGV_betaused_set
    __swig_getmethods__["betaused"] = _sim2d.collectionNLCGV_betaused_get
    if _newclass:
        betaused = _swig_property(_sim2d.collectionNLCGV_betaused_get, _sim2d.collectionNLCGV_betaused_set)
    __swig_setmethods__["dxsum"] = _sim2d.collectionNLCGV_dxsum_set
    __swig_getmethods__["dxsum"] = _sim2d.collectionNLCGV_dxsum_get
    if _newclass:
        dxsum = _swig_property(_sim2d.collectionNLCGV_dxsum_get, _sim2d.collectionNLCGV_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim2d.collectionNLCGV_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim2d.collectionNLCGV_alphavmax_get
    if _newclass:
        alphavmax = _swig_property(_sim2d.collectionNLCGV_alphavmax_get, _sim2d.collectionNLCGV_alphavmax_set)
    __swig_setmethods__["sec"] = _sim2d.collectionNLCGV_sec_set
    __swig_getmethods__["sec"] = _sim2d.collectionNLCGV_sec_get
    if _newclass:
        sec = _swig_property(_sim2d.collectionNLCGV_sec_get, _sim2d.collectionNLCGV_sec_set)

    def stepx(self, dx: 'flt') -> "void":
        """stepx(collectionNLCGV self, flt dx)"""
        return _sim2d.collectionNLCGV_stepx(self, dx)


    def fdota(self) -> "flt":
        """fdota(collectionNLCGV self) -> flt"""
        return _sim2d.collectionNLCGV_fdota(self)


    def fdotf(self) -> "flt":
        """fdotf(collectionNLCGV self) -> flt"""
        return _sim2d.collectionNLCGV_fdotf(self)


    def fdotv(self) -> "flt":
        """fdotv(collectionNLCGV self) -> flt"""
        return _sim2d.collectionNLCGV_fdotv(self)


    def vdotv(self) -> "flt":
        """vdotv(collectionNLCGV self) -> flt"""
        return _sim2d.collectionNLCGV_vdotv(self)


    def __init__(self, *args):
        """
        __init__(collectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints, flt const kmax=1000, uint const secmax=10, flt const seceps=1e-4) -> collectionNLCGV
        __init__(collectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints, flt const kmax=1000, uint const secmax=10) -> collectionNLCGV
        __init__(collectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints, flt const kmax=1000) -> collectionNLCGV
        __init__(collectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionNLCGV
        __init__(collectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionNLCGV
        __init__(collectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionNLCGV
        __init__(collectionNLCGV self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt) -> collectionNLCGV
        """
        this = _sim2d.new_collectionNLCGV(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def pressure(self) -> "flt":
        """pressure(collectionNLCGV self) -> flt"""
        return _sim2d.collectionNLCGV_pressure(self)


    def reset(self) -> "void":
        """reset(collectionNLCGV self)"""
        return _sim2d.collectionNLCGV_reset(self)


    def descend(self) -> "void":
        """descend(collectionNLCGV self)"""
        return _sim2d.collectionNLCGV_descend(self)


    def timestep(self) -> "void":
        """timestep(collectionNLCGV self)"""
        return _sim2d.collectionNLCGV_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionNLCGV self, flt newdt)"""
        return _sim2d.collectionNLCGV_setdt(self, newdt)


    def setamax(self, a: 'flt') -> "void":
        """setamax(collectionNLCGV self, flt a)"""
        return _sim2d.collectionNLCGV_setamax(self, a)


    def setafrac(self, a: 'flt') -> "void":
        """setafrac(collectionNLCGV self, flt a)"""
        return _sim2d.collectionNLCGV_setafrac(self, a)


    def setdxmax(self, d: 'flt') -> "void":
        """setdxmax(collectionNLCGV self, flt d)"""
        return _sim2d.collectionNLCGV_setdxmax(self, d)


    def setstepmax(self, m: 'flt') -> "void":
        """setstepmax(collectionNLCGV self, flt m)"""
        return _sim2d.collectionNLCGV_setstepmax(self, m)

    __swig_destroy__ = _sim2d.delete_collectionNLCGV
    __del__ = lambda self: None
collectionNLCGV_swigregister = _sim2d.collectionNLCGV_swigregister
collectionNLCGV_swigregister(collectionNLCGV)


def solveCubic1(b: 'flt', c: 'flt', d: 'flt') -> "flt":
    """solveCubic1(flt b, flt c, flt d) -> flt"""
    return _sim2d.solveCubic1(b, c, d)

def solveCubic(a1: 'flt', a2: 'flt', a3: 'flt', closeto: 'flt'=0) -> "flt":
    """
    solveCubic(flt a1, flt a2, flt a3, flt closeto=0) -> flt
    solveCubic(flt a1, flt a2, flt a3) -> flt
    """
    return _sim2d.solveCubic(a1, a2, a3, closeto)
class collectionNoseHoover(collection):
    """Proxy of C++ collectionNoseHoover class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNoseHoover, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNoseHoover, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q, flt const T, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionNoseHoover
        __init__(collectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q, flt const T, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionNoseHoover
        __init__(collectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q, flt const T, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionNoseHoover
        __init__(collectionNoseHoover self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q, flt const T) -> collectionNoseHoover
        """
        this = _sim2d.new_collectionNoseHoover(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionNoseHoover self, flt newdt)"""
        return _sim2d.collectionNoseHoover_setdt(self, newdt)


    def setQ(self, newQ: 'flt') -> "void":
        """setQ(collectionNoseHoover self, flt newQ)"""
        return _sim2d.collectionNoseHoover_setQ(self, newQ)


    def resetBath(self) -> "void":
        """resetBath(collectionNoseHoover self)"""
        return _sim2d.collectionNoseHoover_resetBath(self)


    def timestep(self) -> "void":
        """timestep(collectionNoseHoover self)"""
        return _sim2d.collectionNoseHoover_timestep(self)


    def Hamiltonian(self) -> "flt":
        """Hamiltonian(collectionNoseHoover self) -> flt"""
        return _sim2d.collectionNoseHoover_Hamiltonian(self)


    def getxi(self) -> "flt":
        """getxi(collectionNoseHoover self) -> flt"""
        return _sim2d.collectionNoseHoover_getxi(self)


    def getlns(self) -> "flt":
        """getlns(collectionNoseHoover self) -> flt"""
        return _sim2d.collectionNoseHoover_getlns(self)

    __swig_destroy__ = _sim2d.delete_collectionNoseHoover
    __del__ = lambda self: None
collectionNoseHoover_swigregister = _sim2d.collectionNoseHoover_swigregister
collectionNoseHoover_swigregister(collectionNoseHoover)

class collectionGaussianT(collection):
    """Proxy of C++ collectionGaussianT class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGaussianT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGaussianT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGaussianT
        __init__(collectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGaussianT
        __init__(collectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGaussianT
        __init__(collectionGaussianT self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const Q) -> collectionGaussianT
        """
        this = _sim2d.new_collectionGaussianT(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionGaussianT self, flt newdt)"""
        return _sim2d.collectionGaussianT_setdt(self, newdt)


    def setQ(self, newQ: 'flt') -> "void":
        """setQ(collectionGaussianT self, flt newQ)"""
        return _sim2d.collectionGaussianT_setQ(self, newQ)


    def setForces(self, *args) -> "void":
        """
        setForces(collectionGaussianT self, bool seta=True)
        setForces(collectionGaussianT self)
        setForces(collectionGaussianT self, bool seta, bool setxi)
        """
        return _sim2d.collectionGaussianT_setForces(self, *args)


    def timestep(self) -> "void":
        """timestep(collectionGaussianT self)"""
        return _sim2d.collectionGaussianT_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionGaussianT
    __del__ = lambda self: None
collectionGaussianT_swigregister = _sim2d.collectionGaussianT_swigregister
collectionGaussianT_swigregister(collectionGaussianT)

class collectionGear3A(collection):
    """Proxy of C++ collectionGear3A class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear3A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear3A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear3A
        __init__(collectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear3A
        __init__(collectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear3A
        __init__(collectionGear3A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt) -> collectionGear3A
        """
        this = _sim2d.new_collectionGear3A(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionGear3A self)"""
        return _sim2d.collectionGear3A_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionGear3A self, flt newdt)"""
        return _sim2d.collectionGear3A_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionGear3A
    __del__ = lambda self: None
collectionGear3A_swigregister = _sim2d.collectionGear3A_swigregister
collectionGear3A_swigregister(collectionGear3A)

class collectionGear4A(collection):
    """Proxy of C++ collectionGear4A class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear4A
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear4A
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear4A
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps) -> collectionGear4A
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear4A
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear4A
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear4A
        __init__(collectionGear4A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt) -> collectionGear4A
        """
        this = _sim2d.new_collectionGear4A(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionGear4A self)"""
        return _sim2d.collectionGear4A_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionGear4A self, flt newdt)"""
        return _sim2d.collectionGear4A_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionGear4A
    __del__ = lambda self: None
collectionGear4A_swigregister = _sim2d.collectionGear4A_swigregister
collectionGear4A_swigregister(collectionGear4A)

class collectionGear5A(collection):
    """Proxy of C++ collectionGear5A class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear5A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear5A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear5A
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear5A
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear5A
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps) -> collectionGear5A
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear5A
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear5A
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear5A
        __init__(collectionGear5A self, boost::shared_ptr< Box > box, flt const dt, boost::shared_ptr< atomgroup > atoms) -> collectionGear5A
        """
        this = _sim2d.new_collectionGear5A(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionGear5A self)"""
        return _sim2d.collectionGear5A_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionGear5A self, flt newdt)"""
        return _sim2d.collectionGear5A_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionGear5A
    __del__ = lambda self: None
collectionGear5A_swigregister = _sim2d.collectionGear5A_swigregister
collectionGear5A_swigregister(collectionGear5A)

class collectionGear6A(collection):
    """Proxy of C++ collectionGear6A class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear6A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear6A, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear6A
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear6A
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear6A
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps) -> collectionGear6A
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear6A
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear6A
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear6A
        __init__(collectionGear6A self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > atoms, flt const dt) -> collectionGear6A
        """
        this = _sim2d.new_collectionGear6A(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionGear6A self)"""
        return _sim2d.collectionGear6A_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionGear6A self, flt newdt)"""
        return _sim2d.collectionGear6A_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionGear6A
    __del__ = lambda self: None
collectionGear6A_swigregister = _sim2d.collectionGear6A_swigregister
collectionGear6A_swigregister(collectionGear6A)

class RK4data(_object):
    """Proxy of C++ RK4data class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RK4data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RK4data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Kxa"] = _sim2d.RK4data_Kxa_set
    __swig_getmethods__["Kxa"] = _sim2d.RK4data_Kxa_get
    if _newclass:
        Kxa = _swig_property(_sim2d.RK4data_Kxa_get, _sim2d.RK4data_Kxa_set)
    __swig_setmethods__["Kxb"] = _sim2d.RK4data_Kxb_set
    __swig_getmethods__["Kxb"] = _sim2d.RK4data_Kxb_get
    if _newclass:
        Kxb = _swig_property(_sim2d.RK4data_Kxb_get, _sim2d.RK4data_Kxb_set)
    __swig_setmethods__["Kxc"] = _sim2d.RK4data_Kxc_set
    __swig_getmethods__["Kxc"] = _sim2d.RK4data_Kxc_get
    if _newclass:
        Kxc = _swig_property(_sim2d.RK4data_Kxc_get, _sim2d.RK4data_Kxc_set)
    __swig_setmethods__["Kxd"] = _sim2d.RK4data_Kxd_set
    __swig_getmethods__["Kxd"] = _sim2d.RK4data_Kxd_get
    if _newclass:
        Kxd = _swig_property(_sim2d.RK4data_Kxd_get, _sim2d.RK4data_Kxd_set)
    __swig_setmethods__["Kva"] = _sim2d.RK4data_Kva_set
    __swig_getmethods__["Kva"] = _sim2d.RK4data_Kva_get
    if _newclass:
        Kva = _swig_property(_sim2d.RK4data_Kva_get, _sim2d.RK4data_Kva_set)
    __swig_setmethods__["Kvb"] = _sim2d.RK4data_Kvb_set
    __swig_getmethods__["Kvb"] = _sim2d.RK4data_Kvb_get
    if _newclass:
        Kvb = _swig_property(_sim2d.RK4data_Kvb_get, _sim2d.RK4data_Kvb_set)
    __swig_setmethods__["Kvc"] = _sim2d.RK4data_Kvc_set
    __swig_getmethods__["Kvc"] = _sim2d.RK4data_Kvc_get
    if _newclass:
        Kvc = _swig_property(_sim2d.RK4data_Kvc_get, _sim2d.RK4data_Kvc_set)
    __swig_setmethods__["Kvd"] = _sim2d.RK4data_Kvd_set
    __swig_getmethods__["Kvd"] = _sim2d.RK4data_Kvd_get
    if _newclass:
        Kvd = _swig_property(_sim2d.RK4data_Kvd_get, _sim2d.RK4data_Kvd_set)

    def __init__(self):
        """__init__(RK4data self) -> RK4data"""
        this = _sim2d.new_RK4data()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_RK4data
    __del__ = lambda self: None
RK4data_swigregister = _sim2d.RK4data_swigregister
RK4data_swigregister(RK4data)

class collectionRK4(collection):
    """Proxy of C++ collectionRK4 class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionRK4, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > ratoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionRK4
        __init__(collectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > ratoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionRK4
        __init__(collectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > ratoms, flt const dt, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionRK4
        __init__(collectionRK4 self, boost::shared_ptr< Box > box, boost::shared_ptr< atomgroup > ratoms, flt const dt) -> collectionRK4
        """
        this = _sim2d.new_collectionRK4(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionRK4 self)"""
        return _sim2d.collectionRK4_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionRK4 self, flt newdt)"""
        return _sim2d.collectionRK4_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionRK4
    __del__ = lambda self: None
collectionRK4_swigregister = _sim2d.collectionRK4_swigregister
collectionRK4_swigregister(collectionRK4)

class collectionGear4NPH(collection):
    """Proxy of C++ collectionGear4NPH class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPH, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPH, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear4NPH
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear4NPH
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear4NPH
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q, uint ncorrectionsteps) -> collectionGear4NPH
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear4NPH
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear4NPH
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionGear4NPH
        __init__(collectionGear4NPH self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const Q) -> collectionGear4NPH
        """
        this = _sim2d.new_collectionGear4NPH(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionGear4NPH self)"""
        return _sim2d.collectionGear4NPH_timestep(self)


    def kinetic(self) -> "flt":
        """kinetic(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_kinetic(self)


    def temp(self, minuscomv: 'bool'=True) -> "flt":
        """
        temp(collectionGear4NPH self, bool minuscomv=True) -> flt
        temp(collectionGear4NPH self) -> flt
        """
        return _sim2d.collectionGear4NPH_temp(self, minuscomv)


    def Hamiltonian(self) -> "flt":
        """Hamiltonian(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_Hamiltonian(self)


    def getdV(self) -> "flt":
        """getdV(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_getdV(self)


    def getddV(self) -> "flt":
        """getddV(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_getddV(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionGear4NPH self, flt newdt)"""
        return _sim2d.collectionGear4NPH_setdt(self, newdt)

    __swig_destroy__ = _sim2d.delete_collectionGear4NPH
    __del__ = lambda self: None
collectionGear4NPH_swigregister = _sim2d.collectionGear4NPH_swigregister
collectionGear4NPH_swigregister(collectionGear4NPH)

class xrpsummer(fpairxFunct):
    """Proxy of C++ xrpsummer class"""
    __swig_setmethods__ = {}
    for _s in [fpairxFunct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, xrpsummer, name, value)
    __swig_getmethods__ = {}
    for _s in [fpairxFunct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, xrpsummer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["xsum"] = _sim2d.xrpsummer_xsum_set
    __swig_getmethods__["xsum"] = _sim2d.xrpsummer_xsum_get
    if _newclass:
        xsum = _swig_property(_sim2d.xrpsummer_xsum_get, _sim2d.xrpsummer_xsum_set)
    __swig_setmethods__["rpxsum"] = _sim2d.xrpsummer_rpxsum_set
    __swig_getmethods__["rpxsum"] = _sim2d.xrpsummer_rpxsum_get
    if _newclass:
        rpxsum = _swig_property(_sim2d.xrpsummer_rpxsum_get, _sim2d.xrpsummer_rpxsum_set)
    __swig_setmethods__["vfsum"] = _sim2d.xrpsummer_vfsum_set
    __swig_getmethods__["vfsum"] = _sim2d.xrpsummer_vfsum_get
    if _newclass:
        vfsum = _swig_property(_sim2d.xrpsummer_vfsum_get, _sim2d.xrpsummer_vfsum_set)
    __swig_setmethods__["rfsum"] = _sim2d.xrpsummer_rfsum_set
    __swig_getmethods__["rfsum"] = _sim2d.xrpsummer_rfsum_get
    if _newclass:
        rfsum = _swig_property(_sim2d.xrpsummer_rfsum_get, _sim2d.xrpsummer_rfsum_set)

    def __init__(self, box: 'boost::shared_ptr< Box >'):
        """__init__(xrpsummer self, boost::shared_ptr< Box > box) -> xrpsummer"""
        this = _sim2d.new_xrpsummer(box)
        try:
            self.this.append(this)
        except:
            self.this = this

    def run(self, arg2: 'forcepairx') -> "void":
        """run(xrpsummer self, forcepairx arg2)"""
        return _sim2d.xrpsummer_run(self, arg2)


    def reset(self) -> "void":
        """reset(xrpsummer self)"""
        return _sim2d.xrpsummer_reset(self)

    __swig_destroy__ = _sim2d.delete_xrpsummer
    __del__ = lambda self: None
xrpsummer_swigregister = _sim2d.xrpsummer_swigregister
xrpsummer_swigregister(xrpsummer)

class collectionGear4NPT(collection):
    """Proxy of C++ collectionGear4NPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.collectionGear4NPT_dt_set
    __swig_getmethods__["dt"] = _sim2d.collectionGear4NPT_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.collectionGear4NPT_dt_get, _sim2d.collectionGear4NPT_dt_set)
    __swig_setmethods__["xrpsums"] = _sim2d.collectionGear4NPT_xrpsums_set
    __swig_getmethods__["xrpsums"] = _sim2d.collectionGear4NPT_xrpsums_get
    if _newclass:
        xrpsums = _swig_property(_sim2d.collectionGear4NPT_xrpsums_get, _sim2d.collectionGear4NPT_xrpsums_set)
    __swig_setmethods__["ncorrec"] = _sim2d.collectionGear4NPT_ncorrec_set
    __swig_getmethods__["ncorrec"] = _sim2d.collectionGear4NPT_ncorrec_get
    if _newclass:
        ncorrec = _swig_property(_sim2d.collectionGear4NPT_ncorrec_get, _sim2d.collectionGear4NPT_ncorrec_set)
    __swig_setmethods__["V1"] = _sim2d.collectionGear4NPT_V1_set
    __swig_getmethods__["V1"] = _sim2d.collectionGear4NPT_V1_get
    if _newclass:
        V1 = _swig_property(_sim2d.collectionGear4NPT_V1_get, _sim2d.collectionGear4NPT_V1_set)
    __swig_setmethods__["V2"] = _sim2d.collectionGear4NPT_V2_set
    __swig_getmethods__["V2"] = _sim2d.collectionGear4NPT_V2_get
    if _newclass:
        V2 = _swig_property(_sim2d.collectionGear4NPT_V2_get, _sim2d.collectionGear4NPT_V2_set)
    __swig_setmethods__["V3"] = _sim2d.collectionGear4NPT_V3_set
    __swig_getmethods__["V3"] = _sim2d.collectionGear4NPT_V3_get
    if _newclass:
        V3 = _swig_property(_sim2d.collectionGear4NPT_V3_get, _sim2d.collectionGear4NPT_V3_set)
    __swig_setmethods__["chi"] = _sim2d.collectionGear4NPT_chi_set
    __swig_getmethods__["chi"] = _sim2d.collectionGear4NPT_chi_get
    if _newclass:
        chi = _swig_property(_sim2d.collectionGear4NPT_chi_get, _sim2d.collectionGear4NPT_chi_set)
    __swig_setmethods__["chixi"] = _sim2d.collectionGear4NPT_chixi_set
    __swig_getmethods__["chixi"] = _sim2d.collectionGear4NPT_chixi_get
    if _newclass:
        chixi = _swig_property(_sim2d.collectionGear4NPT_chixi_get, _sim2d.collectionGear4NPT_chixi_set)
    __swig_setmethods__["xs1"] = _sim2d.collectionGear4NPT_xs1_set
    __swig_getmethods__["xs1"] = _sim2d.collectionGear4NPT_xs1_get
    if _newclass:
        xs1 = _swig_property(_sim2d.collectionGear4NPT_xs1_get, _sim2d.collectionGear4NPT_xs1_set)
    __swig_setmethods__["xs2"] = _sim2d.collectionGear4NPT_xs2_set
    __swig_getmethods__["xs2"] = _sim2d.collectionGear4NPT_xs2_get
    if _newclass:
        xs2 = _swig_property(_sim2d.collectionGear4NPT_xs2_get, _sim2d.collectionGear4NPT_xs2_set)
    __swig_setmethods__["xs3"] = _sim2d.collectionGear4NPT_xs3_set
    __swig_getmethods__["xs3"] = _sim2d.collectionGear4NPT_xs3_get
    if _newclass:
        xs3 = _swig_property(_sim2d.collectionGear4NPT_xs3_get, _sim2d.collectionGear4NPT_xs3_set)
    __swig_setmethods__["vs2"] = _sim2d.collectionGear4NPT_vs2_set
    __swig_getmethods__["vs2"] = _sim2d.collectionGear4NPT_vs2_get
    if _newclass:
        vs2 = _swig_property(_sim2d.collectionGear4NPT_vs2_get, _sim2d.collectionGear4NPT_vs2_set)
    __swig_setmethods__["vs3"] = _sim2d.collectionGear4NPT_vs3_set
    __swig_getmethods__["vs3"] = _sim2d.collectionGear4NPT_vs3_get
    if _newclass:
        vs3 = _swig_property(_sim2d.collectionGear4NPT_vs3_get, _sim2d.collectionGear4NPT_vs3_set)

    def resetbs(self) -> "void":
        """resetbs(collectionGear4NPT self)"""
        return _sim2d.collectionGear4NPT_resetbs(self)


    def tointerpair(arg1: 'std::vector< boost::shared_ptr< interactionpairsx > > &') -> "std::vector< boost::shared_ptr< interaction > >":
        """tointerpair(std::vector< boost::shared_ptr< interactionpairsx > > & arg1) -> std::vector< boost::shared_ptr< interaction > >"""
        return _sim2d.collectionGear4NPT_tointerpair(arg1)

    if _newclass:
        tointerpair = staticmethod(tointerpair)
    __swig_getmethods__["tointerpair"] = lambda x: tointerpair

    def __init__(self, *args):
        """
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interactionpairsx > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear4NPT
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interactionpairsx > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear4NPT
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps, std::vector< boost::shared_ptr< interactionpairsx > > interactions) -> collectionGear4NPT
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, uint ncorrectionsteps) -> collectionGear4NPT
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interactionpairsx > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionGear4NPT
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interactionpairsx > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionGear4NPT
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< atomgroup > atoms, std::vector< boost::shared_ptr< interactionpairsx > > interactions) -> collectionGear4NPT
        __init__(collectionGear4NPT self, boost::shared_ptr< OriginBox > box, flt const dt, boost::shared_ptr< atomgroup > atoms) -> collectionGear4NPT
        """
        this = _sim2d.new_collectionGear4NPT(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setForces(self, seta: 'bool'=True) -> "void":
        """
        setForces(collectionGear4NPT self, bool seta=True)
        setForces(collectionGear4NPT self)
        """
        return _sim2d.collectionGear4NPT_setForces(self, seta)


    def timestep(self) -> "void":
        """timestep(collectionGear4NPT self)"""
        return _sim2d.collectionGear4NPT_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionGear4NPT
    __del__ = lambda self: None
collectionGear4NPT_swigregister = _sim2d.collectionGear4NPT_swigregister
collectionGear4NPT_swigregister(collectionGear4NPT)

def collectionGear4NPT_tointerpair(arg2: 'std::vector< boost::shared_ptr< interactionpairsx > > &') -> "std::vector< boost::shared_ptr< interaction > >":
    """collectionGear4NPT_tointerpair(std::vector< boost::shared_ptr< interactionpairsx > > & arg2) -> std::vector< boost::shared_ptr< interaction > >"""
    return _sim2d.collectionGear4NPT_tointerpair(arg2)

class collectionVerletNPT(collection):
    """Proxy of C++ collectionVerletNPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerletNPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerletNPT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.collectionVerletNPT_dt_set
    __swig_getmethods__["dt"] = _sim2d.collectionVerletNPT_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.collectionVerletNPT_dt_get, _sim2d.collectionVerletNPT_dt_set)
    __swig_setmethods__["eta"] = _sim2d.collectionVerletNPT_eta_set
    __swig_getmethods__["eta"] = _sim2d.collectionVerletNPT_eta_get
    if _newclass:
        eta = _swig_property(_sim2d.collectionVerletNPT_eta_get, _sim2d.collectionVerletNPT_eta_set)
    __swig_setmethods__["xidot"] = _sim2d.collectionVerletNPT_xidot_set
    __swig_getmethods__["xidot"] = _sim2d.collectionVerletNPT_xidot_get
    if _newclass:
        xidot = _swig_property(_sim2d.collectionVerletNPT_xidot_get, _sim2d.collectionVerletNPT_xidot_set)
    __swig_setmethods__["lastxidot"] = _sim2d.collectionVerletNPT_lastxidot_set
    __swig_getmethods__["lastxidot"] = _sim2d.collectionVerletNPT_lastxidot_get
    if _newclass:
        lastxidot = _swig_property(_sim2d.collectionVerletNPT_lastxidot_get, _sim2d.collectionVerletNPT_lastxidot_set)
    __swig_setmethods__["lastV"] = _sim2d.collectionVerletNPT_lastV_set
    __swig_getmethods__["lastV"] = _sim2d.collectionVerletNPT_lastV_get
    if _newclass:
        lastV = _swig_property(_sim2d.collectionVerletNPT_lastV_get, _sim2d.collectionVerletNPT_lastV_set)
    __swig_setmethods__["etasum"] = _sim2d.collectionVerletNPT_etasum_set
    __swig_getmethods__["etasum"] = _sim2d.collectionVerletNPT_etasum_get
    if _newclass:
        etasum = _swig_property(_sim2d.collectionVerletNPT_etasum_get, _sim2d.collectionVerletNPT_etasum_set)
    __swig_setmethods__["vhalf"] = _sim2d.collectionVerletNPT_vhalf_set
    __swig_getmethods__["vhalf"] = _sim2d.collectionVerletNPT_vhalf_get
    if _newclass:
        vhalf = _swig_property(_sim2d.collectionVerletNPT_vhalf_get, _sim2d.collectionVerletNPT_vhalf_set)
    __swig_setmethods__["P"] = _sim2d.collectionVerletNPT_P_set
    __swig_getmethods__["P"] = _sim2d.collectionVerletNPT_P_get
    if _newclass:
        P = _swig_property(_sim2d.collectionVerletNPT_P_get, _sim2d.collectionVerletNPT_P_set)
    __swig_setmethods__["QP"] = _sim2d.collectionVerletNPT_QP_set
    __swig_getmethods__["QP"] = _sim2d.collectionVerletNPT_QP_get
    if _newclass:
        QP = _swig_property(_sim2d.collectionVerletNPT_QP_get, _sim2d.collectionVerletNPT_QP_set)
    __swig_setmethods__["T"] = _sim2d.collectionVerletNPT_T_set
    __swig_getmethods__["T"] = _sim2d.collectionVerletNPT_T_get
    if _newclass:
        T = _swig_property(_sim2d.collectionVerletNPT_T_get, _sim2d.collectionVerletNPT_T_set)
    __swig_setmethods__["QT"] = _sim2d.collectionVerletNPT_QT_set
    __swig_getmethods__["QT"] = _sim2d.collectionVerletNPT_QT_get
    if _newclass:
        QT = _swig_property(_sim2d.collectionVerletNPT_QT_get, _sim2d.collectionVerletNPT_QT_set)
    __swig_setmethods__["curP"] = _sim2d.collectionVerletNPT_curP_set
    __swig_getmethods__["curP"] = _sim2d.collectionVerletNPT_curP_get
    if _newclass:
        curP = _swig_property(_sim2d.collectionVerletNPT_curP_get, _sim2d.collectionVerletNPT_curP_set)

    def resetvhalf(self) -> "void":
        """resetvhalf(collectionVerletNPT self)"""
        return _sim2d.collectionVerletNPT_resetvhalf(self)


    def __init__(self, *args):
        """
        __init__(collectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionVerletNPT
        __init__(collectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionVerletNPT
        __init__(collectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionVerletNPT
        __init__(collectionVerletNPT self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const P, flt const QP, flt const T, flt const QT) -> collectionVerletNPT
        """
        this = _sim2d.new_collectionVerletNPT(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def timestep(self) -> "void":
        """timestep(collectionVerletNPT self)"""
        return _sim2d.collectionVerletNPT_timestep(self)


    def setdt(self, newdt: 'flt') -> "void":
        """setdt(collectionVerletNPT self, flt newdt)"""
        return _sim2d.collectionVerletNPT_setdt(self, newdt)


    def resetcomv(self) -> "void":
        """resetcomv(collectionVerletNPT self)"""
        return _sim2d.collectionVerletNPT_resetcomv(self)


    def resetL(self) -> "void":
        """resetL(collectionVerletNPT self)"""
        return _sim2d.collectionVerletNPT_resetL(self)


    def scaleVs(self, scaleby: 'flt') -> "void":
        """scaleVs(collectionVerletNPT self, flt scaleby)"""
        return _sim2d.collectionVerletNPT_scaleVs(self, scaleby)


    def scaleVelocitiesT(self, T: 'flt') -> "void":
        """scaleVelocitiesT(collectionVerletNPT self, flt T)"""
        return _sim2d.collectionVerletNPT_scaleVelocitiesT(self, T)


    def scaleVelocitiesE(self, E: 'flt') -> "void":
        """scaleVelocitiesE(collectionVerletNPT self, flt E)"""
        return _sim2d.collectionVerletNPT_scaleVelocitiesE(self, E)


    def geteta(self) -> "flt":
        """geteta(collectionVerletNPT self) -> flt"""
        return _sim2d.collectionVerletNPT_geteta(self)


    def getxidot(self) -> "flt":
        """getxidot(collectionVerletNPT self) -> flt"""
        return _sim2d.collectionVerletNPT_getxidot(self)


    def getP(self) -> "flt":
        """getP(collectionVerletNPT self) -> flt"""
        return _sim2d.collectionVerletNPT_getP(self)


    def getvhalf(self, n: 'uint') -> "Vec":
        """getvhalf(collectionVerletNPT self, uint n) -> Vec"""
        return _sim2d.collectionVerletNPT_getvhalf(self, n)


    def Hamiltonian(self) -> "flt":
        """Hamiltonian(collectionVerletNPT self) -> flt"""
        return _sim2d.collectionVerletNPT_Hamiltonian(self)

    __swig_destroy__ = _sim2d.delete_collectionVerletNPT
    __del__ = lambda self: None
collectionVerletNPT_swigregister = _sim2d.collectionVerletNPT_swigregister
collectionVerletNPT_swigregister(collectionVerletNPT)

class event(_object):
    """Proxy of C++ event class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, event, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, event, name)
    __repr__ = _swig_repr
    __swig_setmethods__["t"] = _sim2d.event_t_set
    __swig_getmethods__["t"] = _sim2d.event_t_get
    if _newclass:
        t = _swig_property(_sim2d.event_t_get, _sim2d.event_t_set)
    __swig_setmethods__["a"] = _sim2d.event_a_set
    __swig_getmethods__["a"] = _sim2d.event_a_get
    if _newclass:
        a = _swig_property(_sim2d.event_a_get, _sim2d.event_a_set)
    __swig_setmethods__["b"] = _sim2d.event_b_set
    __swig_getmethods__["b"] = _sim2d.event_b_get
    if _newclass:
        b = _swig_property(_sim2d.event_b_get, _sim2d.event_b_set)

    def __lt__(self, other: 'event') -> "bool":
        """__lt__(event self, event other) -> bool"""
        return _sim2d.event___lt__(self, other)


    def __init__(self):
        """__init__(event self) -> event"""
        this = _sim2d.new_event()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sim2d.delete_event
    __del__ = lambda self: None
event_swigregister = _sim2d.event_swigregister
event_swigregister(event)


def get_max(v: 'dvector') -> "flt":
    """get_max(dvector v) -> flt"""
    return _sim2d.get_max(v)
class collectionCDBDgrid(collection):
    """Proxy of C++ collectionCDBDgrid class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionCDBDgrid, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionCDBDgrid, name)
    __repr__ = _swig_repr
    __swig_setmethods__["T"] = _sim2d.collectionCDBDgrid_T_set
    __swig_getmethods__["T"] = _sim2d.collectionCDBDgrid_T_get
    if _newclass:
        T = _swig_property(_sim2d.collectionCDBDgrid_T_get, _sim2d.collectionCDBDgrid_T_set)
    __swig_setmethods__["dt"] = _sim2d.collectionCDBDgrid_dt_set
    __swig_getmethods__["dt"] = _sim2d.collectionCDBDgrid_dt_get
    if _newclass:
        dt = _swig_property(_sim2d.collectionCDBDgrid_dt_get, _sim2d.collectionCDBDgrid_dt_set)
    __swig_setmethods__["curt"] = _sim2d.collectionCDBDgrid_curt_set
    __swig_getmethods__["curt"] = _sim2d.collectionCDBDgrid_curt_get
    if _newclass:
        curt = _swig_property(_sim2d.collectionCDBDgrid_curt_get, _sim2d.collectionCDBDgrid_curt_set)
    __swig_setmethods__["numevents"] = _sim2d.collectionCDBDgrid_numevents_set
    __swig_getmethods__["numevents"] = _sim2d.collectionCDBDgrid_numevents_get
    if _newclass:
        numevents = _swig_property(_sim2d.collectionCDBDgrid_numevents_get, _sim2d.collectionCDBDgrid_numevents_set)
    __swig_setmethods__["events"] = _sim2d.collectionCDBDgrid_events_set
    __swig_getmethods__["events"] = _sim2d.collectionCDBDgrid_events_get
    if _newclass:
        events = _swig_property(_sim2d.collectionCDBDgrid_events_get, _sim2d.collectionCDBDgrid_events_set)
    __swig_setmethods__["atomsizes"] = _sim2d.collectionCDBDgrid_atomsizes_set
    __swig_getmethods__["atomsizes"] = _sim2d.collectionCDBDgrid_atomsizes_get
    if _newclass:
        atomsizes = _swig_property(_sim2d.collectionCDBDgrid_atomsizes_get, _sim2d.collectionCDBDgrid_atomsizes_set)
    __swig_setmethods__["edge_epsilon"] = _sim2d.collectionCDBDgrid_edge_epsilon_set
    __swig_getmethods__["edge_epsilon"] = _sim2d.collectionCDBDgrid_edge_epsilon_get
    if _newclass:
        edge_epsilon = _swig_property(_sim2d.collectionCDBDgrid_edge_epsilon_get, _sim2d.collectionCDBDgrid_edge_epsilon_set)

    def reset_events(self, force: 'bool'=True) -> "void":
        """
        reset_events(collectionCDBDgrid self, bool force=True)
        reset_events(collectionCDBDgrid self)
        """
        return _sim2d.collectionCDBDgrid_reset_events(self, force)


    def line_advance(self, deltat: 'flt') -> "void":
        """line_advance(collectionCDBDgrid self, flt deltat)"""
        return _sim2d.collectionCDBDgrid_line_advance(self, deltat)

    __swig_setmethods__["grid"] = _sim2d.collectionCDBDgrid_grid_set
    __swig_getmethods__["grid"] = _sim2d.collectionCDBDgrid_grid_get
    if _newclass:
        grid = _swig_property(_sim2d.collectionCDBDgrid_grid_get, _sim2d.collectionCDBDgrid_grid_set)
    __swig_setmethods__["gridt"] = _sim2d.collectionCDBDgrid_gridt_set
    __swig_getmethods__["gridt"] = _sim2d.collectionCDBDgrid_gridt_get
    if _newclass:
        gridt = _swig_property(_sim2d.collectionCDBDgrid_gridt_get, _sim2d.collectionCDBDgrid_gridt_set)

    def next_event(self, a: 'atomid') -> "event":
        """next_event(collectionCDBDgrid self, atomid a) -> event"""
        return _sim2d.collectionCDBDgrid_next_event(self, a)


    def __init__(self, *args):
        """
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionCDBDgrid
        __init__(collectionCDBDgrid self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes) -> collectionCDBDgrid
        """
        this = _sim2d.new_collectionCDBDgrid(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update_grid(self, force: 'bool'=True) -> "void":
        """
        update_grid(collectionCDBDgrid self, bool force=True)
        update_grid(collectionCDBDgrid self)
        """
        return _sim2d.collectionCDBDgrid_update_grid(self, force)


    def get_grid(self) -> "Grid &":
        """get_grid(collectionCDBDgrid self) -> Grid"""
        return _sim2d.collectionCDBDgrid_get_grid(self)


    def get_epsilon(self) -> "flt":
        """get_epsilon(collectionCDBDgrid self) -> flt"""
        return _sim2d.collectionCDBDgrid_get_epsilon(self)


    def set_epsilon(self, eps: 'flt') -> "void":
        """set_epsilon(collectionCDBDgrid self, flt eps)"""
        return _sim2d.collectionCDBDgrid_set_epsilon(self, eps)


    def reset_velocities(self) -> "void":
        """reset_velocities(collectionCDBDgrid self)"""
        return _sim2d.collectionCDBDgrid_reset_velocities(self)


    def take_step(self, tlim: 'flt'=-1) -> "bool":
        """
        take_step(collectionCDBDgrid self, flt tlim=-1) -> bool
        take_step(collectionCDBDgrid self) -> bool
        """
        return _sim2d.collectionCDBDgrid_take_step(self, tlim)


    def timestep(self) -> "void":
        """timestep(collectionCDBDgrid self)"""
        return _sim2d.collectionCDBDgrid_timestep(self)


    def events_processed(self) -> "long long":
        """events_processed(collectionCDBDgrid self) -> long long"""
        return _sim2d.collectionCDBDgrid_events_processed(self)

    __swig_destroy__ = _sim2d.delete_collectionCDBDgrid
    __del__ = lambda self: None
collectionCDBDgrid_swigregister = _sim2d.collectionCDBDgrid_swigregister
collectionCDBDgrid_swigregister(collectionCDBDgrid)

class collectionCDBD(collection):
    """Proxy of C++ collectionCDBD class"""
    __swig_setmethods__ = {}
    for _s in [collection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionCDBD, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionCDBD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, dvector sizes) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers, std::vector< boost::shared_ptr< constraint > > constraints) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes, std::vector< boost::shared_ptr< interaction > > interactions, std::vector< boost::shared_ptr< statetracker > > trackers) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes, std::vector< boost::shared_ptr< interaction > > interactions) -> collectionCDBD
        __init__(collectionCDBD self, boost::shared_ptr< OriginBox > box, boost::shared_ptr< atomgroup > atoms, flt const dt, flt const T, flt sizes) -> collectionCDBD
        """
        this = _sim2d.new_collectionCDBD(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset_velocities(self) -> "void":
        """reset_velocities(collectionCDBD self)"""
        return _sim2d.collectionCDBD_reset_velocities(self)


    def take_step(self, tlim: 'flt'=-1) -> "bool":
        """
        take_step(collectionCDBD self, flt tlim=-1) -> bool
        take_step(collectionCDBD self) -> bool
        """
        return _sim2d.collectionCDBD_take_step(self, tlim)


    def timestep(self) -> "void":
        """timestep(collectionCDBD self)"""
        return _sim2d.collectionCDBD_timestep(self)


    def events_processed(self) -> "long long":
        """events_processed(collectionCDBD self) -> long long"""
        return _sim2d.collectionCDBD_events_processed(self)

    __swig_destroy__ = _sim2d.delete_collectionCDBD
    __del__ = lambda self: None
collectionCDBD_swigregister = _sim2d.collectionCDBD_swigregister
collectionCDBD_swigregister(collectionCDBD)


def make_event(box: 'Box', e: 'event', a: 'atomid', b: 'atomid', sigma: 'flt', curt: 'flt') -> "bool":
    """make_event(Box box, event e, atomid a, atomid b, flt sigma, flt curt) -> bool"""
    return _sim2d.make_event(box, e, a, b, sigma, curt)

def collide(box: 'Box', a: 'atom', b: 'atom') -> "void":
    """collide(Box box, atom a, atom b)"""
    return _sim2d.collide(box, a, b)
# This file is compatible with both classic and new-style classes.


